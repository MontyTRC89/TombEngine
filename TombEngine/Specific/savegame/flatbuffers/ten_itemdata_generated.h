// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_
#define FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_

#include "flatbuffers/flatbuffers.h"

namespace TEN {
namespace Save {

struct Position;

struct CreatureTarget;
struct CreatureTargetBuilder;
struct CreatureTargetT;

struct Creature;
struct CreatureBuilder;
struct CreatureT;

struct LaserHead;
struct LaserHeadBuilder;
struct LaserHeadT;

struct QuadBike;
struct QuadBikeBuilder;
struct QuadBikeT;

struct BigGun;
struct BigGunBuilder;
struct BigGunT;

struct Motorbike;
struct MotorbikeBuilder;
struct MotorbikeT;

struct Jeep;
struct JeepBuilder;
struct JeepT;

struct Kayak;
struct KayakBuilder;
struct KayakT;

struct Door;
struct DoorBuilder;
struct DoorT;

struct Skidoo;
struct SkidooBuilder;
struct SkidooT;

struct UPV;
struct UPVBuilder;
struct UPVT;

struct Motorboat;
struct MotorboatBuilder;
struct MotorboatT;

struct GameVector;
struct GameVectorBuilder;
struct GameVectorT;

struct Wraith;
struct WraithBuilder;
struct WraithT;

struct Rubberboat;
struct RubberboatBuilder;
struct RubberboatT;

struct Pushable;
struct PushableBuilder;
struct PushableT;

struct Minecart;
struct MinecartBuilder;
struct MinecartT;

struct LaraInfo;
struct LaraInfoBuilder;
struct LaraInfoT;

struct ItemNumber;
struct ItemNumberBuilder;
struct ItemNumberT;

struct Short;
struct ShortBuilder;
struct ShortT;

struct Int;
struct IntBuilder;
struct IntT;

struct Float;
struct FloatBuilder;
struct FloatT;

struct ShortArray;
struct ShortArrayBuilder;
struct ShortArrayT;

struct Vector3;

struct Vector4;

enum class ItemData : uint8_t {
  NONE = 0,
  Int = 1,
  Short = 2,
  Float = 3,
  ShortArray = 4,
  ItemNumber = 5,
  Creature = 6,
  LaserHead = 7,
  QuadBike = 8,
  BigGun = 9,
  Motorbike = 10,
  Jeep = 11,
  LaraInfo = 12,
  Kayak = 13,
  Door = 14,
  Skidoo = 15,
  UPV = 16,
  Motorboat = 17,
  GameVector = 18,
  Wraith = 19,
  Rubberboat = 20,
  Pushable = 21,
  Minecart = 22,
  MIN = NONE,
  MAX = Minecart
};

inline const ItemData (&EnumValuesItemData())[23] {
  static const ItemData values[] = {
    ItemData::NONE,
    ItemData::Int,
    ItemData::Short,
    ItemData::Float,
    ItemData::ShortArray,
    ItemData::ItemNumber,
    ItemData::Creature,
    ItemData::LaserHead,
    ItemData::QuadBike,
    ItemData::BigGun,
    ItemData::Motorbike,
    ItemData::Jeep,
    ItemData::LaraInfo,
    ItemData::Kayak,
    ItemData::Door,
    ItemData::Skidoo,
    ItemData::UPV,
    ItemData::Motorboat,
    ItemData::GameVector,
    ItemData::Wraith,
    ItemData::Rubberboat,
    ItemData::Pushable,
    ItemData::Minecart
  };
  return values;
}

inline const char * const *EnumNamesItemData() {
  static const char * const names[24] = {
    "NONE",
    "Int",
    "Short",
    "Float",
    "ShortArray",
    "ItemNumber",
    "Creature",
    "LaserHead",
    "QuadBike",
    "BigGun",
    "Motorbike",
    "Jeep",
    "LaraInfo",
    "Kayak",
    "Door",
    "Skidoo",
    "UPV",
    "Motorboat",
    "GameVector",
    "Wraith",
    "Rubberboat",
    "Pushable",
    "Minecart",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemData(ItemData e) {
  if (flatbuffers::IsOutRange(e, ItemData::NONE, ItemData::Minecart)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemData()[index];
}

template<typename T> struct ItemDataTraits {
  static const ItemData enum_value = ItemData::NONE;
};

template<> struct ItemDataTraits<TEN::Save::Int> {
  static const ItemData enum_value = ItemData::Int;
};

template<> struct ItemDataTraits<TEN::Save::Short> {
  static const ItemData enum_value = ItemData::Short;
};

template<> struct ItemDataTraits<TEN::Save::Float> {
  static const ItemData enum_value = ItemData::Float;
};

template<> struct ItemDataTraits<TEN::Save::ShortArray> {
  static const ItemData enum_value = ItemData::ShortArray;
};

template<> struct ItemDataTraits<TEN::Save::ItemNumber> {
  static const ItemData enum_value = ItemData::ItemNumber;
};

template<> struct ItemDataTraits<TEN::Save::Creature> {
  static const ItemData enum_value = ItemData::Creature;
};

template<> struct ItemDataTraits<TEN::Save::LaserHead> {
  static const ItemData enum_value = ItemData::LaserHead;
};

template<> struct ItemDataTraits<TEN::Save::QuadBike> {
  static const ItemData enum_value = ItemData::QuadBike;
};

template<> struct ItemDataTraits<TEN::Save::BigGun> {
  static const ItemData enum_value = ItemData::BigGun;
};

template<> struct ItemDataTraits<TEN::Save::Motorbike> {
  static const ItemData enum_value = ItemData::Motorbike;
};

template<> struct ItemDataTraits<TEN::Save::Jeep> {
  static const ItemData enum_value = ItemData::Jeep;
};

template<> struct ItemDataTraits<TEN::Save::LaraInfo> {
  static const ItemData enum_value = ItemData::LaraInfo;
};

template<> struct ItemDataTraits<TEN::Save::Kayak> {
  static const ItemData enum_value = ItemData::Kayak;
};

template<> struct ItemDataTraits<TEN::Save::Door> {
  static const ItemData enum_value = ItemData::Door;
};

template<> struct ItemDataTraits<TEN::Save::Skidoo> {
  static const ItemData enum_value = ItemData::Skidoo;
};

template<> struct ItemDataTraits<TEN::Save::UPV> {
  static const ItemData enum_value = ItemData::UPV;
};

template<> struct ItemDataTraits<TEN::Save::Motorboat> {
  static const ItemData enum_value = ItemData::Motorboat;
};

template<> struct ItemDataTraits<TEN::Save::GameVector> {
  static const ItemData enum_value = ItemData::GameVector;
};

template<> struct ItemDataTraits<TEN::Save::Wraith> {
  static const ItemData enum_value = ItemData::Wraith;
};

template<> struct ItemDataTraits<TEN::Save::Rubberboat> {
  static const ItemData enum_value = ItemData::Rubberboat;
};

template<> struct ItemDataTraits<TEN::Save::Pushable> {
  static const ItemData enum_value = ItemData::Pushable;
};

template<> struct ItemDataTraits<TEN::Save::Minecart> {
  static const ItemData enum_value = ItemData::Minecart;
};

struct ItemDataUnion {
  ItemData type;
  void *value;

  ItemDataUnion() : type(ItemData::NONE), value(nullptr) {}
  ItemDataUnion(ItemDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ItemData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ItemDataUnion(const ItemDataUnion &);
  ItemDataUnion &operator=(const ItemDataUnion &u)
    { ItemDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ItemDataUnion &operator=(ItemDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ItemDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ItemDataTraits<typename RT::TableType>::enum_value;
    if (type != ItemData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ItemData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TEN::Save::IntT *AsInt() {
    return type == ItemData::Int ?
      reinterpret_cast<TEN::Save::IntT *>(value) : nullptr;
  }
  const TEN::Save::IntT *AsInt() const {
    return type == ItemData::Int ?
      reinterpret_cast<const TEN::Save::IntT *>(value) : nullptr;
  }
  TEN::Save::ShortT *AsShort() {
    return type == ItemData::Short ?
      reinterpret_cast<TEN::Save::ShortT *>(value) : nullptr;
  }
  const TEN::Save::ShortT *AsShort() const {
    return type == ItemData::Short ?
      reinterpret_cast<const TEN::Save::ShortT *>(value) : nullptr;
  }
  TEN::Save::FloatT *AsFloat() {
    return type == ItemData::Float ?
      reinterpret_cast<TEN::Save::FloatT *>(value) : nullptr;
  }
  const TEN::Save::FloatT *AsFloat() const {
    return type == ItemData::Float ?
      reinterpret_cast<const TEN::Save::FloatT *>(value) : nullptr;
  }
  TEN::Save::ShortArrayT *AsShortArray() {
    return type == ItemData::ShortArray ?
      reinterpret_cast<TEN::Save::ShortArrayT *>(value) : nullptr;
  }
  const TEN::Save::ShortArrayT *AsShortArray() const {
    return type == ItemData::ShortArray ?
      reinterpret_cast<const TEN::Save::ShortArrayT *>(value) : nullptr;
  }
  TEN::Save::ItemNumberT *AsItemNumber() {
    return type == ItemData::ItemNumber ?
      reinterpret_cast<TEN::Save::ItemNumberT *>(value) : nullptr;
  }
  const TEN::Save::ItemNumberT *AsItemNumber() const {
    return type == ItemData::ItemNumber ?
      reinterpret_cast<const TEN::Save::ItemNumberT *>(value) : nullptr;
  }
  TEN::Save::CreatureT *AsCreature() {
    return type == ItemData::Creature ?
      reinterpret_cast<TEN::Save::CreatureT *>(value) : nullptr;
  }
  const TEN::Save::CreatureT *AsCreature() const {
    return type == ItemData::Creature ?
      reinterpret_cast<const TEN::Save::CreatureT *>(value) : nullptr;
  }
  TEN::Save::LaserHeadT *AsLaserHead() {
    return type == ItemData::LaserHead ?
      reinterpret_cast<TEN::Save::LaserHeadT *>(value) : nullptr;
  }
  const TEN::Save::LaserHeadT *AsLaserHead() const {
    return type == ItemData::LaserHead ?
      reinterpret_cast<const TEN::Save::LaserHeadT *>(value) : nullptr;
  }
  TEN::Save::QuadBikeT *AsQuadBike() {
    return type == ItemData::QuadBike ?
      reinterpret_cast<TEN::Save::QuadBikeT *>(value) : nullptr;
  }
  const TEN::Save::QuadBikeT *AsQuadBike() const {
    return type == ItemData::QuadBike ?
      reinterpret_cast<const TEN::Save::QuadBikeT *>(value) : nullptr;
  }
  TEN::Save::BigGunT *AsBigGun() {
    return type == ItemData::BigGun ?
      reinterpret_cast<TEN::Save::BigGunT *>(value) : nullptr;
  }
  const TEN::Save::BigGunT *AsBigGun() const {
    return type == ItemData::BigGun ?
      reinterpret_cast<const TEN::Save::BigGunT *>(value) : nullptr;
  }
  TEN::Save::MotorbikeT *AsMotorbike() {
    return type == ItemData::Motorbike ?
      reinterpret_cast<TEN::Save::MotorbikeT *>(value) : nullptr;
  }
  const TEN::Save::MotorbikeT *AsMotorbike() const {
    return type == ItemData::Motorbike ?
      reinterpret_cast<const TEN::Save::MotorbikeT *>(value) : nullptr;
  }
  TEN::Save::JeepT *AsJeep() {
    return type == ItemData::Jeep ?
      reinterpret_cast<TEN::Save::JeepT *>(value) : nullptr;
  }
  const TEN::Save::JeepT *AsJeep() const {
    return type == ItemData::Jeep ?
      reinterpret_cast<const TEN::Save::JeepT *>(value) : nullptr;
  }
  TEN::Save::LaraInfoT *AsLaraInfo() {
    return type == ItemData::LaraInfo ?
      reinterpret_cast<TEN::Save::LaraInfoT *>(value) : nullptr;
  }
  const TEN::Save::LaraInfoT *AsLaraInfo() const {
    return type == ItemData::LaraInfo ?
      reinterpret_cast<const TEN::Save::LaraInfoT *>(value) : nullptr;
  }
  TEN::Save::KayakT *AsKayak() {
    return type == ItemData::Kayak ?
      reinterpret_cast<TEN::Save::KayakT *>(value) : nullptr;
  }
  const TEN::Save::KayakT *AsKayak() const {
    return type == ItemData::Kayak ?
      reinterpret_cast<const TEN::Save::KayakT *>(value) : nullptr;
  }
  TEN::Save::DoorT *AsDoor() {
    return type == ItemData::Door ?
      reinterpret_cast<TEN::Save::DoorT *>(value) : nullptr;
  }
  const TEN::Save::DoorT *AsDoor() const {
    return type == ItemData::Door ?
      reinterpret_cast<const TEN::Save::DoorT *>(value) : nullptr;
  }
  TEN::Save::SkidooT *AsSkidoo() {
    return type == ItemData::Skidoo ?
      reinterpret_cast<TEN::Save::SkidooT *>(value) : nullptr;
  }
  const TEN::Save::SkidooT *AsSkidoo() const {
    return type == ItemData::Skidoo ?
      reinterpret_cast<const TEN::Save::SkidooT *>(value) : nullptr;
  }
  TEN::Save::UPVT *AsUPV() {
    return type == ItemData::UPV ?
      reinterpret_cast<TEN::Save::UPVT *>(value) : nullptr;
  }
  const TEN::Save::UPVT *AsUPV() const {
    return type == ItemData::UPV ?
      reinterpret_cast<const TEN::Save::UPVT *>(value) : nullptr;
  }
  TEN::Save::MotorboatT *AsMotorboat() {
    return type == ItemData::Motorboat ?
      reinterpret_cast<TEN::Save::MotorboatT *>(value) : nullptr;
  }
  const TEN::Save::MotorboatT *AsMotorboat() const {
    return type == ItemData::Motorboat ?
      reinterpret_cast<const TEN::Save::MotorboatT *>(value) : nullptr;
  }
  TEN::Save::GameVectorT *AsGameVector() {
    return type == ItemData::GameVector ?
      reinterpret_cast<TEN::Save::GameVectorT *>(value) : nullptr;
  }
  const TEN::Save::GameVectorT *AsGameVector() const {
    return type == ItemData::GameVector ?
      reinterpret_cast<const TEN::Save::GameVectorT *>(value) : nullptr;
  }
  TEN::Save::WraithT *AsWraith() {
    return type == ItemData::Wraith ?
      reinterpret_cast<TEN::Save::WraithT *>(value) : nullptr;
  }
  const TEN::Save::WraithT *AsWraith() const {
    return type == ItemData::Wraith ?
      reinterpret_cast<const TEN::Save::WraithT *>(value) : nullptr;
  }
  TEN::Save::RubberboatT *AsRubberboat() {
    return type == ItemData::Rubberboat ?
      reinterpret_cast<TEN::Save::RubberboatT *>(value) : nullptr;
  }
  const TEN::Save::RubberboatT *AsRubberboat() const {
    return type == ItemData::Rubberboat ?
      reinterpret_cast<const TEN::Save::RubberboatT *>(value) : nullptr;
  }
  TEN::Save::PushableT *AsPushable() {
    return type == ItemData::Pushable ?
      reinterpret_cast<TEN::Save::PushableT *>(value) : nullptr;
  }
  const TEN::Save::PushableT *AsPushable() const {
    return type == ItemData::Pushable ?
      reinterpret_cast<const TEN::Save::PushableT *>(value) : nullptr;
  }
  TEN::Save::MinecartT *AsMinecart() {
    return type == ItemData::Minecart ?
      reinterpret_cast<TEN::Save::MinecartT *>(value) : nullptr;
  }
  const TEN::Save::MinecartT *AsMinecart() const {
    return type == ItemData::Minecart ?
      reinterpret_cast<const TEN::Save::MinecartT *>(value) : nullptr;
  }
};

bool VerifyItemData(flatbuffers::Verifier &verifier, const void *obj, ItemData type);
bool VerifyItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_pos_;
  int32_t y_pos_;
  int32_t z_pos_;
  int32_t x_rot_;
  int32_t y_rot_;
  int32_t z_rot_;

 public:
  struct Traits;
  Position()
      : x_pos_(0),
        y_pos_(0),
        z_pos_(0),
        x_rot_(0),
        y_rot_(0),
        z_rot_(0) {
  }
  Position(int32_t _x_pos, int32_t _y_pos, int32_t _z_pos, int32_t _x_rot, int32_t _y_rot, int32_t _z_rot)
      : x_pos_(flatbuffers::EndianScalar(_x_pos)),
        y_pos_(flatbuffers::EndianScalar(_y_pos)),
        z_pos_(flatbuffers::EndianScalar(_z_pos)),
        x_rot_(flatbuffers::EndianScalar(_x_rot)),
        y_rot_(flatbuffers::EndianScalar(_y_rot)),
        z_rot_(flatbuffers::EndianScalar(_z_rot)) {
  }
  int32_t x_pos() const {
    return flatbuffers::EndianScalar(x_pos_);
  }
  int32_t y_pos() const {
    return flatbuffers::EndianScalar(y_pos_);
  }
  int32_t z_pos() const {
    return flatbuffers::EndianScalar(z_pos_);
  }
  int32_t x_rot() const {
    return flatbuffers::EndianScalar(x_rot_);
  }
  int32_t y_rot() const {
    return flatbuffers::EndianScalar(y_rot_);
  }
  int32_t z_rot() const {
    return flatbuffers::EndianScalar(z_rot_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 24);

struct Position::Traits {
  using type = Position;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  struct Traits;
  Vector3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 12);

struct Vector3::Traits {
  using type = Vector3;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  struct Traits;
  Vector4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vector4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vector4, 16);

struct Vector4::Traits {
  using type = Vector4;
};

struct CreatureTargetT : public flatbuffers::NativeTable {
  typedef CreatureTarget TableType;
  int32_t object_number = 0;
  int32_t room_number = 0;
  int32_t box_number = 0;
  int32_t flags = 0;
  int32_t trigger_flags = 0;
  std::unique_ptr<TEN::Save::Position> position{};
};

struct CreatureTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureTargetT NativeTableType;
  typedef CreatureTargetBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NUMBER = 4,
    VT_ROOM_NUMBER = 6,
    VT_BOX_NUMBER = 8,
    VT_FLAGS = 10,
    VT_TRIGGER_FLAGS = 12,
    VT_POSITION = 14
  };
  int32_t object_number() const {
    return GetField<int32_t>(VT_OBJECT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t box_number() const {
    return GetField<int32_t>(VT_BOX_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t trigger_flags() const {
    return GetField<int32_t>(VT_TRIGGER_FLAGS, 0);
  }
  const TEN::Save::Position *position() const {
    return GetStruct<const TEN::Save::Position *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_BOX_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TRIGGER_FLAGS) &&
           VerifyField<TEN::Save::Position>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
  CreatureTargetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureTargetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreatureTarget> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureTargetBuilder {
  typedef CreatureTarget Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_number(int32_t object_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_box_number(int32_t box_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_BOX_NUMBER, box_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_FLAGS, flags, 0);
  }
  void add_trigger_flags(int32_t trigger_flags) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_TRIGGER_FLAGS, trigger_flags, 0);
  }
  void add_position(const TEN::Save::Position *position) {
    fbb_.AddStruct(CreatureTarget::VT_POSITION, position);
  }
  explicit CreatureTargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreatureTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureTarget>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t object_number = 0,
    int32_t room_number = 0,
    int32_t box_number = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    const TEN::Save::Position *position = 0) {
  CreatureTargetBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_trigger_flags(trigger_flags);
  builder_.add_flags(flags);
  builder_.add_box_number(box_number);
  builder_.add_room_number(room_number);
  builder_.add_object_number(object_number);
  return builder_.Finish();
}

struct CreatureTarget::Traits {
  using type = CreatureTarget;
  static auto constexpr Create = CreateCreatureTarget;
};

flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreatureT : public flatbuffers::NativeTable {
  typedef Creature TableType;
  int32_t maximum_turn = 0;
  std::vector<int32_t> joint_rotation{};
  bool head_left = false;
  bool head_right = false;
  bool patrol = false;
  bool alerted = false;
  bool reached_goal = false;
  bool jump_ahead = false;
  bool monkey_swing_ahead = false;
  bool friendly = false;
  bool poisoned = false;
  bool hurt_by_lara = false;
  int32_t tosspad = 0;
  int32_t location_ai = 0;
  int32_t fired_weapon = 0;
  int32_t mood = 0;
  int32_t enemy = 0;
  int32_t ai_target_number = 0;
  int32_t flags = 0;
  bool can_jump = false;
  bool can_monkey = false;
  bool is_amphibious = false;
  bool is_jumping = false;
  bool is_monkeying = false;
};

struct Creature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureT NativeTableType;
  typedef CreatureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXIMUM_TURN = 4,
    VT_JOINT_ROTATION = 6,
    VT_HEAD_LEFT = 8,
    VT_HEAD_RIGHT = 10,
    VT_PATROL = 12,
    VT_ALERTED = 14,
    VT_REACHED_GOAL = 16,
    VT_JUMP_AHEAD = 18,
    VT_MONKEY_SWING_AHEAD = 20,
    VT_FRIENDLY = 22,
    VT_POISONED = 24,
    VT_HURT_BY_LARA = 26,
    VT_TOSSPAD = 28,
    VT_LOCATION_AI = 30,
    VT_FIRED_WEAPON = 32,
    VT_MOOD = 34,
    VT_ENEMY = 36,
    VT_AI_TARGET_NUMBER = 38,
    VT_FLAGS = 40,
    VT_CAN_JUMP = 42,
    VT_CAN_MONKEY = 44,
    VT_IS_AMPHIBIOUS = 46,
    VT_IS_JUMPING = 48,
    VT_IS_MONKEYING = 50
  };
  int32_t maximum_turn() const {
    return GetField<int32_t>(VT_MAXIMUM_TURN, 0);
  }
  const flatbuffers::Vector<int32_t> *joint_rotation() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_JOINT_ROTATION);
  }
  bool head_left() const {
    return GetField<uint8_t>(VT_HEAD_LEFT, 0) != 0;
  }
  bool head_right() const {
    return GetField<uint8_t>(VT_HEAD_RIGHT, 0) != 0;
  }
  bool patrol() const {
    return GetField<uint8_t>(VT_PATROL, 0) != 0;
  }
  bool alerted() const {
    return GetField<uint8_t>(VT_ALERTED, 0) != 0;
  }
  bool reached_goal() const {
    return GetField<uint8_t>(VT_REACHED_GOAL, 0) != 0;
  }
  bool jump_ahead() const {
    return GetField<uint8_t>(VT_JUMP_AHEAD, 0) != 0;
  }
  bool monkey_swing_ahead() const {
    return GetField<uint8_t>(VT_MONKEY_SWING_AHEAD, 0) != 0;
  }
  bool friendly() const {
    return GetField<uint8_t>(VT_FRIENDLY, 0) != 0;
  }
  bool poisoned() const {
    return GetField<uint8_t>(VT_POISONED, 0) != 0;
  }
  bool hurt_by_lara() const {
    return GetField<uint8_t>(VT_HURT_BY_LARA, 0) != 0;
  }
  int32_t tosspad() const {
    return GetField<int32_t>(VT_TOSSPAD, 0);
  }
  int32_t location_ai() const {
    return GetField<int32_t>(VT_LOCATION_AI, 0);
  }
  int32_t fired_weapon() const {
    return GetField<int32_t>(VT_FIRED_WEAPON, 0);
  }
  int32_t mood() const {
    return GetField<int32_t>(VT_MOOD, 0);
  }
  int32_t enemy() const {
    return GetField<int32_t>(VT_ENEMY, 0);
  }
  int32_t ai_target_number() const {
    return GetField<int32_t>(VT_AI_TARGET_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool can_jump() const {
    return GetField<uint8_t>(VT_CAN_JUMP, 0) != 0;
  }
  bool can_monkey() const {
    return GetField<uint8_t>(VT_CAN_MONKEY, 0) != 0;
  }
  bool is_amphibious() const {
    return GetField<uint8_t>(VT_IS_AMPHIBIOUS, 0) != 0;
  }
  bool is_jumping() const {
    return GetField<uint8_t>(VT_IS_JUMPING, 0) != 0;
  }
  bool is_monkeying() const {
    return GetField<uint8_t>(VT_IS_MONKEYING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAXIMUM_TURN) &&
           VerifyOffset(verifier, VT_JOINT_ROTATION) &&
           verifier.VerifyVector(joint_rotation()) &&
           VerifyField<uint8_t>(verifier, VT_HEAD_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_HEAD_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_PATROL) &&
           VerifyField<uint8_t>(verifier, VT_ALERTED) &&
           VerifyField<uint8_t>(verifier, VT_REACHED_GOAL) &&
           VerifyField<uint8_t>(verifier, VT_JUMP_AHEAD) &&
           VerifyField<uint8_t>(verifier, VT_MONKEY_SWING_AHEAD) &&
           VerifyField<uint8_t>(verifier, VT_FRIENDLY) &&
           VerifyField<uint8_t>(verifier, VT_POISONED) &&
           VerifyField<uint8_t>(verifier, VT_HURT_BY_LARA) &&
           VerifyField<int32_t>(verifier, VT_TOSSPAD) &&
           VerifyField<int32_t>(verifier, VT_LOCATION_AI) &&
           VerifyField<int32_t>(verifier, VT_FIRED_WEAPON) &&
           VerifyField<int32_t>(verifier, VT_MOOD) &&
           VerifyField<int32_t>(verifier, VT_ENEMY) &&
           VerifyField<int32_t>(verifier, VT_AI_TARGET_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_CAN_JUMP) &&
           VerifyField<uint8_t>(verifier, VT_CAN_MONKEY) &&
           VerifyField<uint8_t>(verifier, VT_IS_AMPHIBIOUS) &&
           VerifyField<uint8_t>(verifier, VT_IS_JUMPING) &&
           VerifyField<uint8_t>(verifier, VT_IS_MONKEYING) &&
           verifier.EndTable();
  }
  CreatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Creature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureBuilder {
  typedef Creature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maximum_turn(int32_t maximum_turn) {
    fbb_.AddElement<int32_t>(Creature::VT_MAXIMUM_TURN, maximum_turn, 0);
  }
  void add_joint_rotation(flatbuffers::Offset<flatbuffers::Vector<int32_t>> joint_rotation) {
    fbb_.AddOffset(Creature::VT_JOINT_ROTATION, joint_rotation);
  }
  void add_head_left(bool head_left) {
    fbb_.AddElement<uint8_t>(Creature::VT_HEAD_LEFT, static_cast<uint8_t>(head_left), 0);
  }
  void add_head_right(bool head_right) {
    fbb_.AddElement<uint8_t>(Creature::VT_HEAD_RIGHT, static_cast<uint8_t>(head_right), 0);
  }
  void add_patrol(bool patrol) {
    fbb_.AddElement<uint8_t>(Creature::VT_PATROL, static_cast<uint8_t>(patrol), 0);
  }
  void add_alerted(bool alerted) {
    fbb_.AddElement<uint8_t>(Creature::VT_ALERTED, static_cast<uint8_t>(alerted), 0);
  }
  void add_reached_goal(bool reached_goal) {
    fbb_.AddElement<uint8_t>(Creature::VT_REACHED_GOAL, static_cast<uint8_t>(reached_goal), 0);
  }
  void add_jump_ahead(bool jump_ahead) {
    fbb_.AddElement<uint8_t>(Creature::VT_JUMP_AHEAD, static_cast<uint8_t>(jump_ahead), 0);
  }
  void add_monkey_swing_ahead(bool monkey_swing_ahead) {
    fbb_.AddElement<uint8_t>(Creature::VT_MONKEY_SWING_AHEAD, static_cast<uint8_t>(monkey_swing_ahead), 0);
  }
  void add_friendly(bool friendly) {
    fbb_.AddElement<uint8_t>(Creature::VT_FRIENDLY, static_cast<uint8_t>(friendly), 0);
  }
  void add_poisoned(bool poisoned) {
    fbb_.AddElement<uint8_t>(Creature::VT_POISONED, static_cast<uint8_t>(poisoned), 0);
  }
  void add_hurt_by_lara(bool hurt_by_lara) {
    fbb_.AddElement<uint8_t>(Creature::VT_HURT_BY_LARA, static_cast<uint8_t>(hurt_by_lara), 0);
  }
  void add_tosspad(int32_t tosspad) {
    fbb_.AddElement<int32_t>(Creature::VT_TOSSPAD, tosspad, 0);
  }
  void add_location_ai(int32_t location_ai) {
    fbb_.AddElement<int32_t>(Creature::VT_LOCATION_AI, location_ai, 0);
  }
  void add_fired_weapon(int32_t fired_weapon) {
    fbb_.AddElement<int32_t>(Creature::VT_FIRED_WEAPON, fired_weapon, 0);
  }
  void add_mood(int32_t mood) {
    fbb_.AddElement<int32_t>(Creature::VT_MOOD, mood, 0);
  }
  void add_enemy(int32_t enemy) {
    fbb_.AddElement<int32_t>(Creature::VT_ENEMY, enemy, 0);
  }
  void add_ai_target_number(int32_t ai_target_number) {
    fbb_.AddElement<int32_t>(Creature::VT_AI_TARGET_NUMBER, ai_target_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Creature::VT_FLAGS, flags, 0);
  }
  void add_can_jump(bool can_jump) {
    fbb_.AddElement<uint8_t>(Creature::VT_CAN_JUMP, static_cast<uint8_t>(can_jump), 0);
  }
  void add_can_monkey(bool can_monkey) {
    fbb_.AddElement<uint8_t>(Creature::VT_CAN_MONKEY, static_cast<uint8_t>(can_monkey), 0);
  }
  void add_is_amphibious(bool is_amphibious) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_AMPHIBIOUS, static_cast<uint8_t>(is_amphibious), 0);
  }
  void add_is_jumping(bool is_jumping) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_JUMPING, static_cast<uint8_t>(is_jumping), 0);
  }
  void add_is_monkeying(bool is_monkeying) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_MONKEYING, static_cast<uint8_t>(is_monkeying), 0);
  }
  explicit CreatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Creature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Creature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Creature> CreateCreature(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t maximum_turn = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> joint_rotation = 0,
    bool head_left = false,
    bool head_right = false,
    bool patrol = false,
    bool alerted = false,
    bool reached_goal = false,
    bool jump_ahead = false,
    bool monkey_swing_ahead = false,
    bool friendly = false,
    bool poisoned = false,
    bool hurt_by_lara = false,
    int32_t tosspad = 0,
    int32_t location_ai = 0,
    int32_t fired_weapon = 0,
    int32_t mood = 0,
    int32_t enemy = 0,
    int32_t ai_target_number = 0,
    int32_t flags = 0,
    bool can_jump = false,
    bool can_monkey = false,
    bool is_amphibious = false,
    bool is_jumping = false,
    bool is_monkeying = false) {
  CreatureBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_ai_target_number(ai_target_number);
  builder_.add_enemy(enemy);
  builder_.add_mood(mood);
  builder_.add_fired_weapon(fired_weapon);
  builder_.add_location_ai(location_ai);
  builder_.add_tosspad(tosspad);
  builder_.add_joint_rotation(joint_rotation);
  builder_.add_maximum_turn(maximum_turn);
  builder_.add_is_monkeying(is_monkeying);
  builder_.add_is_jumping(is_jumping);
  builder_.add_is_amphibious(is_amphibious);
  builder_.add_can_monkey(can_monkey);
  builder_.add_can_jump(can_jump);
  builder_.add_hurt_by_lara(hurt_by_lara);
  builder_.add_poisoned(poisoned);
  builder_.add_friendly(friendly);
  builder_.add_monkey_swing_ahead(monkey_swing_ahead);
  builder_.add_jump_ahead(jump_ahead);
  builder_.add_reached_goal(reached_goal);
  builder_.add_alerted(alerted);
  builder_.add_patrol(patrol);
  builder_.add_head_right(head_right);
  builder_.add_head_left(head_left);
  return builder_.Finish();
}

struct Creature::Traits {
  using type = Creature;
  static auto constexpr Create = CreateCreature;
};

inline flatbuffers::Offset<Creature> CreateCreatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t maximum_turn = 0,
    const std::vector<int32_t> *joint_rotation = nullptr,
    bool head_left = false,
    bool head_right = false,
    bool patrol = false,
    bool alerted = false,
    bool reached_goal = false,
    bool jump_ahead = false,
    bool monkey_swing_ahead = false,
    bool friendly = false,
    bool poisoned = false,
    bool hurt_by_lara = false,
    int32_t tosspad = 0,
    int32_t location_ai = 0,
    int32_t fired_weapon = 0,
    int32_t mood = 0,
    int32_t enemy = 0,
    int32_t ai_target_number = 0,
    int32_t flags = 0,
    bool can_jump = false,
    bool can_monkey = false,
    bool is_amphibious = false,
    bool is_jumping = false,
    bool is_monkeying = false) {
  auto joint_rotation__ = joint_rotation ? _fbb.CreateVector<int32_t>(*joint_rotation) : 0;
  return TEN::Save::CreateCreature(
      _fbb,
      maximum_turn,
      joint_rotation__,
      head_left,
      head_right,
      patrol,
      alerted,
      reached_goal,
      jump_ahead,
      monkey_swing_ahead,
      friendly,
      poisoned,
      hurt_by_lara,
      tosspad,
      location_ai,
      fired_weapon,
      mood,
      enemy,
      ai_target_number,
      flags,
      can_jump,
      can_monkey,
      is_amphibious,
      is_jumping,
      is_monkeying);
}

flatbuffers::Offset<Creature> CreateCreature(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserHeadT : public flatbuffers::NativeTable {
  typedef LaserHead TableType;
};

struct LaserHead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaserHeadT NativeTableType;
  typedef LaserHeadBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LaserHeadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserHeadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaserHead> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserHeadBuilder {
  typedef LaserHead Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LaserHeadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaserHead> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaserHead>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaserHead> CreateLaserHead(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LaserHeadBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LaserHead::Traits {
  using type = LaserHead;
  static auto constexpr Create = CreateLaserHead;
};

flatbuffers::Offset<LaserHead> CreateLaserHead(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuadBikeT : public flatbuffers::NativeTable {
  typedef QuadBike TableType;
  int32_t turn_rate = 0;
  int32_t front_rot = 0;
  int32_t rear_rot = 0;
  int32_t momentum_angle = 0;
  int32_t extra_rotation = 0;
  int32_t velocity = 0;
  int32_t left_vertical_velocity = 0;
  int32_t right_vertical_velocity = 0;
  int32_t revs = 0;
  int32_t engine_revs = 0;
  int32_t pitch = 0;
  int32_t smoke_start = 0;
  bool can_start_drift = false;
  bool drift_starting = false;
  bool no_dismount = false;
  int32_t flags = 0;
};

struct QuadBike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuadBikeT NativeTableType;
  typedef QuadBikeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TURN_RATE = 4,
    VT_FRONT_ROT = 6,
    VT_REAR_ROT = 8,
    VT_MOMENTUM_ANGLE = 10,
    VT_EXTRA_ROTATION = 12,
    VT_VELOCITY = 14,
    VT_LEFT_VERTICAL_VELOCITY = 16,
    VT_RIGHT_VERTICAL_VELOCITY = 18,
    VT_REVS = 20,
    VT_ENGINE_REVS = 22,
    VT_PITCH = 24,
    VT_SMOKE_START = 26,
    VT_CAN_START_DRIFT = 28,
    VT_DRIFT_STARTING = 30,
    VT_NO_DISMOUNT = 32,
    VT_FLAGS = 34
  };
  int32_t turn_rate() const {
    return GetField<int32_t>(VT_TURN_RATE, 0);
  }
  int32_t front_rot() const {
    return GetField<int32_t>(VT_FRONT_ROT, 0);
  }
  int32_t rear_rot() const {
    return GetField<int32_t>(VT_REAR_ROT, 0);
  }
  int32_t momentum_angle() const {
    return GetField<int32_t>(VT_MOMENTUM_ANGLE, 0);
  }
  int32_t extra_rotation() const {
    return GetField<int32_t>(VT_EXTRA_ROTATION, 0);
  }
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t left_vertical_velocity() const {
    return GetField<int32_t>(VT_LEFT_VERTICAL_VELOCITY, 0);
  }
  int32_t right_vertical_velocity() const {
    return GetField<int32_t>(VT_RIGHT_VERTICAL_VELOCITY, 0);
  }
  int32_t revs() const {
    return GetField<int32_t>(VT_REVS, 0);
  }
  int32_t engine_revs() const {
    return GetField<int32_t>(VT_ENGINE_REVS, 0);
  }
  int32_t pitch() const {
    return GetField<int32_t>(VT_PITCH, 0);
  }
  int32_t smoke_start() const {
    return GetField<int32_t>(VT_SMOKE_START, 0);
  }
  bool can_start_drift() const {
    return GetField<uint8_t>(VT_CAN_START_DRIFT, 0) != 0;
  }
  bool drift_starting() const {
    return GetField<uint8_t>(VT_DRIFT_STARTING, 0) != 0;
  }
  bool no_dismount() const {
    return GetField<uint8_t>(VT_NO_DISMOUNT, 0) != 0;
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TURN_RATE) &&
           VerifyField<int32_t>(verifier, VT_FRONT_ROT) &&
           VerifyField<int32_t>(verifier, VT_REAR_ROT) &&
           VerifyField<int32_t>(verifier, VT_MOMENTUM_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_EXTRA_ROTATION) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_LEFT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_REVS) &&
           VerifyField<int32_t>(verifier, VT_ENGINE_REVS) &&
           VerifyField<int32_t>(verifier, VT_PITCH) &&
           VerifyField<int32_t>(verifier, VT_SMOKE_START) &&
           VerifyField<uint8_t>(verifier, VT_CAN_START_DRIFT) &&
           VerifyField<uint8_t>(verifier, VT_DRIFT_STARTING) &&
           VerifyField<uint8_t>(verifier, VT_NO_DISMOUNT) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  QuadBikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuadBikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuadBike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuadBikeBuilder {
  typedef QuadBike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turn_rate(int32_t turn_rate) {
    fbb_.AddElement<int32_t>(QuadBike::VT_TURN_RATE, turn_rate, 0);
  }
  void add_front_rot(int32_t front_rot) {
    fbb_.AddElement<int32_t>(QuadBike::VT_FRONT_ROT, front_rot, 0);
  }
  void add_rear_rot(int32_t rear_rot) {
    fbb_.AddElement<int32_t>(QuadBike::VT_REAR_ROT, rear_rot, 0);
  }
  void add_momentum_angle(int32_t momentum_angle) {
    fbb_.AddElement<int32_t>(QuadBike::VT_MOMENTUM_ANGLE, momentum_angle, 0);
  }
  void add_extra_rotation(int32_t extra_rotation) {
    fbb_.AddElement<int32_t>(QuadBike::VT_EXTRA_ROTATION, extra_rotation, 0);
  }
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(QuadBike::VT_VELOCITY, velocity, 0);
  }
  void add_left_vertical_velocity(int32_t left_vertical_velocity) {
    fbb_.AddElement<int32_t>(QuadBike::VT_LEFT_VERTICAL_VELOCITY, left_vertical_velocity, 0);
  }
  void add_right_vertical_velocity(int32_t right_vertical_velocity) {
    fbb_.AddElement<int32_t>(QuadBike::VT_RIGHT_VERTICAL_VELOCITY, right_vertical_velocity, 0);
  }
  void add_revs(int32_t revs) {
    fbb_.AddElement<int32_t>(QuadBike::VT_REVS, revs, 0);
  }
  void add_engine_revs(int32_t engine_revs) {
    fbb_.AddElement<int32_t>(QuadBike::VT_ENGINE_REVS, engine_revs, 0);
  }
  void add_pitch(int32_t pitch) {
    fbb_.AddElement<int32_t>(QuadBike::VT_PITCH, pitch, 0);
  }
  void add_smoke_start(int32_t smoke_start) {
    fbb_.AddElement<int32_t>(QuadBike::VT_SMOKE_START, smoke_start, 0);
  }
  void add_can_start_drift(bool can_start_drift) {
    fbb_.AddElement<uint8_t>(QuadBike::VT_CAN_START_DRIFT, static_cast<uint8_t>(can_start_drift), 0);
  }
  void add_drift_starting(bool drift_starting) {
    fbb_.AddElement<uint8_t>(QuadBike::VT_DRIFT_STARTING, static_cast<uint8_t>(drift_starting), 0);
  }
  void add_no_dismount(bool no_dismount) {
    fbb_.AddElement<uint8_t>(QuadBike::VT_NO_DISMOUNT, static_cast<uint8_t>(no_dismount), 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(QuadBike::VT_FLAGS, flags, 0);
  }
  explicit QuadBikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuadBike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuadBike>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuadBike> CreateQuadBike(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t turn_rate = 0,
    int32_t front_rot = 0,
    int32_t rear_rot = 0,
    int32_t momentum_angle = 0,
    int32_t extra_rotation = 0,
    int32_t velocity = 0,
    int32_t left_vertical_velocity = 0,
    int32_t right_vertical_velocity = 0,
    int32_t revs = 0,
    int32_t engine_revs = 0,
    int32_t pitch = 0,
    int32_t smoke_start = 0,
    bool can_start_drift = false,
    bool drift_starting = false,
    bool no_dismount = false,
    int32_t flags = 0) {
  QuadBikeBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_smoke_start(smoke_start);
  builder_.add_pitch(pitch);
  builder_.add_engine_revs(engine_revs);
  builder_.add_revs(revs);
  builder_.add_right_vertical_velocity(right_vertical_velocity);
  builder_.add_left_vertical_velocity(left_vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_extra_rotation(extra_rotation);
  builder_.add_momentum_angle(momentum_angle);
  builder_.add_rear_rot(rear_rot);
  builder_.add_front_rot(front_rot);
  builder_.add_turn_rate(turn_rate);
  builder_.add_no_dismount(no_dismount);
  builder_.add_drift_starting(drift_starting);
  builder_.add_can_start_drift(can_start_drift);
  return builder_.Finish();
}

struct QuadBike::Traits {
  using type = QuadBike;
  static auto constexpr Create = CreateQuadBike;
};

flatbuffers::Offset<QuadBike> CreateQuadBike(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BigGunT : public flatbuffers::NativeTable {
  typedef BigGun TableType;
};

struct BigGun FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BigGunT NativeTableType;
  typedef BigGunBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BigGunT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BigGunT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BigGun> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BigGunBuilder {
  typedef BigGun Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BigGunBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BigGun> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BigGun>(end);
    return o;
  }
};

inline flatbuffers::Offset<BigGun> CreateBigGun(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BigGunBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BigGun::Traits {
  using type = BigGun;
  static auto constexpr Create = CreateBigGun;
};

flatbuffers::Offset<BigGun> CreateBigGun(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotorbikeT : public flatbuffers::NativeTable {
  typedef Motorbike TableType;
};

struct Motorbike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotorbikeT NativeTableType;
  typedef MotorbikeBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MotorbikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotorbikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Motorbike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MotorbikeBuilder {
  typedef Motorbike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MotorbikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Motorbike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Motorbike>(end);
    return o;
  }
};

inline flatbuffers::Offset<Motorbike> CreateMotorbike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MotorbikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Motorbike::Traits {
  using type = Motorbike;
  static auto constexpr Create = CreateMotorbike;
};

flatbuffers::Offset<Motorbike> CreateMotorbike(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JeepT : public flatbuffers::NativeTable {
  typedef Jeep TableType;
};

struct Jeep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JeepT NativeTableType;
  typedef JeepBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  JeepT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JeepT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Jeep> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JeepT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JeepBuilder {
  typedef Jeep Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit JeepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Jeep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Jeep>(end);
    return o;
  }
};

inline flatbuffers::Offset<Jeep> CreateJeep(
    flatbuffers::FlatBufferBuilder &_fbb) {
  JeepBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Jeep::Traits {
  using type = Jeep;
  static auto constexpr Create = CreateJeep;
};

flatbuffers::Offset<Jeep> CreateJeep(flatbuffers::FlatBufferBuilder &_fbb, const JeepT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KayakT : public flatbuffers::NativeTable {
  typedef Kayak TableType;
  int32_t turn_rate = 0;
  int32_t velocity = 0;
  int32_t front_vertical_velocity = 0;
  int32_t left_vertical_velocity = 0;
  int32_t right_vertical_velocity = 0;
  int32_t left_right_count = 0;
  int32_t water_height = 0;
  std::unique_ptr<TEN::Save::Position> old_pos{};
  bool turn = false;
  bool forward = false;
  bool true_water = false;
  int32_t current_start_wake = 0;
  int32_t wake_shade = 0;
  int32_t flags = 0;
};

struct Kayak FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KayakT NativeTableType;
  typedef KayakBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TURN_RATE = 4,
    VT_VELOCITY = 6,
    VT_FRONT_VERTICAL_VELOCITY = 8,
    VT_LEFT_VERTICAL_VELOCITY = 10,
    VT_RIGHT_VERTICAL_VELOCITY = 12,
    VT_LEFT_RIGHT_COUNT = 14,
    VT_WATER_HEIGHT = 16,
    VT_OLD_POS = 18,
    VT_TURN = 20,
    VT_FORWARD = 22,
    VT_TRUE_WATER = 24,
    VT_CURRENT_START_WAKE = 26,
    VT_WAKE_SHADE = 28,
    VT_FLAGS = 30
  };
  int32_t turn_rate() const {
    return GetField<int32_t>(VT_TURN_RATE, 0);
  }
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t front_vertical_velocity() const {
    return GetField<int32_t>(VT_FRONT_VERTICAL_VELOCITY, 0);
  }
  int32_t left_vertical_velocity() const {
    return GetField<int32_t>(VT_LEFT_VERTICAL_VELOCITY, 0);
  }
  int32_t right_vertical_velocity() const {
    return GetField<int32_t>(VT_RIGHT_VERTICAL_VELOCITY, 0);
  }
  int32_t left_right_count() const {
    return GetField<int32_t>(VT_LEFT_RIGHT_COUNT, 0);
  }
  int32_t water_height() const {
    return GetField<int32_t>(VT_WATER_HEIGHT, 0);
  }
  const TEN::Save::Position *old_pos() const {
    return GetStruct<const TEN::Save::Position *>(VT_OLD_POS);
  }
  bool turn() const {
    return GetField<uint8_t>(VT_TURN, 0) != 0;
  }
  bool forward() const {
    return GetField<uint8_t>(VT_FORWARD, 0) != 0;
  }
  bool true_water() const {
    return GetField<uint8_t>(VT_TRUE_WATER, 0) != 0;
  }
  int32_t current_start_wake() const {
    return GetField<int32_t>(VT_CURRENT_START_WAKE, 0);
  }
  int32_t wake_shade() const {
    return GetField<int32_t>(VT_WAKE_SHADE, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TURN_RATE) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_FRONT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_LEFT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_LEFT_RIGHT_COUNT) &&
           VerifyField<int32_t>(verifier, VT_WATER_HEIGHT) &&
           VerifyField<TEN::Save::Position>(verifier, VT_OLD_POS) &&
           VerifyField<uint8_t>(verifier, VT_TURN) &&
           VerifyField<uint8_t>(verifier, VT_FORWARD) &&
           VerifyField<uint8_t>(verifier, VT_TRUE_WATER) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_START_WAKE) &&
           VerifyField<int32_t>(verifier, VT_WAKE_SHADE) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  KayakT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KayakT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Kayak> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KayakT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KayakBuilder {
  typedef Kayak Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turn_rate(int32_t turn_rate) {
    fbb_.AddElement<int32_t>(Kayak::VT_TURN_RATE, turn_rate, 0);
  }
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(Kayak::VT_VELOCITY, velocity, 0);
  }
  void add_front_vertical_velocity(int32_t front_vertical_velocity) {
    fbb_.AddElement<int32_t>(Kayak::VT_FRONT_VERTICAL_VELOCITY, front_vertical_velocity, 0);
  }
  void add_left_vertical_velocity(int32_t left_vertical_velocity) {
    fbb_.AddElement<int32_t>(Kayak::VT_LEFT_VERTICAL_VELOCITY, left_vertical_velocity, 0);
  }
  void add_right_vertical_velocity(int32_t right_vertical_velocity) {
    fbb_.AddElement<int32_t>(Kayak::VT_RIGHT_VERTICAL_VELOCITY, right_vertical_velocity, 0);
  }
  void add_left_right_count(int32_t left_right_count) {
    fbb_.AddElement<int32_t>(Kayak::VT_LEFT_RIGHT_COUNT, left_right_count, 0);
  }
  void add_water_height(int32_t water_height) {
    fbb_.AddElement<int32_t>(Kayak::VT_WATER_HEIGHT, water_height, 0);
  }
  void add_old_pos(const TEN::Save::Position *old_pos) {
    fbb_.AddStruct(Kayak::VT_OLD_POS, old_pos);
  }
  void add_turn(bool turn) {
    fbb_.AddElement<uint8_t>(Kayak::VT_TURN, static_cast<uint8_t>(turn), 0);
  }
  void add_forward(bool forward) {
    fbb_.AddElement<uint8_t>(Kayak::VT_FORWARD, static_cast<uint8_t>(forward), 0);
  }
  void add_true_water(bool true_water) {
    fbb_.AddElement<uint8_t>(Kayak::VT_TRUE_WATER, static_cast<uint8_t>(true_water), 0);
  }
  void add_current_start_wake(int32_t current_start_wake) {
    fbb_.AddElement<int32_t>(Kayak::VT_CURRENT_START_WAKE, current_start_wake, 0);
  }
  void add_wake_shade(int32_t wake_shade) {
    fbb_.AddElement<int32_t>(Kayak::VT_WAKE_SHADE, wake_shade, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Kayak::VT_FLAGS, flags, 0);
  }
  explicit KayakBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Kayak> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Kayak>(end);
    return o;
  }
};

inline flatbuffers::Offset<Kayak> CreateKayak(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t turn_rate = 0,
    int32_t velocity = 0,
    int32_t front_vertical_velocity = 0,
    int32_t left_vertical_velocity = 0,
    int32_t right_vertical_velocity = 0,
    int32_t left_right_count = 0,
    int32_t water_height = 0,
    const TEN::Save::Position *old_pos = 0,
    bool turn = false,
    bool forward = false,
    bool true_water = false,
    int32_t current_start_wake = 0,
    int32_t wake_shade = 0,
    int32_t flags = 0) {
  KayakBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_wake_shade(wake_shade);
  builder_.add_current_start_wake(current_start_wake);
  builder_.add_old_pos(old_pos);
  builder_.add_water_height(water_height);
  builder_.add_left_right_count(left_right_count);
  builder_.add_right_vertical_velocity(right_vertical_velocity);
  builder_.add_left_vertical_velocity(left_vertical_velocity);
  builder_.add_front_vertical_velocity(front_vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_turn_rate(turn_rate);
  builder_.add_true_water(true_water);
  builder_.add_forward(forward);
  builder_.add_turn(turn);
  return builder_.Finish();
}

struct Kayak::Traits {
  using type = Kayak;
  static auto constexpr Create = CreateKayak;
};

flatbuffers::Offset<Kayak> CreateKayak(flatbuffers::FlatBufferBuilder &_fbb, const KayakT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DoorT : public flatbuffers::NativeTable {
  typedef Door TableType;
};

struct Door FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoorT NativeTableType;
  typedef DoorBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DoorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Door> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoorBuilder {
  typedef Door Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DoorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Door> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Door>(end);
    return o;
  }
};

inline flatbuffers::Offset<Door> CreateDoor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DoorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Door::Traits {
  using type = Door;
  static auto constexpr Create = CreateDoor;
};

flatbuffers::Offset<Door> CreateDoor(flatbuffers::FlatBufferBuilder &_fbb, const DoorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkidooT : public flatbuffers::NativeTable {
  typedef Skidoo TableType;
};

struct Skidoo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkidooT NativeTableType;
  typedef SkidooBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SkidooT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkidooT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Skidoo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkidooBuilder {
  typedef Skidoo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkidooBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Skidoo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Skidoo>(end);
    return o;
  }
};

inline flatbuffers::Offset<Skidoo> CreateSkidoo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkidooBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Skidoo::Traits {
  using type = Skidoo;
  static auto constexpr Create = CreateSkidoo;
};

flatbuffers::Offset<Skidoo> CreateSkidoo(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPVT : public flatbuffers::NativeTable {
  typedef UPV TableType;
  int32_t velocity = 0;
  int32_t rot = 0;
  int32_t x_rot = 0;
  int32_t fan_rot = 0;
  int32_t harpoon_timer = 0;
  bool harpoon_left = false;
  int32_t flags = 0;
};

struct UPV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPVT NativeTableType;
  typedef UPVBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VELOCITY = 4,
    VT_ROT = 6,
    VT_X_ROT = 8,
    VT_FAN_ROT = 10,
    VT_HARPOON_TIMER = 12,
    VT_HARPOON_LEFT = 14,
    VT_FLAGS = 16
  };
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t rot() const {
    return GetField<int32_t>(VT_ROT, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t fan_rot() const {
    return GetField<int32_t>(VT_FAN_ROT, 0);
  }
  int32_t harpoon_timer() const {
    return GetField<int32_t>(VT_HARPOON_TIMER, 0);
  }
  bool harpoon_left() const {
    return GetField<uint8_t>(VT_HARPOON_LEFT, 0) != 0;
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_ROT) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_FAN_ROT) &&
           VerifyField<int32_t>(verifier, VT_HARPOON_TIMER) &&
           VerifyField<uint8_t>(verifier, VT_HARPOON_LEFT) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  UPVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPVBuilder {
  typedef UPV Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(UPV::VT_VELOCITY, velocity, 0);
  }
  void add_rot(int32_t rot) {
    fbb_.AddElement<int32_t>(UPV::VT_ROT, rot, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(UPV::VT_X_ROT, x_rot, 0);
  }
  void add_fan_rot(int32_t fan_rot) {
    fbb_.AddElement<int32_t>(UPV::VT_FAN_ROT, fan_rot, 0);
  }
  void add_harpoon_timer(int32_t harpoon_timer) {
    fbb_.AddElement<int32_t>(UPV::VT_HARPOON_TIMER, harpoon_timer, 0);
  }
  void add_harpoon_left(bool harpoon_left) {
    fbb_.AddElement<uint8_t>(UPV::VT_HARPOON_LEFT, static_cast<uint8_t>(harpoon_left), 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(UPV::VT_FLAGS, flags, 0);
  }
  explicit UPVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UPV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPV>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPV> CreateUPV(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t velocity = 0,
    int32_t rot = 0,
    int32_t x_rot = 0,
    int32_t fan_rot = 0,
    int32_t harpoon_timer = 0,
    bool harpoon_left = false,
    int32_t flags = 0) {
  UPVBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_harpoon_timer(harpoon_timer);
  builder_.add_fan_rot(fan_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_rot(rot);
  builder_.add_velocity(velocity);
  builder_.add_harpoon_left(harpoon_left);
  return builder_.Finish();
}

struct UPV::Traits {
  using type = UPV;
  static auto constexpr Create = CreateUPV;
};

flatbuffers::Offset<UPV> CreateUPV(flatbuffers::FlatBufferBuilder &_fbb, const UPVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotorboatT : public flatbuffers::NativeTable {
  typedef Motorboat TableType;
};

struct Motorboat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotorboatT NativeTableType;
  typedef MotorboatBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MotorboatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotorboatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Motorboat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MotorboatBuilder {
  typedef Motorboat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MotorboatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Motorboat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Motorboat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Motorboat> CreateMotorboat(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MotorboatBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Motorboat::Traits {
  using type = Motorboat;
  static auto constexpr Create = CreateMotorboat;
};

flatbuffers::Offset<Motorboat> CreateMotorboat(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameVectorT : public flatbuffers::NativeTable {
  typedef GameVector TableType;
};

struct GameVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GameVectorT NativeTableType;
  typedef GameVectorBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GameVectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameVectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GameVector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameVectorBuilder {
  typedef GameVector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GameVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GameVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameVector> CreateGameVector(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GameVectorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GameVector::Traits {
  using type = GameVector;
  static auto constexpr Create = CreateGameVector;
};

flatbuffers::Offset<GameVector> CreateGameVector(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WraithT : public flatbuffers::NativeTable {
  typedef Wraith TableType;
};

struct Wraith FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WraithT NativeTableType;
  typedef WraithBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WraithT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WraithT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Wraith> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WraithT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WraithBuilder {
  typedef Wraith Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WraithBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Wraith> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Wraith>(end);
    return o;
  }
};

inline flatbuffers::Offset<Wraith> CreateWraith(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WraithBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Wraith::Traits {
  using type = Wraith;
  static auto constexpr Create = CreateWraith;
};

flatbuffers::Offset<Wraith> CreateWraith(flatbuffers::FlatBufferBuilder &_fbb, const WraithT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RubberboatT : public flatbuffers::NativeTable {
  typedef Rubberboat TableType;
};

struct Rubberboat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RubberboatT NativeTableType;
  typedef RubberboatBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RubberboatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RubberboatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rubberboat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RubberboatBuilder {
  typedef Rubberboat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RubberboatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rubberboat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rubberboat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rubberboat> CreateRubberboat(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RubberboatBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rubberboat::Traits {
  using type = Rubberboat;
  static auto constexpr Create = CreateRubberboat;
};

flatbuffers::Offset<Rubberboat> CreateRubberboat(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PushableT : public flatbuffers::NativeTable {
  typedef Pushable TableType;
};

struct Pushable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PushableT NativeTableType;
  typedef PushableBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PushableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PushableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pushable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PushableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PushableBuilder {
  typedef Pushable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PushableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pushable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pushable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pushable> CreatePushable(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PushableBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Pushable::Traits {
  using type = Pushable;
  static auto constexpr Create = CreatePushable;
};

flatbuffers::Offset<Pushable> CreatePushable(flatbuffers::FlatBufferBuilder &_fbb, const PushableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinecartT : public flatbuffers::NativeTable {
  typedef Minecart TableType;
  int32_t turn_rot = 0;
  int32_t turn_x = 0;
  int32_t turn_z = 0;
  int32_t turn_len = 0;
  int32_t velocity = 0;
  int32_t vertical_velocity = 0;
  int32_t gradient = 0;
  int32_t stop_delay = 0;
  int32_t floor_height_middle = 0;
  int32_t floor_height_front = 0;
  int32_t flags = 0;
};

struct Minecart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinecartT NativeTableType;
  typedef MinecartBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TURN_ROT = 4,
    VT_TURN_X = 6,
    VT_TURN_Z = 8,
    VT_TURN_LEN = 10,
    VT_VELOCITY = 12,
    VT_VERTICAL_VELOCITY = 14,
    VT_GRADIENT = 16,
    VT_STOP_DELAY = 18,
    VT_FLOOR_HEIGHT_MIDDLE = 20,
    VT_FLOOR_HEIGHT_FRONT = 22,
    VT_FLAGS = 24
  };
  int32_t turn_rot() const {
    return GetField<int32_t>(VT_TURN_ROT, 0);
  }
  int32_t turn_x() const {
    return GetField<int32_t>(VT_TURN_X, 0);
  }
  int32_t turn_z() const {
    return GetField<int32_t>(VT_TURN_Z, 0);
  }
  int32_t turn_len() const {
    return GetField<int32_t>(VT_TURN_LEN, 0);
  }
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t vertical_velocity() const {
    return GetField<int32_t>(VT_VERTICAL_VELOCITY, 0);
  }
  int32_t gradient() const {
    return GetField<int32_t>(VT_GRADIENT, 0);
  }
  int32_t stop_delay() const {
    return GetField<int32_t>(VT_STOP_DELAY, 0);
  }
  int32_t floor_height_middle() const {
    return GetField<int32_t>(VT_FLOOR_HEIGHT_MIDDLE, 0);
  }
  int32_t floor_height_front() const {
    return GetField<int32_t>(VT_FLOOR_HEIGHT_FRONT, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TURN_ROT) &&
           VerifyField<int32_t>(verifier, VT_TURN_X) &&
           VerifyField<int32_t>(verifier, VT_TURN_Z) &&
           VerifyField<int32_t>(verifier, VT_TURN_LEN) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_GRADIENT) &&
           VerifyField<int32_t>(verifier, VT_STOP_DELAY) &&
           VerifyField<int32_t>(verifier, VT_FLOOR_HEIGHT_MIDDLE) &&
           VerifyField<int32_t>(verifier, VT_FLOOR_HEIGHT_FRONT) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  MinecartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinecartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Minecart> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinecartBuilder {
  typedef Minecart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turn_rot(int32_t turn_rot) {
    fbb_.AddElement<int32_t>(Minecart::VT_TURN_ROT, turn_rot, 0);
  }
  void add_turn_x(int32_t turn_x) {
    fbb_.AddElement<int32_t>(Minecart::VT_TURN_X, turn_x, 0);
  }
  void add_turn_z(int32_t turn_z) {
    fbb_.AddElement<int32_t>(Minecart::VT_TURN_Z, turn_z, 0);
  }
  void add_turn_len(int32_t turn_len) {
    fbb_.AddElement<int32_t>(Minecart::VT_TURN_LEN, turn_len, 0);
  }
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(Minecart::VT_VELOCITY, velocity, 0);
  }
  void add_vertical_velocity(int32_t vertical_velocity) {
    fbb_.AddElement<int32_t>(Minecart::VT_VERTICAL_VELOCITY, vertical_velocity, 0);
  }
  void add_gradient(int32_t gradient) {
    fbb_.AddElement<int32_t>(Minecart::VT_GRADIENT, gradient, 0);
  }
  void add_stop_delay(int32_t stop_delay) {
    fbb_.AddElement<int32_t>(Minecart::VT_STOP_DELAY, stop_delay, 0);
  }
  void add_floor_height_middle(int32_t floor_height_middle) {
    fbb_.AddElement<int32_t>(Minecart::VT_FLOOR_HEIGHT_MIDDLE, floor_height_middle, 0);
  }
  void add_floor_height_front(int32_t floor_height_front) {
    fbb_.AddElement<int32_t>(Minecart::VT_FLOOR_HEIGHT_FRONT, floor_height_front, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Minecart::VT_FLAGS, flags, 0);
  }
  explicit MinecartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Minecart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minecart>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minecart> CreateMinecart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t turn_rot = 0,
    int32_t turn_x = 0,
    int32_t turn_z = 0,
    int32_t turn_len = 0,
    int32_t velocity = 0,
    int32_t vertical_velocity = 0,
    int32_t gradient = 0,
    int32_t stop_delay = 0,
    int32_t floor_height_middle = 0,
    int32_t floor_height_front = 0,
    int32_t flags = 0) {
  MinecartBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_floor_height_front(floor_height_front);
  builder_.add_floor_height_middle(floor_height_middle);
  builder_.add_stop_delay(stop_delay);
  builder_.add_gradient(gradient);
  builder_.add_vertical_velocity(vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_turn_len(turn_len);
  builder_.add_turn_z(turn_z);
  builder_.add_turn_x(turn_x);
  builder_.add_turn_rot(turn_rot);
  return builder_.Finish();
}

struct Minecart::Traits {
  using type = Minecart;
  static auto constexpr Create = CreateMinecart;
};

flatbuffers::Offset<Minecart> CreateMinecart(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraInfoT : public flatbuffers::NativeTable {
  typedef LaraInfo TableType;
};

struct LaraInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraInfoT NativeTableType;
  typedef LaraInfoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LaraInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraInfoBuilder {
  typedef LaraInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LaraInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraInfo> CreateLaraInfo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LaraInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LaraInfo::Traits {
  using type = LaraInfo;
  static auto constexpr Create = CreateLaraInfo;
};

flatbuffers::Offset<LaraInfo> CreateLaraInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemNumberT : public flatbuffers::NativeTable {
  typedef ItemNumber TableType;
  int16_t num = 0;
};

struct ItemNumber FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemNumberT NativeTableType;
  typedef ItemNumberBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4
  };
  int16_t num() const {
    return GetField<int16_t>(VT_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_NUM) &&
           verifier.EndTable();
  }
  ItemNumberT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemNumberT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemNumber> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemNumberBuilder {
  typedef ItemNumber Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int16_t num) {
    fbb_.AddElement<int16_t>(ItemNumber::VT_NUM, num, 0);
  }
  explicit ItemNumberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemNumber>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemNumber> CreateItemNumber(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t num = 0) {
  ItemNumberBuilder builder_(_fbb);
  builder_.add_num(num);
  return builder_.Finish();
}

struct ItemNumber::Traits {
  using type = ItemNumber;
  static auto constexpr Create = CreateItemNumber;
};

flatbuffers::Offset<ItemNumber> CreateItemNumber(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShortT : public flatbuffers::NativeTable {
  typedef Short TableType;
  int16_t scalar = 0;
};

struct Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortT NativeTableType;
  typedef ShortBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  int16_t scalar() const {
    return GetField<int16_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  ShortT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShortT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Short> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShortBuilder {
  typedef Short Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(int16_t scalar) {
    fbb_.AddElement<int16_t>(Short::VT_SCALAR, scalar, 0);
  }
  explicit ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline flatbuffers::Offset<Short> CreateShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t scalar = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Short::Traits {
  using type = Short;
  static auto constexpr Create = CreateShort;
};

flatbuffers::Offset<Short> CreateShort(flatbuffers::FlatBufferBuilder &_fbb, const ShortT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntT : public flatbuffers::NativeTable {
  typedef Int TableType;
  int32_t scalar = 0;
};

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntT NativeTableType;
  typedef IntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  int32_t scalar() const {
    return GetField<int32_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  IntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Int> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntBuilder {
  typedef Int Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(int32_t scalar) {
    fbb_.AddElement<int32_t>(Int::VT_SCALAR, scalar, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scalar = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Int::Traits {
  using type = Int;
  static auto constexpr Create = CreateInt;
};

flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb, const IntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatT : public flatbuffers::NativeTable {
  typedef Float TableType;
  double scalar = 0.0;
};

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatT NativeTableType;
  typedef FloatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  double scalar() const {
    return GetField<double>(VT_SCALAR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  FloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Float> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatBuilder {
  typedef Float Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(double scalar) {
    fbb_.AddElement<double>(Float::VT_SCALAR, scalar, 0.0);
  }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float> CreateFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scalar = 0.0) {
  FloatBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Float::Traits {
  using type = Float;
  static auto constexpr Create = CreateFloat;
};

flatbuffers::Offset<Float> CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, const FloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShortArrayT : public flatbuffers::NativeTable {
  typedef ShortArray TableType;
  std::vector<int16_t> arr{};
};

struct ShortArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortArrayT NativeTableType;
  typedef ShortArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARR = 4
  };
  const flatbuffers::Vector<int16_t> *arr() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_ARR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARR) &&
           verifier.VerifyVector(arr()) &&
           verifier.EndTable();
  }
  ShortArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShortArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShortArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShortArrayBuilder {
  typedef ShortArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arr(flatbuffers::Offset<flatbuffers::Vector<int16_t>> arr) {
    fbb_.AddOffset(ShortArray::VT_ARR, arr);
  }
  explicit ShortArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShortArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortArray> CreateShortArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> arr = 0) {
  ShortArrayBuilder builder_(_fbb);
  builder_.add_arr(arr);
  return builder_.Finish();
}

struct ShortArray::Traits {
  using type = ShortArray;
  static auto constexpr Create = CreateShortArray;
};

inline flatbuffers::Offset<ShortArray> CreateShortArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *arr = nullptr) {
  auto arr__ = arr ? _fbb.CreateVector<int16_t>(*arr) : 0;
  return TEN::Save::CreateShortArray(
      _fbb,
      arr__);
}

flatbuffers::Offset<ShortArray> CreateShortArray(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CreatureTargetT *CreatureTarget::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CreatureTargetT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreatureTarget::UnPackTo(CreatureTargetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = box_number(); _o->box_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = trigger_flags(); _o->trigger_flags = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
}

inline flatbuffers::Offset<CreatureTarget> CreatureTarget::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreatureTarget(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureTargetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_number = _o->object_number;
  auto _room_number = _o->room_number;
  auto _box_number = _o->box_number;
  auto _flags = _o->flags;
  auto _trigger_flags = _o->trigger_flags;
  auto _position = _o->position ? _o->position.get() : 0;
  return TEN::Save::CreateCreatureTarget(
      _fbb,
      _object_number,
      _room_number,
      _box_number,
      _flags,
      _trigger_flags,
      _position);
}

inline CreatureT *Creature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CreatureT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Creature::UnPackTo(CreatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = maximum_turn(); _o->maximum_turn = _e; }
  { auto _e = joint_rotation(); if (_e) { _o->joint_rotation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->joint_rotation[_i] = _e->Get(_i); } } }
  { auto _e = head_left(); _o->head_left = _e; }
  { auto _e = head_right(); _o->head_right = _e; }
  { auto _e = patrol(); _o->patrol = _e; }
  { auto _e = alerted(); _o->alerted = _e; }
  { auto _e = reached_goal(); _o->reached_goal = _e; }
  { auto _e = jump_ahead(); _o->jump_ahead = _e; }
  { auto _e = monkey_swing_ahead(); _o->monkey_swing_ahead = _e; }
  { auto _e = friendly(); _o->friendly = _e; }
  { auto _e = poisoned(); _o->poisoned = _e; }
  { auto _e = hurt_by_lara(); _o->hurt_by_lara = _e; }
  { auto _e = tosspad(); _o->tosspad = _e; }
  { auto _e = location_ai(); _o->location_ai = _e; }
  { auto _e = fired_weapon(); _o->fired_weapon = _e; }
  { auto _e = mood(); _o->mood = _e; }
  { auto _e = enemy(); _o->enemy = _e; }
  { auto _e = ai_target_number(); _o->ai_target_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = can_jump(); _o->can_jump = _e; }
  { auto _e = can_monkey(); _o->can_monkey = _e; }
  { auto _e = is_amphibious(); _o->is_amphibious = _e; }
  { auto _e = is_jumping(); _o->is_jumping = _e; }
  { auto _e = is_monkeying(); _o->is_monkeying = _e; }
}

inline flatbuffers::Offset<Creature> Creature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Creature> CreateCreature(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _maximum_turn = _o->maximum_turn;
  auto _joint_rotation = _fbb.CreateVector(_o->joint_rotation);
  auto _head_left = _o->head_left;
  auto _head_right = _o->head_right;
  auto _patrol = _o->patrol;
  auto _alerted = _o->alerted;
  auto _reached_goal = _o->reached_goal;
  auto _jump_ahead = _o->jump_ahead;
  auto _monkey_swing_ahead = _o->monkey_swing_ahead;
  auto _friendly = _o->friendly;
  auto _poisoned = _o->poisoned;
  auto _hurt_by_lara = _o->hurt_by_lara;
  auto _tosspad = _o->tosspad;
  auto _location_ai = _o->location_ai;
  auto _fired_weapon = _o->fired_weapon;
  auto _mood = _o->mood;
  auto _enemy = _o->enemy;
  auto _ai_target_number = _o->ai_target_number;
  auto _flags = _o->flags;
  auto _can_jump = _o->can_jump;
  auto _can_monkey = _o->can_monkey;
  auto _is_amphibious = _o->is_amphibious;
  auto _is_jumping = _o->is_jumping;
  auto _is_monkeying = _o->is_monkeying;
  return TEN::Save::CreateCreature(
      _fbb,
      _maximum_turn,
      _joint_rotation,
      _head_left,
      _head_right,
      _patrol,
      _alerted,
      _reached_goal,
      _jump_ahead,
      _monkey_swing_ahead,
      _friendly,
      _poisoned,
      _hurt_by_lara,
      _tosspad,
      _location_ai,
      _fired_weapon,
      _mood,
      _enemy,
      _ai_target_number,
      _flags,
      _can_jump,
      _can_monkey,
      _is_amphibious,
      _is_jumping,
      _is_monkeying);
}

inline LaserHeadT *LaserHead::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaserHeadT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserHead::UnPackTo(LaserHeadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LaserHead> LaserHead::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserHead(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaserHead> CreateLaserHead(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaserHeadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateLaserHead(
      _fbb);
}

inline QuadBikeT *QuadBike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<QuadBikeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuadBike::UnPackTo(QuadBikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = turn_rate(); _o->turn_rate = _e; }
  { auto _e = front_rot(); _o->front_rot = _e; }
  { auto _e = rear_rot(); _o->rear_rot = _e; }
  { auto _e = momentum_angle(); _o->momentum_angle = _e; }
  { auto _e = extra_rotation(); _o->extra_rotation = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = left_vertical_velocity(); _o->left_vertical_velocity = _e; }
  { auto _e = right_vertical_velocity(); _o->right_vertical_velocity = _e; }
  { auto _e = revs(); _o->revs = _e; }
  { auto _e = engine_revs(); _o->engine_revs = _e; }
  { auto _e = pitch(); _o->pitch = _e; }
  { auto _e = smoke_start(); _o->smoke_start = _e; }
  { auto _e = can_start_drift(); _o->can_start_drift = _e; }
  { auto _e = drift_starting(); _o->drift_starting = _e; }
  { auto _e = no_dismount(); _o->no_dismount = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<QuadBike> QuadBike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuadBike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuadBike> CreateQuadBike(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuadBikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _turn_rate = _o->turn_rate;
  auto _front_rot = _o->front_rot;
  auto _rear_rot = _o->rear_rot;
  auto _momentum_angle = _o->momentum_angle;
  auto _extra_rotation = _o->extra_rotation;
  auto _velocity = _o->velocity;
  auto _left_vertical_velocity = _o->left_vertical_velocity;
  auto _right_vertical_velocity = _o->right_vertical_velocity;
  auto _revs = _o->revs;
  auto _engine_revs = _o->engine_revs;
  auto _pitch = _o->pitch;
  auto _smoke_start = _o->smoke_start;
  auto _can_start_drift = _o->can_start_drift;
  auto _drift_starting = _o->drift_starting;
  auto _no_dismount = _o->no_dismount;
  auto _flags = _o->flags;
  return TEN::Save::CreateQuadBike(
      _fbb,
      _turn_rate,
      _front_rot,
      _rear_rot,
      _momentum_angle,
      _extra_rotation,
      _velocity,
      _left_vertical_velocity,
      _right_vertical_velocity,
      _revs,
      _engine_revs,
      _pitch,
      _smoke_start,
      _can_start_drift,
      _drift_starting,
      _no_dismount,
      _flags);
}

inline BigGunT *BigGun::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BigGunT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BigGun::UnPackTo(BigGunT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BigGun> BigGun::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBigGun(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BigGun> CreateBigGun(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BigGunT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateBigGun(
      _fbb);
}

inline MotorbikeT *Motorbike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MotorbikeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Motorbike::UnPackTo(MotorbikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Motorbike> Motorbike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotorbike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Motorbike> CreateMotorbike(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MotorbikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateMotorbike(
      _fbb);
}

inline JeepT *Jeep::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<JeepT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Jeep::UnPackTo(JeepT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Jeep> Jeep::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JeepT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJeep(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Jeep> CreateJeep(flatbuffers::FlatBufferBuilder &_fbb, const JeepT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JeepT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateJeep(
      _fbb);
}

inline KayakT *Kayak::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<KayakT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Kayak::UnPackTo(KayakT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = turn_rate(); _o->turn_rate = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = front_vertical_velocity(); _o->front_vertical_velocity = _e; }
  { auto _e = left_vertical_velocity(); _o->left_vertical_velocity = _e; }
  { auto _e = right_vertical_velocity(); _o->right_vertical_velocity = _e; }
  { auto _e = left_right_count(); _o->left_right_count = _e; }
  { auto _e = water_height(); _o->water_height = _e; }
  { auto _e = old_pos(); if (_e) _o->old_pos = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
  { auto _e = turn(); _o->turn = _e; }
  { auto _e = forward(); _o->forward = _e; }
  { auto _e = true_water(); _o->true_water = _e; }
  { auto _e = current_start_wake(); _o->current_start_wake = _e; }
  { auto _e = wake_shade(); _o->wake_shade = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<Kayak> Kayak::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KayakT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKayak(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Kayak> CreateKayak(flatbuffers::FlatBufferBuilder &_fbb, const KayakT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KayakT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _turn_rate = _o->turn_rate;
  auto _velocity = _o->velocity;
  auto _front_vertical_velocity = _o->front_vertical_velocity;
  auto _left_vertical_velocity = _o->left_vertical_velocity;
  auto _right_vertical_velocity = _o->right_vertical_velocity;
  auto _left_right_count = _o->left_right_count;
  auto _water_height = _o->water_height;
  auto _old_pos = _o->old_pos ? _o->old_pos.get() : 0;
  auto _turn = _o->turn;
  auto _forward = _o->forward;
  auto _true_water = _o->true_water;
  auto _current_start_wake = _o->current_start_wake;
  auto _wake_shade = _o->wake_shade;
  auto _flags = _o->flags;
  return TEN::Save::CreateKayak(
      _fbb,
      _turn_rate,
      _velocity,
      _front_vertical_velocity,
      _left_vertical_velocity,
      _right_vertical_velocity,
      _left_right_count,
      _water_height,
      _old_pos,
      _turn,
      _forward,
      _true_water,
      _current_start_wake,
      _wake_shade,
      _flags);
}

inline DoorT *Door::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<DoorT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Door::UnPackTo(DoorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Door> Door::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Door> CreateDoor(flatbuffers::FlatBufferBuilder &_fbb, const DoorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DoorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateDoor(
      _fbb);
}

inline SkidooT *Skidoo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SkidooT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Skidoo::UnPackTo(SkidooT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Skidoo> Skidoo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkidoo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Skidoo> CreateSkidoo(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkidooT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateSkidoo(
      _fbb);
}

inline UPVT *UPV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UPVT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UPV::UnPackTo(UPVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = rot(); _o->rot = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = fan_rot(); _o->fan_rot = _e; }
  { auto _e = harpoon_timer(); _o->harpoon_timer = _e; }
  { auto _e = harpoon_left(); _o->harpoon_left = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<UPV> UPV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPV> CreateUPV(flatbuffers::FlatBufferBuilder &_fbb, const UPVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _velocity = _o->velocity;
  auto _rot = _o->rot;
  auto _x_rot = _o->x_rot;
  auto _fan_rot = _o->fan_rot;
  auto _harpoon_timer = _o->harpoon_timer;
  auto _harpoon_left = _o->harpoon_left;
  auto _flags = _o->flags;
  return TEN::Save::CreateUPV(
      _fbb,
      _velocity,
      _rot,
      _x_rot,
      _fan_rot,
      _harpoon_timer,
      _harpoon_left,
      _flags);
}

inline MotorboatT *Motorboat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MotorboatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Motorboat::UnPackTo(MotorboatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Motorboat> Motorboat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotorboat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Motorboat> CreateMotorboat(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MotorboatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateMotorboat(
      _fbb);
}

inline GameVectorT *GameVector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<GameVectorT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameVector::UnPackTo(GameVectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GameVector> GameVector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGameVector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GameVector> CreateGameVector(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GameVectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateGameVector(
      _fbb);
}

inline WraithT *Wraith::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WraithT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Wraith::UnPackTo(WraithT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Wraith> Wraith::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WraithT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWraith(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Wraith> CreateWraith(flatbuffers::FlatBufferBuilder &_fbb, const WraithT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WraithT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateWraith(
      _fbb);
}

inline RubberboatT *Rubberboat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RubberboatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rubberboat::UnPackTo(RubberboatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rubberboat> Rubberboat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRubberboat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rubberboat> CreateRubberboat(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RubberboatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateRubberboat(
      _fbb);
}

inline PushableT *Pushable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PushableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pushable::UnPackTo(PushableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Pushable> Pushable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PushableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePushable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pushable> CreatePushable(flatbuffers::FlatBufferBuilder &_fbb, const PushableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PushableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreatePushable(
      _fbb);
}

inline MinecartT *Minecart::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MinecartT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Minecart::UnPackTo(MinecartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = turn_rot(); _o->turn_rot = _e; }
  { auto _e = turn_x(); _o->turn_x = _e; }
  { auto _e = turn_z(); _o->turn_z = _e; }
  { auto _e = turn_len(); _o->turn_len = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = vertical_velocity(); _o->vertical_velocity = _e; }
  { auto _e = gradient(); _o->gradient = _e; }
  { auto _e = stop_delay(); _o->stop_delay = _e; }
  { auto _e = floor_height_middle(); _o->floor_height_middle = _e; }
  { auto _e = floor_height_front(); _o->floor_height_front = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<Minecart> Minecart::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinecart(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Minecart> CreateMinecart(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinecartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _turn_rot = _o->turn_rot;
  auto _turn_x = _o->turn_x;
  auto _turn_z = _o->turn_z;
  auto _turn_len = _o->turn_len;
  auto _velocity = _o->velocity;
  auto _vertical_velocity = _o->vertical_velocity;
  auto _gradient = _o->gradient;
  auto _stop_delay = _o->stop_delay;
  auto _floor_height_middle = _o->floor_height_middle;
  auto _floor_height_front = _o->floor_height_front;
  auto _flags = _o->flags;
  return TEN::Save::CreateMinecart(
      _fbb,
      _turn_rot,
      _turn_x,
      _turn_z,
      _turn_len,
      _velocity,
      _vertical_velocity,
      _gradient,
      _stop_delay,
      _floor_height_middle,
      _floor_height_front,
      _flags);
}

inline LaraInfoT *LaraInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraInfo::UnPackTo(LaraInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LaraInfo> LaraInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraInfo> CreateLaraInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateLaraInfo(
      _fbb);
}

inline ItemNumberT *ItemNumber::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ItemNumberT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemNumber::UnPackTo(ItemNumberT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
}

inline flatbuffers::Offset<ItemNumber> ItemNumber::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemNumber(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemNumber> CreateItemNumber(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemNumberT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  return TEN::Save::CreateItemNumber(
      _fbb,
      _num);
}

inline ShortT *Short::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ShortT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Short::UnPackTo(ShortT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Short> Short::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShort(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Short> CreateShort(flatbuffers::FlatBufferBuilder &_fbb, const ShortT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShortT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateShort(
      _fbb,
      _scalar);
}

inline IntT *Int::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<IntT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int::UnPackTo(IntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Int> Int::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb, const IntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateInt(
      _fbb,
      _scalar);
}

inline FloatT *Float::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FloatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float::UnPackTo(FloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Float> Float::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Float> CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, const FloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateFloat(
      _fbb,
      _scalar);
}

inline ShortArrayT *ShortArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ShortArrayT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShortArray::UnPackTo(ShortArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = arr(); if (_e) { _o->arr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arr[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ShortArray> ShortArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShortArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShortArray> CreateShortArray(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShortArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _arr = _fbb.CreateVector(_o->arr);
  return TEN::Save::CreateShortArray(
      _fbb,
      _arr);
}

inline bool VerifyItemData(flatbuffers::Verifier &verifier, const void *obj, ItemData type) {
  switch (type) {
    case ItemData::NONE: {
      return true;
    }
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::Float *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumber *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::Creature *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHead *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGun *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorbike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::Jeep *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::Kayak *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::Door *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::Skidoo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorboat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::Wraith *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Rubberboat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::Pushable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::Minecart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyItemData(
        verifier,  values->Get(i), types->GetEnum<ItemData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ItemDataUnion::UnPack(const void *obj, ItemData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::Int *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::Short *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::Float *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArray *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumber *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::Creature *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHead *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBike *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGun *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorbike *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::Jeep *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::Kayak *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::Door *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::Skidoo *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPV *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorboat *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVector *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::Wraith *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Rubberboat *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::Pushable *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::Minecart *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ItemDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::IntT *>(value);
      return CreateInt(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortT *>(value);
      return CreateShort(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::FloatT *>(value);
      return CreateFloat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArrayT *>(value);
      return CreateShortArray(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumberT *>(value);
      return CreateItemNumber(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::CreatureT *>(value);
      return CreateCreature(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHeadT *>(value);
      return CreateLaserHead(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBikeT *>(value);
      return CreateQuadBike(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGunT *>(value);
      return CreateBigGun(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::MotorbikeT *>(value);
      return CreateMotorbike(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::JeepT *>(value);
      return CreateJeep(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfoT *>(value);
      return CreateLaraInfo(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::KayakT *>(value);
      return CreateKayak(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::DoorT *>(value);
      return CreateDoor(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::SkidooT *>(value);
      return CreateSkidoo(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPVT *>(value);
      return CreateUPV(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::MotorboatT *>(value);
      return CreateMotorboat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVectorT *>(value);
      return CreateGameVector(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::WraithT *>(value);
      return CreateWraith(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::RubberboatT *>(value);
      return CreateRubberboat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::PushableT *>(value);
      return CreatePushable(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::MinecartT *>(value);
      return CreateMinecart(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ItemDataUnion::ItemDataUnion(const ItemDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ItemData::Int: {
      value = new TEN::Save::IntT(*reinterpret_cast<TEN::Save::IntT *>(u.value));
      break;
    }
    case ItemData::Short: {
      value = new TEN::Save::ShortT(*reinterpret_cast<TEN::Save::ShortT *>(u.value));
      break;
    }
    case ItemData::Float: {
      value = new TEN::Save::FloatT(*reinterpret_cast<TEN::Save::FloatT *>(u.value));
      break;
    }
    case ItemData::ShortArray: {
      value = new TEN::Save::ShortArrayT(*reinterpret_cast<TEN::Save::ShortArrayT *>(u.value));
      break;
    }
    case ItemData::ItemNumber: {
      value = new TEN::Save::ItemNumberT(*reinterpret_cast<TEN::Save::ItemNumberT *>(u.value));
      break;
    }
    case ItemData::Creature: {
      value = new TEN::Save::CreatureT(*reinterpret_cast<TEN::Save::CreatureT *>(u.value));
      break;
    }
    case ItemData::LaserHead: {
      value = new TEN::Save::LaserHeadT(*reinterpret_cast<TEN::Save::LaserHeadT *>(u.value));
      break;
    }
    case ItemData::QuadBike: {
      value = new TEN::Save::QuadBikeT(*reinterpret_cast<TEN::Save::QuadBikeT *>(u.value));
      break;
    }
    case ItemData::BigGun: {
      value = new TEN::Save::BigGunT(*reinterpret_cast<TEN::Save::BigGunT *>(u.value));
      break;
    }
    case ItemData::Motorbike: {
      value = new TEN::Save::MotorbikeT(*reinterpret_cast<TEN::Save::MotorbikeT *>(u.value));
      break;
    }
    case ItemData::Jeep: {
      value = new TEN::Save::JeepT(*reinterpret_cast<TEN::Save::JeepT *>(u.value));
      break;
    }
    case ItemData::LaraInfo: {
      value = new TEN::Save::LaraInfoT(*reinterpret_cast<TEN::Save::LaraInfoT *>(u.value));
      break;
    }
    case ItemData::Kayak: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::KayakT not copyable.
      break;
    }
    case ItemData::Door: {
      value = new TEN::Save::DoorT(*reinterpret_cast<TEN::Save::DoorT *>(u.value));
      break;
    }
    case ItemData::Skidoo: {
      value = new TEN::Save::SkidooT(*reinterpret_cast<TEN::Save::SkidooT *>(u.value));
      break;
    }
    case ItemData::UPV: {
      value = new TEN::Save::UPVT(*reinterpret_cast<TEN::Save::UPVT *>(u.value));
      break;
    }
    case ItemData::Motorboat: {
      value = new TEN::Save::MotorboatT(*reinterpret_cast<TEN::Save::MotorboatT *>(u.value));
      break;
    }
    case ItemData::GameVector: {
      value = new TEN::Save::GameVectorT(*reinterpret_cast<TEN::Save::GameVectorT *>(u.value));
      break;
    }
    case ItemData::Wraith: {
      value = new TEN::Save::WraithT(*reinterpret_cast<TEN::Save::WraithT *>(u.value));
      break;
    }
    case ItemData::Rubberboat: {
      value = new TEN::Save::RubberboatT(*reinterpret_cast<TEN::Save::RubberboatT *>(u.value));
      break;
    }
    case ItemData::Pushable: {
      value = new TEN::Save::PushableT(*reinterpret_cast<TEN::Save::PushableT *>(u.value));
      break;
    }
    case ItemData::Minecart: {
      value = new TEN::Save::MinecartT(*reinterpret_cast<TEN::Save::MinecartT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ItemDataUnion::Reset() {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<TEN::Save::IntT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<TEN::Save::ShortT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<TEN::Save::FloatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<TEN::Save::ShortArrayT *>(value);
      delete ptr;
      break;
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<TEN::Save::ItemNumberT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<TEN::Save::CreatureT *>(value);
      delete ptr;
      break;
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<TEN::Save::LaserHeadT *>(value);
      delete ptr;
      break;
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<TEN::Save::QuadBikeT *>(value);
      delete ptr;
      break;
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<TEN::Save::BigGunT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<TEN::Save::MotorbikeT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<TEN::Save::JeepT *>(value);
      delete ptr;
      break;
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<TEN::Save::LaraInfoT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<TEN::Save::KayakT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<TEN::Save::DoorT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<TEN::Save::SkidooT *>(value);
      delete ptr;
      break;
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<TEN::Save::UPVT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<TEN::Save::MotorboatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<TEN::Save::GameVectorT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<TEN::Save::WraithT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<TEN::Save::RubberboatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<TEN::Save::PushableT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<TEN::Save::MinecartT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ItemData::NONE;
}

}  // namespace Save
}  // namespace TEN

#endif  // FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_
