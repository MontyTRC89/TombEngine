// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
#define FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_

#include "flatbuffers/flatbuffers.h"

#include "ten_itemdata_generated.h"

namespace TEN {
namespace Save {

struct RoomVector;

struct Item;
struct ItemBuilder;
struct ItemT;

struct FXInfo;
struct FXInfoBuilder;
struct FXInfoT;

struct AmmoInfo;
struct AmmoInfoBuilder;
struct AmmoInfoT;

struct HolsterInfo;
struct HolsterInfoBuilder;
struct HolsterInfoT;

struct CarriedWeaponInfo;
struct CarriedWeaponInfoBuilder;
struct CarriedWeaponInfoT;

struct WeaponInfo;
struct WeaponInfoBuilder;
struct WeaponInfoT;

struct ArmInfo;
struct ArmInfoBuilder;
struct ArmInfoT;

struct FlareData;
struct FlareDataBuilder;
struct FlareDataT;

struct TorchData;
struct TorchDataBuilder;
struct TorchDataT;

struct LaraInventoryData;
struct LaraInventoryDataBuilder;
struct LaraInventoryDataT;

struct LaraCountData;
struct LaraCountDataBuilder;
struct LaraCountDataT;

struct WeaponControlData;
struct WeaponControlDataBuilder;
struct WeaponControlDataT;

struct RopeControlData;
struct RopeControlDataBuilder;
struct RopeControlDataT;

struct TightropeControlData;
struct TightropeControlDataBuilder;
struct TightropeControlDataT;

struct SubsuitControlData;
struct SubsuitControlDataBuilder;
struct SubsuitControlDataT;

struct LaraControlData;
struct LaraControlDataBuilder;
struct LaraControlDataT;

struct Lara;
struct LaraBuilder;
struct LaraT;

struct FixedCamera;
struct FixedCameraBuilder;
struct FixedCameraT;

struct FlyByCamera;
struct FlyByCameraBuilder;
struct FlyByCameraT;

struct Sink;
struct SinkBuilder;
struct SinkT;

struct StaticMeshInfo;
struct StaticMeshInfoBuilder;
struct StaticMeshInfoT;

struct ParticleInfo;
struct ParticleInfoBuilder;
struct ParticleInfoT;

struct RatInfo;
struct RatInfoBuilder;
struct RatInfoT;

struct SpiderInfo;
struct SpiderInfoBuilder;
struct SpiderInfoT;

struct ScarabInfo;
struct ScarabInfoBuilder;
struct ScarabInfoT;

struct BatInfo;
struct BatInfoBuilder;
struct BatInfoT;

struct Rope;
struct RopeBuilder;
struct RopeT;

struct Pendulum;
struct PendulumBuilder;
struct PendulumT;

struct EventSetCallCounters;
struct EventSetCallCountersBuilder;
struct EventSetCallCountersT;

struct VolumeState;
struct VolumeStateBuilder;
struct VolumeStateT;

struct KeyValPair;

struct ScriptTable;
struct ScriptTableBuilder;
struct ScriptTableT;

struct stringTable;
struct stringTableBuilder;
struct stringTableT;

struct doubleTable;
struct doubleTableBuilder;
struct doubleTableT;

struct boolTable;
struct boolTableBuilder;
struct boolTableT;

struct UnionTable;
struct UnionTableBuilder;
struct UnionTableT;

struct UnionVec;
struct UnionVecBuilder;
struct UnionVecT;

struct SaveGameHeader;
struct SaveGameHeaderBuilder;
struct SaveGameHeaderT;

struct SaveGameStatistics;
struct SaveGameStatisticsBuilder;
struct SaveGameStatisticsT;

struct SaveGame;
struct SaveGameBuilder;
struct SaveGameT;

enum class TorchState : int32_t {
  holding = 0,
  throwing = 1,
  dropping = 2,
  just_lit = 3,
  MIN = holding,
  MAX = just_lit
};

inline const TorchState (&EnumValuesTorchState())[4] {
  static const TorchState values[] = {
    TorchState::holding,
    TorchState::throwing,
    TorchState::dropping,
    TorchState::just_lit
  };
  return values;
}

inline const char * const *EnumNamesTorchState() {
  static const char * const names[5] = {
    "holding",
    "throwing",
    "dropping",
    "just_lit",
    nullptr
  };
  return names;
}

inline const char *EnumNameTorchState(TorchState e) {
  if (flatbuffers::IsOutRange(e, TorchState::holding, TorchState::just_lit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTorchState()[index];
}

enum class VarUnion : uint8_t {
  NONE = 0,
  str = 1,
  tab = 2,
  num = 3,
  boolean = 4,
  MIN = NONE,
  MAX = boolean
};

inline const VarUnion (&EnumValuesVarUnion())[5] {
  static const VarUnion values[] = {
    VarUnion::NONE,
    VarUnion::str,
    VarUnion::tab,
    VarUnion::num,
    VarUnion::boolean
  };
  return values;
}

inline const char * const *EnumNamesVarUnion() {
  static const char * const names[6] = {
    "NONE",
    "str",
    "tab",
    "num",
    "boolean",
    nullptr
  };
  return names;
}

inline const char *EnumNameVarUnion(VarUnion e) {
  if (flatbuffers::IsOutRange(e, VarUnion::NONE, VarUnion::boolean)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarUnion()[index];
}

template<typename T> struct VarUnionTraits {
  static const VarUnion enum_value = VarUnion::NONE;
};

template<> struct VarUnionTraits<TEN::Save::stringTable> {
  static const VarUnion enum_value = VarUnion::str;
};

template<> struct VarUnionTraits<TEN::Save::ScriptTable> {
  static const VarUnion enum_value = VarUnion::tab;
};

template<> struct VarUnionTraits<TEN::Save::doubleTable> {
  static const VarUnion enum_value = VarUnion::num;
};

template<> struct VarUnionTraits<TEN::Save::boolTable> {
  static const VarUnion enum_value = VarUnion::boolean;
};

struct VarUnionUnion {
  VarUnion type;
  void *value;

  VarUnionUnion() : type(VarUnion::NONE), value(nullptr) {}
  VarUnionUnion(VarUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(VarUnion::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  VarUnionUnion(const VarUnionUnion &);
  VarUnionUnion &operator=(const VarUnionUnion &u)
    { VarUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  VarUnionUnion &operator=(VarUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~VarUnionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = VarUnionTraits<typename RT::TableType>::enum_value;
    if (type != VarUnion::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TEN::Save::stringTableT *Asstr() {
    return type == VarUnion::str ?
      reinterpret_cast<TEN::Save::stringTableT *>(value) : nullptr;
  }
  const TEN::Save::stringTableT *Asstr() const {
    return type == VarUnion::str ?
      reinterpret_cast<const TEN::Save::stringTableT *>(value) : nullptr;
  }
  TEN::Save::ScriptTableT *Astab() {
    return type == VarUnion::tab ?
      reinterpret_cast<TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  const TEN::Save::ScriptTableT *Astab() const {
    return type == VarUnion::tab ?
      reinterpret_cast<const TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  TEN::Save::doubleTableT *Asnum() {
    return type == VarUnion::num ?
      reinterpret_cast<TEN::Save::doubleTableT *>(value) : nullptr;
  }
  const TEN::Save::doubleTableT *Asnum() const {
    return type == VarUnion::num ?
      reinterpret_cast<const TEN::Save::doubleTableT *>(value) : nullptr;
  }
  TEN::Save::boolTableT *Asboolean() {
    return type == VarUnion::boolean ?
      reinterpret_cast<TEN::Save::boolTableT *>(value) : nullptr;
  }
  const TEN::Save::boolTableT *Asboolean() const {
    return type == VarUnion::boolean ?
      reinterpret_cast<const TEN::Save::boolTableT *>(value) : nullptr;
  }
};

bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type);
bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RoomVector FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t room_;
  uint32_t y_location_;

 public:
  struct Traits;
  RoomVector()
      : room_(0),
        y_location_(0) {
  }
  RoomVector(uint32_t _room, uint32_t _y_location)
      : room_(flatbuffers::EndianScalar(_room)),
        y_location_(flatbuffers::EndianScalar(_y_location)) {
  }
  uint32_t room() const {
    return flatbuffers::EndianScalar(room_);
  }
  uint32_t y_location() const {
    return flatbuffers::EndianScalar(y_location_);
  }
};
FLATBUFFERS_STRUCT_END(RoomVector, 8);

struct RoomVector::Traits {
  using type = RoomVector;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KeyValPair FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t key_;
  uint32_t val_;

 public:
  struct Traits;
  KeyValPair()
      : key_(0),
        val_(0) {
  }
  KeyValPair(uint32_t _key, uint32_t _val)
      : key_(flatbuffers::EndianScalar(_key)),
        val_(flatbuffers::EndianScalar(_val)) {
  }
  uint32_t key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint32_t val() const {
    return flatbuffers::EndianScalar(val_);
  }
};
FLATBUFFERS_STRUCT_END(KeyValPair, 8);

struct KeyValPair::Traits {
  using type = KeyValPair;
};

struct ItemT : public flatbuffers::NativeTable {
  typedef Item TableType;
  int32_t floor = 0;
  int32_t touch_bits = 0;
  int32_t mesh_bits = 0;
  int32_t object_id = 0;
  int32_t active_state = 0;
  int32_t target_state = 0;
  int32_t required_state = 0;
  int32_t anim_number = 0;
  int32_t frame_number = 0;
  int32_t room_number = 0;
  int32_t velocity = 0;
  int32_t vertical_velocity = 0;
  int32_t hit_points = 0;
  int32_t box_number = 0;
  int32_t timer = 0;
  std::unique_ptr<TEN::Save::Vector4> color{};
  int32_t flags = 0;
  int32_t trigger_flags = 0;
  int32_t carried_item = 0;
  int32_t after_death = 0;
  std::vector<int32_t> item_flags{};
  std::unique_ptr<TEN::Save::Position> position{};
  int32_t next_item = 0;
  int32_t next_item_active = 0;
  bool triggered = false;
  bool active = false;
  int32_t status = 0;
  bool is_airborne = false;
  bool hit_stauts = false;
  bool collidable = false;
  bool looked_at = false;
  int32_t ai_bits = 0;
  int32_t swap_mesh_flags = 0;
  TEN::Save::ItemDataUnion data{};
  std::string lua_name{};
  std::string lua_on_killed_name{};
  std::string lua_on_hit_name{};
  std::string lua_on_collided_with_object_name{};
  std::string lua_on_collided_with_room_name{};
};

struct Item FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOOR = 4,
    VT_TOUCH_BITS = 6,
    VT_MESH_BITS = 8,
    VT_OBJECT_ID = 10,
    VT_ACTIVE_STATE = 12,
    VT_TARGET_STATE = 14,
    VT_REQUIRED_STATE = 16,
    VT_ANIM_NUMBER = 18,
    VT_FRAME_NUMBER = 20,
    VT_ROOM_NUMBER = 22,
    VT_VELOCITY = 24,
    VT_VERTICAL_VELOCITY = 26,
    VT_HIT_POINTS = 28,
    VT_BOX_NUMBER = 30,
    VT_TIMER = 32,
    VT_COLOR = 34,
    VT_FLAGS = 36,
    VT_TRIGGER_FLAGS = 38,
    VT_CARRIED_ITEM = 40,
    VT_AFTER_DEATH = 42,
    VT_ITEM_FLAGS = 44,
    VT_POSITION = 46,
    VT_NEXT_ITEM = 48,
    VT_NEXT_ITEM_ACTIVE = 50,
    VT_TRIGGERED = 52,
    VT_ACTIVE = 54,
    VT_STATUS = 56,
    VT_IS_AIRBORNE = 58,
    VT_HIT_STAUTS = 60,
    VT_COLLIDABLE = 62,
    VT_LOOKED_AT = 64,
    VT_AI_BITS = 66,
    VT_SWAP_MESH_FLAGS = 68,
    VT_DATA_TYPE = 70,
    VT_DATA = 72,
    VT_LUA_NAME = 74,
    VT_LUA_ON_KILLED_NAME = 76,
    VT_LUA_ON_HIT_NAME = 78,
    VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME = 80,
    VT_LUA_ON_COLLIDED_WITH_ROOM_NAME = 82
  };
  int32_t floor() const {
    return GetField<int32_t>(VT_FLOOR, 0);
  }
  int32_t touch_bits() const {
    return GetField<int32_t>(VT_TOUCH_BITS, 0);
  }
  int32_t mesh_bits() const {
    return GetField<int32_t>(VT_MESH_BITS, 0);
  }
  int32_t object_id() const {
    return GetField<int32_t>(VT_OBJECT_ID, 0);
  }
  int32_t active_state() const {
    return GetField<int32_t>(VT_ACTIVE_STATE, 0);
  }
  int32_t target_state() const {
    return GetField<int32_t>(VT_TARGET_STATE, 0);
  }
  int32_t required_state() const {
    return GetField<int32_t>(VT_REQUIRED_STATE, 0);
  }
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t velocity() const {
    return GetField<int32_t>(VT_VELOCITY, 0);
  }
  int32_t vertical_velocity() const {
    return GetField<int32_t>(VT_VERTICAL_VELOCITY, 0);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t box_number() const {
    return GetField<int32_t>(VT_BOX_NUMBER, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  const TEN::Save::Vector4 *color() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_COLOR);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t trigger_flags() const {
    return GetField<int32_t>(VT_TRIGGER_FLAGS, 0);
  }
  int32_t carried_item() const {
    return GetField<int32_t>(VT_CARRIED_ITEM, 0);
  }
  int32_t after_death() const {
    return GetField<int32_t>(VT_AFTER_DEATH, 0);
  }
  const flatbuffers::Vector<int32_t> *item_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ITEM_FLAGS);
  }
  const TEN::Save::Position *position() const {
    return GetStruct<const TEN::Save::Position *>(VT_POSITION);
  }
  int32_t next_item() const {
    return GetField<int32_t>(VT_NEXT_ITEM, 0);
  }
  int32_t next_item_active() const {
    return GetField<int32_t>(VT_NEXT_ITEM_ACTIVE, 0);
  }
  bool triggered() const {
    return GetField<uint8_t>(VT_TRIGGERED, 0) != 0;
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool is_airborne() const {
    return GetField<uint8_t>(VT_IS_AIRBORNE, 0) != 0;
  }
  bool hit_stauts() const {
    return GetField<uint8_t>(VT_HIT_STAUTS, 0) != 0;
  }
  bool collidable() const {
    return GetField<uint8_t>(VT_COLLIDABLE, 0) != 0;
  }
  bool looked_at() const {
    return GetField<uint8_t>(VT_LOOKED_AT, 0) != 0;
  }
  int32_t ai_bits() const {
    return GetField<int32_t>(VT_AI_BITS, 0);
  }
  int32_t swap_mesh_flags() const {
    return GetField<int32_t>(VT_SWAP_MESH_FLAGS, 0);
  }
  TEN::Save::ItemData data_type() const {
    return static_cast<TEN::Save::ItemData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const TEN::Save::Int *data_as_Int() const {
    return data_type() == TEN::Save::ItemData::Int ? static_cast<const TEN::Save::Int *>(data()) : nullptr;
  }
  const TEN::Save::Short *data_as_Short() const {
    return data_type() == TEN::Save::ItemData::Short ? static_cast<const TEN::Save::Short *>(data()) : nullptr;
  }
  const TEN::Save::Float *data_as_Float() const {
    return data_type() == TEN::Save::ItemData::Float ? static_cast<const TEN::Save::Float *>(data()) : nullptr;
  }
  const TEN::Save::ShortArray *data_as_ShortArray() const {
    return data_type() == TEN::Save::ItemData::ShortArray ? static_cast<const TEN::Save::ShortArray *>(data()) : nullptr;
  }
  const TEN::Save::ItemNumber *data_as_ItemNumber() const {
    return data_type() == TEN::Save::ItemData::ItemNumber ? static_cast<const TEN::Save::ItemNumber *>(data()) : nullptr;
  }
  const TEN::Save::Creature *data_as_Creature() const {
    return data_type() == TEN::Save::ItemData::Creature ? static_cast<const TEN::Save::Creature *>(data()) : nullptr;
  }
  const TEN::Save::LaserHead *data_as_LaserHead() const {
    return data_type() == TEN::Save::ItemData::LaserHead ? static_cast<const TEN::Save::LaserHead *>(data()) : nullptr;
  }
  const TEN::Save::QuadBike *data_as_QuadBike() const {
    return data_type() == TEN::Save::ItemData::QuadBike ? static_cast<const TEN::Save::QuadBike *>(data()) : nullptr;
  }
  const TEN::Save::BigGun *data_as_BigGun() const {
    return data_type() == TEN::Save::ItemData::BigGun ? static_cast<const TEN::Save::BigGun *>(data()) : nullptr;
  }
  const TEN::Save::Motorbike *data_as_Motorbike() const {
    return data_type() == TEN::Save::ItemData::Motorbike ? static_cast<const TEN::Save::Motorbike *>(data()) : nullptr;
  }
  const TEN::Save::Jeep *data_as_Jeep() const {
    return data_type() == TEN::Save::ItemData::Jeep ? static_cast<const TEN::Save::Jeep *>(data()) : nullptr;
  }
  const TEN::Save::LaraInfo *data_as_LaraInfo() const {
    return data_type() == TEN::Save::ItemData::LaraInfo ? static_cast<const TEN::Save::LaraInfo *>(data()) : nullptr;
  }
  const TEN::Save::Kayak *data_as_Kayak() const {
    return data_type() == TEN::Save::ItemData::Kayak ? static_cast<const TEN::Save::Kayak *>(data()) : nullptr;
  }
  const TEN::Save::Door *data_as_Door() const {
    return data_type() == TEN::Save::ItemData::Door ? static_cast<const TEN::Save::Door *>(data()) : nullptr;
  }
  const TEN::Save::Skidoo *data_as_Skidoo() const {
    return data_type() == TEN::Save::ItemData::Skidoo ? static_cast<const TEN::Save::Skidoo *>(data()) : nullptr;
  }
  const TEN::Save::UPV *data_as_UPV() const {
    return data_type() == TEN::Save::ItemData::UPV ? static_cast<const TEN::Save::UPV *>(data()) : nullptr;
  }
  const TEN::Save::Motorboat *data_as_Motorboat() const {
    return data_type() == TEN::Save::ItemData::Motorboat ? static_cast<const TEN::Save::Motorboat *>(data()) : nullptr;
  }
  const TEN::Save::GameVector *data_as_GameVector() const {
    return data_type() == TEN::Save::ItemData::GameVector ? static_cast<const TEN::Save::GameVector *>(data()) : nullptr;
  }
  const TEN::Save::Wraith *data_as_Wraith() const {
    return data_type() == TEN::Save::ItemData::Wraith ? static_cast<const TEN::Save::Wraith *>(data()) : nullptr;
  }
  const TEN::Save::Rubberboat *data_as_Rubberboat() const {
    return data_type() == TEN::Save::ItemData::Rubberboat ? static_cast<const TEN::Save::Rubberboat *>(data()) : nullptr;
  }
  const TEN::Save::Pushable *data_as_Pushable() const {
    return data_type() == TEN::Save::ItemData::Pushable ? static_cast<const TEN::Save::Pushable *>(data()) : nullptr;
  }
  const TEN::Save::Minecart *data_as_Minecart() const {
    return data_type() == TEN::Save::ItemData::Minecart ? static_cast<const TEN::Save::Minecart *>(data()) : nullptr;
  }
  const flatbuffers::String *lua_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_NAME);
  }
  const flatbuffers::String *lua_on_killed_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_KILLED_NAME);
  }
  const flatbuffers::String *lua_on_hit_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_HIT_NAME);
  }
  const flatbuffers::String *lua_on_collided_with_object_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME);
  }
  const flatbuffers::String *lua_on_collided_with_room_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_COLLIDED_WITH_ROOM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLOOR) &&
           VerifyField<int32_t>(verifier, VT_TOUCH_BITS) &&
           VerifyField<int32_t>(verifier, VT_MESH_BITS) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_ID) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_STATE) &&
           VerifyField<int32_t>(verifier, VT_TARGET_STATE) &&
           VerifyField<int32_t>(verifier, VT_REQUIRED_STATE) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_BOX_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TRIGGER_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_CARRIED_ITEM) &&
           VerifyField<int32_t>(verifier, VT_AFTER_DEATH) &&
           VerifyOffset(verifier, VT_ITEM_FLAGS) &&
           verifier.VerifyVector(item_flags()) &&
           VerifyField<TEN::Save::Position>(verifier, VT_POSITION) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGERED) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_IS_AIRBORNE) &&
           VerifyField<uint8_t>(verifier, VT_HIT_STAUTS) &&
           VerifyField<uint8_t>(verifier, VT_COLLIDABLE) &&
           VerifyField<uint8_t>(verifier, VT_LOOKED_AT) &&
           VerifyField<int32_t>(verifier, VT_AI_BITS) &&
           VerifyField<int32_t>(verifier, VT_SWAP_MESH_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyItemData(verifier, data(), data_type()) &&
           VerifyOffset(verifier, VT_LUA_NAME) &&
           verifier.VerifyString(lua_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_KILLED_NAME) &&
           verifier.VerifyString(lua_on_killed_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_HIT_NAME) &&
           verifier.VerifyString(lua_on_hit_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME) &&
           verifier.VerifyString(lua_on_collided_with_object_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_COLLIDED_WITH_ROOM_NAME) &&
           verifier.VerifyString(lua_on_collided_with_room_name()) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Item> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::Int *Item::data_as<TEN::Save::Int>() const {
  return data_as_Int();
}

template<> inline const TEN::Save::Short *Item::data_as<TEN::Save::Short>() const {
  return data_as_Short();
}

template<> inline const TEN::Save::Float *Item::data_as<TEN::Save::Float>() const {
  return data_as_Float();
}

template<> inline const TEN::Save::ShortArray *Item::data_as<TEN::Save::ShortArray>() const {
  return data_as_ShortArray();
}

template<> inline const TEN::Save::ItemNumber *Item::data_as<TEN::Save::ItemNumber>() const {
  return data_as_ItemNumber();
}

template<> inline const TEN::Save::Creature *Item::data_as<TEN::Save::Creature>() const {
  return data_as_Creature();
}

template<> inline const TEN::Save::LaserHead *Item::data_as<TEN::Save::LaserHead>() const {
  return data_as_LaserHead();
}

template<> inline const TEN::Save::QuadBike *Item::data_as<TEN::Save::QuadBike>() const {
  return data_as_QuadBike();
}

template<> inline const TEN::Save::BigGun *Item::data_as<TEN::Save::BigGun>() const {
  return data_as_BigGun();
}

template<> inline const TEN::Save::Motorbike *Item::data_as<TEN::Save::Motorbike>() const {
  return data_as_Motorbike();
}

template<> inline const TEN::Save::Jeep *Item::data_as<TEN::Save::Jeep>() const {
  return data_as_Jeep();
}

template<> inline const TEN::Save::LaraInfo *Item::data_as<TEN::Save::LaraInfo>() const {
  return data_as_LaraInfo();
}

template<> inline const TEN::Save::Kayak *Item::data_as<TEN::Save::Kayak>() const {
  return data_as_Kayak();
}

template<> inline const TEN::Save::Door *Item::data_as<TEN::Save::Door>() const {
  return data_as_Door();
}

template<> inline const TEN::Save::Skidoo *Item::data_as<TEN::Save::Skidoo>() const {
  return data_as_Skidoo();
}

template<> inline const TEN::Save::UPV *Item::data_as<TEN::Save::UPV>() const {
  return data_as_UPV();
}

template<> inline const TEN::Save::Motorboat *Item::data_as<TEN::Save::Motorboat>() const {
  return data_as_Motorboat();
}

template<> inline const TEN::Save::GameVector *Item::data_as<TEN::Save::GameVector>() const {
  return data_as_GameVector();
}

template<> inline const TEN::Save::Wraith *Item::data_as<TEN::Save::Wraith>() const {
  return data_as_Wraith();
}

template<> inline const TEN::Save::Rubberboat *Item::data_as<TEN::Save::Rubberboat>() const {
  return data_as_Rubberboat();
}

template<> inline const TEN::Save::Pushable *Item::data_as<TEN::Save::Pushable>() const {
  return data_as_Pushable();
}

template<> inline const TEN::Save::Minecart *Item::data_as<TEN::Save::Minecart>() const {
  return data_as_Minecart();
}

struct ItemBuilder {
  typedef Item Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floor(int32_t floor) {
    fbb_.AddElement<int32_t>(Item::VT_FLOOR, floor, 0);
  }
  void add_touch_bits(int32_t touch_bits) {
    fbb_.AddElement<int32_t>(Item::VT_TOUCH_BITS, touch_bits, 0);
  }
  void add_mesh_bits(int32_t mesh_bits) {
    fbb_.AddElement<int32_t>(Item::VT_MESH_BITS, mesh_bits, 0);
  }
  void add_object_id(int32_t object_id) {
    fbb_.AddElement<int32_t>(Item::VT_OBJECT_ID, object_id, 0);
  }
  void add_active_state(int32_t active_state) {
    fbb_.AddElement<int32_t>(Item::VT_ACTIVE_STATE, active_state, 0);
  }
  void add_target_state(int32_t target_state) {
    fbb_.AddElement<int32_t>(Item::VT_TARGET_STATE, target_state, 0);
  }
  void add_required_state(int32_t required_state) {
    fbb_.AddElement<int32_t>(Item::VT_REQUIRED_STATE, required_state, 0);
  }
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(Item::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(Item::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(Item::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_velocity(int32_t velocity) {
    fbb_.AddElement<int32_t>(Item::VT_VELOCITY, velocity, 0);
  }
  void add_vertical_velocity(int32_t vertical_velocity) {
    fbb_.AddElement<int32_t>(Item::VT_VERTICAL_VELOCITY, vertical_velocity, 0);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(Item::VT_HIT_POINTS, hit_points, 0);
  }
  void add_box_number(int32_t box_number) {
    fbb_.AddElement<int32_t>(Item::VT_BOX_NUMBER, box_number, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(Item::VT_TIMER, timer, 0);
  }
  void add_color(const TEN::Save::Vector4 *color) {
    fbb_.AddStruct(Item::VT_COLOR, color);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Item::VT_FLAGS, flags, 0);
  }
  void add_trigger_flags(int32_t trigger_flags) {
    fbb_.AddElement<int32_t>(Item::VT_TRIGGER_FLAGS, trigger_flags, 0);
  }
  void add_carried_item(int32_t carried_item) {
    fbb_.AddElement<int32_t>(Item::VT_CARRIED_ITEM, carried_item, 0);
  }
  void add_after_death(int32_t after_death) {
    fbb_.AddElement<int32_t>(Item::VT_AFTER_DEATH, after_death, 0);
  }
  void add_item_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags) {
    fbb_.AddOffset(Item::VT_ITEM_FLAGS, item_flags);
  }
  void add_position(const TEN::Save::Position *position) {
    fbb_.AddStruct(Item::VT_POSITION, position);
  }
  void add_next_item(int32_t next_item) {
    fbb_.AddElement<int32_t>(Item::VT_NEXT_ITEM, next_item, 0);
  }
  void add_next_item_active(int32_t next_item_active) {
    fbb_.AddElement<int32_t>(Item::VT_NEXT_ITEM_ACTIVE, next_item_active, 0);
  }
  void add_triggered(bool triggered) {
    fbb_.AddElement<uint8_t>(Item::VT_TRIGGERED, static_cast<uint8_t>(triggered), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Item::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(Item::VT_STATUS, status, 0);
  }
  void add_is_airborne(bool is_airborne) {
    fbb_.AddElement<uint8_t>(Item::VT_IS_AIRBORNE, static_cast<uint8_t>(is_airborne), 0);
  }
  void add_hit_stauts(bool hit_stauts) {
    fbb_.AddElement<uint8_t>(Item::VT_HIT_STAUTS, static_cast<uint8_t>(hit_stauts), 0);
  }
  void add_collidable(bool collidable) {
    fbb_.AddElement<uint8_t>(Item::VT_COLLIDABLE, static_cast<uint8_t>(collidable), 0);
  }
  void add_looked_at(bool looked_at) {
    fbb_.AddElement<uint8_t>(Item::VT_LOOKED_AT, static_cast<uint8_t>(looked_at), 0);
  }
  void add_ai_bits(int32_t ai_bits) {
    fbb_.AddElement<int32_t>(Item::VT_AI_BITS, ai_bits, 0);
  }
  void add_swap_mesh_flags(int32_t swap_mesh_flags) {
    fbb_.AddElement<int32_t>(Item::VT_SWAP_MESH_FLAGS, swap_mesh_flags, 0);
  }
  void add_data_type(TEN::Save::ItemData data_type) {
    fbb_.AddElement<uint8_t>(Item::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Item::VT_DATA, data);
  }
  void add_lua_name(flatbuffers::Offset<flatbuffers::String> lua_name) {
    fbb_.AddOffset(Item::VT_LUA_NAME, lua_name);
  }
  void add_lua_on_killed_name(flatbuffers::Offset<flatbuffers::String> lua_on_killed_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_KILLED_NAME, lua_on_killed_name);
  }
  void add_lua_on_hit_name(flatbuffers::Offset<flatbuffers::String> lua_on_hit_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_HIT_NAME, lua_on_hit_name);
  }
  void add_lua_on_collided_with_object_name(flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_object_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME, lua_on_collided_with_object_name);
  }
  void add_lua_on_collided_with_room_name(flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_room_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_COLLIDED_WITH_ROOM_NAME, lua_on_collided_with_room_name);
  }
  explicit ItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline flatbuffers::Offset<Item> CreateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t active_state = 0,
    int32_t target_state = 0,
    int32_t required_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t room_number = 0,
    int32_t velocity = 0,
    int32_t vertical_velocity = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags = 0,
    const TEN::Save::Position *position = 0,
    int32_t next_item = 0,
    int32_t next_item_active = 0,
    bool triggered = false,
    bool active = false,
    int32_t status = 0,
    bool is_airborne = false,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    int32_t ai_bits = 0,
    int32_t swap_mesh_flags = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0,
    flatbuffers::Offset<flatbuffers::String> lua_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_killed_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_hit_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_object_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_room_name = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_lua_on_collided_with_room_name(lua_on_collided_with_room_name);
  builder_.add_lua_on_collided_with_object_name(lua_on_collided_with_object_name);
  builder_.add_lua_on_hit_name(lua_on_hit_name);
  builder_.add_lua_on_killed_name(lua_on_killed_name);
  builder_.add_lua_name(lua_name);
  builder_.add_data(data);
  builder_.add_swap_mesh_flags(swap_mesh_flags);
  builder_.add_ai_bits(ai_bits);
  builder_.add_status(status);
  builder_.add_next_item_active(next_item_active);
  builder_.add_next_item(next_item);
  builder_.add_position(position);
  builder_.add_item_flags(item_flags);
  builder_.add_after_death(after_death);
  builder_.add_carried_item(carried_item);
  builder_.add_trigger_flags(trigger_flags);
  builder_.add_flags(flags);
  builder_.add_color(color);
  builder_.add_timer(timer);
  builder_.add_box_number(box_number);
  builder_.add_hit_points(hit_points);
  builder_.add_vertical_velocity(vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_room_number(room_number);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_required_state(required_state);
  builder_.add_target_state(target_state);
  builder_.add_active_state(active_state);
  builder_.add_object_id(object_id);
  builder_.add_mesh_bits(mesh_bits);
  builder_.add_touch_bits(touch_bits);
  builder_.add_floor(floor);
  builder_.add_data_type(data_type);
  builder_.add_looked_at(looked_at);
  builder_.add_collidable(collidable);
  builder_.add_hit_stauts(hit_stauts);
  builder_.add_is_airborne(is_airborne);
  builder_.add_active(active);
  builder_.add_triggered(triggered);
  return builder_.Finish();
}

struct Item::Traits {
  using type = Item;
  static auto constexpr Create = CreateItem;
};

inline flatbuffers::Offset<Item> CreateItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t active_state = 0,
    int32_t target_state = 0,
    int32_t required_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t room_number = 0,
    int32_t velocity = 0,
    int32_t vertical_velocity = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    const std::vector<int32_t> *item_flags = nullptr,
    const TEN::Save::Position *position = 0,
    int32_t next_item = 0,
    int32_t next_item_active = 0,
    bool triggered = false,
    bool active = false,
    int32_t status = 0,
    bool is_airborne = false,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    int32_t ai_bits = 0,
    int32_t swap_mesh_flags = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0,
    const char *lua_name = nullptr,
    const char *lua_on_killed_name = nullptr,
    const char *lua_on_hit_name = nullptr,
    const char *lua_on_collided_with_object_name = nullptr,
    const char *lua_on_collided_with_room_name = nullptr) {
  auto item_flags__ = item_flags ? _fbb.CreateVector<int32_t>(*item_flags) : 0;
  auto lua_name__ = lua_name ? _fbb.CreateString(lua_name) : 0;
  auto lua_on_killed_name__ = lua_on_killed_name ? _fbb.CreateString(lua_on_killed_name) : 0;
  auto lua_on_hit_name__ = lua_on_hit_name ? _fbb.CreateString(lua_on_hit_name) : 0;
  auto lua_on_collided_with_object_name__ = lua_on_collided_with_object_name ? _fbb.CreateString(lua_on_collided_with_object_name) : 0;
  auto lua_on_collided_with_room_name__ = lua_on_collided_with_room_name ? _fbb.CreateString(lua_on_collided_with_room_name) : 0;
  return TEN::Save::CreateItem(
      _fbb,
      floor,
      touch_bits,
      mesh_bits,
      object_id,
      active_state,
      target_state,
      required_state,
      anim_number,
      frame_number,
      room_number,
      velocity,
      vertical_velocity,
      hit_points,
      box_number,
      timer,
      color,
      flags,
      trigger_flags,
      carried_item,
      after_death,
      item_flags__,
      position,
      next_item,
      next_item_active,
      triggered,
      active,
      status,
      is_airborne,
      hit_stauts,
      collidable,
      looked_at,
      ai_bits,
      swap_mesh_flags,
      data_type,
      data,
      lua_name__,
      lua_on_killed_name__,
      lua_on_hit_name__,
      lua_on_collided_with_object_name__,
      lua_on_collided_with_room_name__);
}

flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FXInfoT : public flatbuffers::NativeTable {
  typedef FXInfo TableType;
  std::unique_ptr<TEN::Save::Position> pos{};
  int32_t room_number = 0;
  int32_t object_number = 0;
  int32_t next_fx = 0;
  int32_t next_active = 0;
  int32_t speed = 0;
  int32_t fall_speed = 0;
  int32_t frame_number = 0;
  int32_t counter = 0;
  int32_t shade = 0;
  int32_t flag1 = 0;
  int32_t flag2 = 0;
};

struct FXInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FXInfoT NativeTableType;
  typedef FXInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROOM_NUMBER = 6,
    VT_OBJECT_NUMBER = 8,
    VT_NEXT_FX = 10,
    VT_NEXT_ACTIVE = 12,
    VT_SPEED = 14,
    VT_FALL_SPEED = 16,
    VT_FRAME_NUMBER = 18,
    VT_COUNTER = 20,
    VT_SHADE = 22,
    VT_FLAG1 = 24,
    VT_FLAG2 = 26
  };
  const TEN::Save::Position *pos() const {
    return GetStruct<const TEN::Save::Position *>(VT_POS);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t object_number() const {
    return GetField<int32_t>(VT_OBJECT_NUMBER, 0);
  }
  int32_t next_fx() const {
    return GetField<int32_t>(VT_NEXT_FX, 0);
  }
  int32_t next_active() const {
    return GetField<int32_t>(VT_NEXT_ACTIVE, 0);
  }
  int32_t speed() const {
    return GetField<int32_t>(VT_SPEED, 0);
  }
  int32_t fall_speed() const {
    return GetField<int32_t>(VT_FALL_SPEED, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t counter() const {
    return GetField<int32_t>(VT_COUNTER, 0);
  }
  int32_t shade() const {
    return GetField<int32_t>(VT_SHADE, 0);
  }
  int32_t flag1() const {
    return GetField<int32_t>(VT_FLAG1, 0);
  }
  int32_t flag2() const {
    return GetField<int32_t>(VT_FLAG2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Position>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FALL_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_COUNTER) &&
           VerifyField<int32_t>(verifier, VT_SHADE) &&
           VerifyField<int32_t>(verifier, VT_FLAG1) &&
           VerifyField<int32_t>(verifier, VT_FLAG2) &&
           verifier.EndTable();
  }
  FXInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FXInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FXInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FXInfoBuilder {
  typedef FXInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const TEN::Save::Position *pos) {
    fbb_.AddStruct(FXInfo::VT_POS, pos);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_object_number(int32_t object_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_next_fx(int32_t next_fx) {
    fbb_.AddElement<int32_t>(FXInfo::VT_NEXT_FX, next_fx, 0);
  }
  void add_next_active(int32_t next_active) {
    fbb_.AddElement<int32_t>(FXInfo::VT_NEXT_ACTIVE, next_active, 0);
  }
  void add_speed(int32_t speed) {
    fbb_.AddElement<int32_t>(FXInfo::VT_SPEED, speed, 0);
  }
  void add_fall_speed(int32_t fall_speed) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FALL_SPEED, fall_speed, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_counter(int32_t counter) {
    fbb_.AddElement<int32_t>(FXInfo::VT_COUNTER, counter, 0);
  }
  void add_shade(int32_t shade) {
    fbb_.AddElement<int32_t>(FXInfo::VT_SHADE, shade, 0);
  }
  void add_flag1(int32_t flag1) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FLAG1, flag1, 0);
  }
  void add_flag2(int32_t flag2) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FLAG2, flag2, 0);
  }
  explicit FXInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FXInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FXInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FXInfo> CreateFXInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Position *pos = 0,
    int32_t room_number = 0,
    int32_t object_number = 0,
    int32_t next_fx = 0,
    int32_t next_active = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t frame_number = 0,
    int32_t counter = 0,
    int32_t shade = 0,
    int32_t flag1 = 0,
    int32_t flag2 = 0) {
  FXInfoBuilder builder_(_fbb);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  builder_.add_shade(shade);
  builder_.add_counter(counter);
  builder_.add_frame_number(frame_number);
  builder_.add_fall_speed(fall_speed);
  builder_.add_speed(speed);
  builder_.add_next_active(next_active);
  builder_.add_next_fx(next_fx);
  builder_.add_object_number(object_number);
  builder_.add_room_number(room_number);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct FXInfo::Traits {
  using type = FXInfo;
  static auto constexpr Create = CreateFXInfo;
};

flatbuffers::Offset<FXInfo> CreateFXInfo(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AmmoInfoT : public flatbuffers::NativeTable {
  typedef AmmoInfo TableType;
  int32_t count = 0;
  bool is_infinite = false;
};

struct AmmoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AmmoInfoT NativeTableType;
  typedef AmmoInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_IS_INFINITE = 6
  };
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool is_infinite() const {
    return GetField<uint8_t>(VT_IS_INFINITE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_IS_INFINITE) &&
           verifier.EndTable();
  }
  AmmoInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AmmoInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AmmoInfoBuilder {
  typedef AmmoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(AmmoInfo::VT_COUNT, count, 0);
  }
  void add_is_infinite(bool is_infinite) {
    fbb_.AddElement<uint8_t>(AmmoInfo::VT_IS_INFINITE, static_cast<uint8_t>(is_infinite), 0);
  }
  explicit AmmoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AmmoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AmmoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count = 0,
    bool is_infinite = false) {
  AmmoInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_is_infinite(is_infinite);
  return builder_.Finish();
}

struct AmmoInfo::Traits {
  using type = AmmoInfo;
  static auto constexpr Create = CreateAmmoInfo;
};

flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HolsterInfoT : public flatbuffers::NativeTable {
  typedef HolsterInfo TableType;
  int32_t left_holster = 0;
  int32_t right_holster = 0;
  int32_t back_holster = 0;
};

struct HolsterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HolsterInfoT NativeTableType;
  typedef HolsterInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_HOLSTER = 4,
    VT_RIGHT_HOLSTER = 6,
    VT_BACK_HOLSTER = 8
  };
  int32_t left_holster() const {
    return GetField<int32_t>(VT_LEFT_HOLSTER, 0);
  }
  int32_t right_holster() const {
    return GetField<int32_t>(VT_RIGHT_HOLSTER, 0);
  }
  int32_t back_holster() const {
    return GetField<int32_t>(VT_BACK_HOLSTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_BACK_HOLSTER) &&
           verifier.EndTable();
  }
  HolsterInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HolsterInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HolsterInfoBuilder {
  typedef HolsterInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_holster(int32_t left_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_LEFT_HOLSTER, left_holster, 0);
  }
  void add_right_holster(int32_t right_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_RIGHT_HOLSTER, right_holster, 0);
  }
  void add_back_holster(int32_t back_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_BACK_HOLSTER, back_holster, 0);
  }
  explicit HolsterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HolsterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HolsterInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_holster = 0,
    int32_t right_holster = 0,
    int32_t back_holster = 0) {
  HolsterInfoBuilder builder_(_fbb);
  builder_.add_back_holster(back_holster);
  builder_.add_right_holster(right_holster);
  builder_.add_left_holster(left_holster);
  return builder_.Finish();
}

struct HolsterInfo::Traits {
  using type = HolsterInfo;
  static auto constexpr Create = CreateHolsterInfo;
};

flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CarriedWeaponInfoT : public flatbuffers::NativeTable {
  typedef CarriedWeaponInfo TableType;
  bool present = false;
  std::vector<std::unique_ptr<TEN::Save::AmmoInfoT>> ammo{};
  int32_t selected_ammo = 0;
  bool has_lasersight = false;
  bool has_silencer = false;
};

struct CarriedWeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CarriedWeaponInfoT NativeTableType;
  typedef CarriedWeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESENT = 4,
    VT_AMMO = 6,
    VT_SELECTED_AMMO = 8,
    VT_HAS_LASERSIGHT = 10,
    VT_HAS_SILENCER = 12
  };
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *>(VT_AMMO);
  }
  int32_t selected_ammo() const {
    return GetField<int32_t>(VT_SELECTED_AMMO, 0);
  }
  bool has_lasersight() const {
    return GetField<uint8_t>(VT_HAS_LASERSIGHT, 0) != 0;
  }
  bool has_silencer() const {
    return GetField<uint8_t>(VT_HAS_SILENCER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT) &&
           VerifyOffset(verifier, VT_AMMO) &&
           verifier.VerifyVector(ammo()) &&
           verifier.VerifyVectorOfTables(ammo()) &&
           VerifyField<int32_t>(verifier, VT_SELECTED_AMMO) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SILENCER) &&
           verifier.EndTable();
  }
  CarriedWeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CarriedWeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CarriedWeaponInfoBuilder {
  typedef CarriedWeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  void add_ammo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo) {
    fbb_.AddOffset(CarriedWeaponInfo::VT_AMMO, ammo);
  }
  void add_selected_ammo(int32_t selected_ammo) {
    fbb_.AddElement<int32_t>(CarriedWeaponInfo::VT_SELECTED_AMMO, selected_ammo, 0);
  }
  void add_has_lasersight(bool has_lasersight) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_LASERSIGHT, static_cast<uint8_t>(has_lasersight), 0);
  }
  void add_has_silencer(bool has_silencer) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_SILENCER, static_cast<uint8_t>(has_silencer), 0);
  }
  explicit CarriedWeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CarriedWeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CarriedWeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo = 0,
    int32_t selected_ammo = 0,
    bool has_lasersight = false,
    bool has_silencer = false) {
  CarriedWeaponInfoBuilder builder_(_fbb);
  builder_.add_selected_ammo(selected_ammo);
  builder_.add_ammo(ammo);
  builder_.add_has_silencer(has_silencer);
  builder_.add_has_lasersight(has_lasersight);
  builder_.add_present(present);
  return builder_.Finish();
}

struct CarriedWeaponInfo::Traits {
  using type = CarriedWeaponInfo;
  static auto constexpr Create = CreateCarriedWeaponInfo;
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    const std::vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo = nullptr,
    int32_t selected_ammo = 0,
    bool has_lasersight = false,
    bool has_silencer = false) {
  auto ammo__ = ammo ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>>(*ammo) : 0;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      present,
      ammo__,
      selected_ammo,
      has_lasersight,
      has_silencer);
}

flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponInfoT : public flatbuffers::NativeTable {
  typedef WeaponInfo TableType;
  uint32_t object_number = 0;
  uint32_t anim_number = 0;
  uint32_t frame_number = 0;
  uint32_t active_state = 0;
  uint32_t target_state = 0;
};

struct WeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponInfoT NativeTableType;
  typedef WeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NUMBER = 4,
    VT_ANIM_NUMBER = 6,
    VT_FRAME_NUMBER = 8,
    VT_ACTIVE_STATE = 10,
    VT_TARGET_STATE = 12
  };
  uint32_t object_number() const {
    return GetField<uint32_t>(VT_OBJECT_NUMBER, 0);
  }
  uint32_t anim_number() const {
    return GetField<uint32_t>(VT_ANIM_NUMBER, 0);
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  uint32_t active_state() const {
    return GetField<uint32_t>(VT_ACTIVE_STATE, 0);
  }
  uint32_t target_state() const {
    return GetField<uint32_t>(VT_TARGET_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_ACTIVE_STATE) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_STATE) &&
           verifier.EndTable();
  }
  WeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponInfoBuilder {
  typedef WeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_number(uint32_t object_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_anim_number(uint32_t anim_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_active_state(uint32_t active_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_ACTIVE_STATE, active_state, 0);
  }
  void add_target_state(uint32_t target_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_TARGET_STATE, target_state, 0);
  }
  explicit WeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_number = 0,
    uint32_t anim_number = 0,
    uint32_t frame_number = 0,
    uint32_t active_state = 0,
    uint32_t target_state = 0) {
  WeaponInfoBuilder builder_(_fbb);
  builder_.add_target_state(target_state);
  builder_.add_active_state(active_state);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_object_number(object_number);
  return builder_.Finish();
}

struct WeaponInfo::Traits {
  using type = WeaponInfo;
  static auto constexpr Create = CreateWeaponInfo;
};

flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArmInfoT : public flatbuffers::NativeTable {
  typedef ArmInfo TableType;
  int32_t anim_number = 0;
  int32_t frame_number = 0;
  int32_t frame_base = 0;
  bool locked = false;
  std::unique_ptr<TEN::Save::Vector3> rotation{};
  int32_t gun_flash = 0;
  int32_t gun_smoke = 0;
};

struct ArmInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArmInfoT NativeTableType;
  typedef ArmInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIM_NUMBER = 4,
    VT_FRAME_NUMBER = 6,
    VT_FRAME_BASE = 8,
    VT_LOCKED = 10,
    VT_ROTATION = 12,
    VT_GUN_FLASH = 14,
    VT_GUN_SMOKE = 16
  };
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t frame_base() const {
    return GetField<int32_t>(VT_FRAME_BASE, 0);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  const TEN::Save::Vector3 *rotation() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_ROTATION);
  }
  int32_t gun_flash() const {
    return GetField<int32_t>(VT_GUN_FLASH, 0);
  }
  int32_t gun_smoke() const {
    return GetField<int32_t>(VT_GUN_SMOKE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_BASE) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_ROTATION) &&
           VerifyField<int32_t>(verifier, VT_GUN_FLASH) &&
           VerifyField<int32_t>(verifier, VT_GUN_SMOKE) &&
           verifier.EndTable();
  }
  ArmInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArmInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArmInfoBuilder {
  typedef ArmInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_frame_base(int32_t frame_base) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_FRAME_BASE, frame_base, 0);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(ArmInfo::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  void add_rotation(const TEN::Save::Vector3 *rotation) {
    fbb_.AddStruct(ArmInfo::VT_ROTATION, rotation);
  }
  void add_gun_flash(int32_t gun_flash) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_GUN_FLASH, gun_flash, 0);
  }
  void add_gun_smoke(int32_t gun_smoke) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_GUN_SMOKE, gun_smoke, 0);
  }
  explicit ArmInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArmInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArmInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArmInfo> CreateArmInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t frame_base = 0,
    bool locked = false,
    const TEN::Save::Vector3 *rotation = 0,
    int32_t gun_flash = 0,
    int32_t gun_smoke = 0) {
  ArmInfoBuilder builder_(_fbb);
  builder_.add_gun_smoke(gun_smoke);
  builder_.add_gun_flash(gun_flash);
  builder_.add_rotation(rotation);
  builder_.add_frame_base(frame_base);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_locked(locked);
  return builder_.Finish();
}

struct ArmInfo::Traits {
  using type = ArmInfo;
  static auto constexpr Create = CreateArmInfo;
};

flatbuffers::Offset<ArmInfo> CreateArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlareDataT : public flatbuffers::NativeTable {
  typedef FlareData TableType;
  uint32_t life = 0;
  int32_t frame = 0;
  bool control_left = false;
};

struct FlareData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlareDataT NativeTableType;
  typedef FlareDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIFE = 4,
    VT_FRAME = 6,
    VT_CONTROL_LEFT = 8
  };
  uint32_t life() const {
    return GetField<uint32_t>(VT_LIFE, 0);
  }
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  bool control_left() const {
    return GetField<uint8_t>(VT_CONTROL_LEFT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_CONTROL_LEFT) &&
           verifier.EndTable();
  }
  FlareDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlareDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlareData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlareDataBuilder {
  typedef FlareData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_life(uint32_t life) {
    fbb_.AddElement<uint32_t>(FlareData::VT_LIFE, life, 0);
  }
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(FlareData::VT_FRAME, frame, 0);
  }
  void add_control_left(bool control_left) {
    fbb_.AddElement<uint8_t>(FlareData::VT_CONTROL_LEFT, static_cast<uint8_t>(control_left), 0);
  }
  explicit FlareDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlareData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlareData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlareData> CreateFlareData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t life = 0,
    int32_t frame = 0,
    bool control_left = false) {
  FlareDataBuilder builder_(_fbb);
  builder_.add_frame(frame);
  builder_.add_life(life);
  builder_.add_control_left(control_left);
  return builder_.Finish();
}

struct FlareData::Traits {
  using type = FlareData;
  static auto constexpr Create = CreateFlareData;
};

flatbuffers::Offset<FlareData> CreateFlareData(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TorchDataT : public flatbuffers::NativeTable {
  typedef TorchData TableType;
  TEN::Save::TorchState state = TEN::Save::TorchState::holding;
  bool is_lit = false;
};

struct TorchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TorchDataT NativeTableType;
  typedef TorchDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_IS_LIT = 6
  };
  TEN::Save::TorchState state() const {
    return static_cast<TEN::Save::TorchState>(GetField<int32_t>(VT_STATE, 0));
  }
  bool is_lit() const {
    return GetField<uint8_t>(VT_IS_LIT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<uint8_t>(verifier, VT_IS_LIT) &&
           verifier.EndTable();
  }
  TorchDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TorchDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TorchData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TorchDataBuilder {
  typedef TorchData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(TEN::Save::TorchState state) {
    fbb_.AddElement<int32_t>(TorchData::VT_STATE, static_cast<int32_t>(state), 0);
  }
  void add_is_lit(bool is_lit) {
    fbb_.AddElement<uint8_t>(TorchData::VT_IS_LIT, static_cast<uint8_t>(is_lit), 0);
  }
  explicit TorchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TorchData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TorchData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TorchData> CreateTorchData(
    flatbuffers::FlatBufferBuilder &_fbb,
    TEN::Save::TorchState state = TEN::Save::TorchState::holding,
    bool is_lit = false) {
  TorchDataBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_is_lit(is_lit);
  return builder_.Finish();
}

struct TorchData::Traits {
  using type = TorchData;
  static auto constexpr Create = CreateTorchData;
};

flatbuffers::Offset<TorchData> CreateTorchData(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraInventoryDataT : public flatbuffers::NativeTable {
  typedef LaraInventoryData TableType;
  bool is_busy = false;
  bool old_busy = false;
  int32_t beetle_life = 0;
  int32_t beetle_components = 0;
  int32_t small_waterskin = 0;
  int32_t big_waterskin = 0;
  bool has_binoculars = false;
  bool has_crowbar = false;
  bool has_torch = false;
  bool has_lasersight = false;
  bool has_silencer = false;
  int32_t total_small_medipacks = 0;
  int32_t total_large_medipacks = 0;
  int32_t total_flares = 0;
  uint32_t total_secrets = 0;
  std::vector<int32_t> puzzles{};
  std::vector<int32_t> keys{};
  std::vector<int32_t> pickups{};
  std::vector<int32_t> examines{};
  std::vector<int32_t> puzzles_combo{};
  std::vector<int32_t> keys_combo{};
  std::vector<int32_t> pickups_combo{};
  std::vector<int32_t> examines_combo{};
};

struct LaraInventoryData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraInventoryDataT NativeTableType;
  typedef LaraInventoryDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_BUSY = 4,
    VT_OLD_BUSY = 6,
    VT_BEETLE_LIFE = 8,
    VT_BEETLE_COMPONENTS = 10,
    VT_SMALL_WATERSKIN = 12,
    VT_BIG_WATERSKIN = 14,
    VT_HAS_BINOCULARS = 16,
    VT_HAS_CROWBAR = 18,
    VT_HAS_TORCH = 20,
    VT_HAS_LASERSIGHT = 22,
    VT_HAS_SILENCER = 24,
    VT_TOTAL_SMALL_MEDIPACKS = 26,
    VT_TOTAL_LARGE_MEDIPACKS = 28,
    VT_TOTAL_FLARES = 30,
    VT_TOTAL_SECRETS = 32,
    VT_PUZZLES = 34,
    VT_KEYS = 36,
    VT_PICKUPS = 38,
    VT_EXAMINES = 40,
    VT_PUZZLES_COMBO = 42,
    VT_KEYS_COMBO = 44,
    VT_PICKUPS_COMBO = 46,
    VT_EXAMINES_COMBO = 48
  };
  bool is_busy() const {
    return GetField<uint8_t>(VT_IS_BUSY, 0) != 0;
  }
  bool old_busy() const {
    return GetField<uint8_t>(VT_OLD_BUSY, 0) != 0;
  }
  int32_t beetle_life() const {
    return GetField<int32_t>(VT_BEETLE_LIFE, 0);
  }
  int32_t beetle_components() const {
    return GetField<int32_t>(VT_BEETLE_COMPONENTS, 0);
  }
  int32_t small_waterskin() const {
    return GetField<int32_t>(VT_SMALL_WATERSKIN, 0);
  }
  int32_t big_waterskin() const {
    return GetField<int32_t>(VT_BIG_WATERSKIN, 0);
  }
  bool has_binoculars() const {
    return GetField<uint8_t>(VT_HAS_BINOCULARS, 0) != 0;
  }
  bool has_crowbar() const {
    return GetField<uint8_t>(VT_HAS_CROWBAR, 0) != 0;
  }
  bool has_torch() const {
    return GetField<uint8_t>(VT_HAS_TORCH, 0) != 0;
  }
  bool has_lasersight() const {
    return GetField<uint8_t>(VT_HAS_LASERSIGHT, 0) != 0;
  }
  bool has_silencer() const {
    return GetField<uint8_t>(VT_HAS_SILENCER, 0) != 0;
  }
  int32_t total_small_medipacks() const {
    return GetField<int32_t>(VT_TOTAL_SMALL_MEDIPACKS, 0);
  }
  int32_t total_large_medipacks() const {
    return GetField<int32_t>(VT_TOTAL_LARGE_MEDIPACKS, 0);
  }
  int32_t total_flares() const {
    return GetField<int32_t>(VT_TOTAL_FLARES, 0);
  }
  uint32_t total_secrets() const {
    return GetField<uint32_t>(VT_TOTAL_SECRETS, 0);
  }
  const flatbuffers::Vector<int32_t> *puzzles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES);
  }
  const flatbuffers::Vector<int32_t> *keys() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS);
  }
  const flatbuffers::Vector<int32_t> *pickups() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS);
  }
  const flatbuffers::Vector<int32_t> *examines() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES);
  }
  const flatbuffers::Vector<int32_t> *puzzles_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES_COMBO);
  }
  const flatbuffers::Vector<int32_t> *keys_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *pickups_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *examines_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES_COMBO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_BUSY) &&
           VerifyField<uint8_t>(verifier, VT_OLD_BUSY) &&
           VerifyField<int32_t>(verifier, VT_BEETLE_LIFE) &&
           VerifyField<int32_t>(verifier, VT_BEETLE_COMPONENTS) &&
           VerifyField<int32_t>(verifier, VT_SMALL_WATERSKIN) &&
           VerifyField<int32_t>(verifier, VT_BIG_WATERSKIN) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BINOCULARS) &&
           VerifyField<uint8_t>(verifier, VT_HAS_CROWBAR) &&
           VerifyField<uint8_t>(verifier, VT_HAS_TORCH) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SILENCER) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_SMALL_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_LARGE_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_FLARES) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SECRETS) &&
           VerifyOffset(verifier, VT_PUZZLES) &&
           verifier.VerifyVector(puzzles()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_PICKUPS) &&
           verifier.VerifyVector(pickups()) &&
           VerifyOffset(verifier, VT_EXAMINES) &&
           verifier.VerifyVector(examines()) &&
           VerifyOffset(verifier, VT_PUZZLES_COMBO) &&
           verifier.VerifyVector(puzzles_combo()) &&
           VerifyOffset(verifier, VT_KEYS_COMBO) &&
           verifier.VerifyVector(keys_combo()) &&
           VerifyOffset(verifier, VT_PICKUPS_COMBO) &&
           verifier.VerifyVector(pickups_combo()) &&
           VerifyOffset(verifier, VT_EXAMINES_COMBO) &&
           verifier.VerifyVector(examines_combo()) &&
           verifier.EndTable();
  }
  LaraInventoryDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraInventoryDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraInventoryData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraInventoryDataBuilder {
  typedef LaraInventoryData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_busy(bool is_busy) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_IS_BUSY, static_cast<uint8_t>(is_busy), 0);
  }
  void add_old_busy(bool old_busy) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_OLD_BUSY, static_cast<uint8_t>(old_busy), 0);
  }
  void add_beetle_life(int32_t beetle_life) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BEETLE_LIFE, beetle_life, 0);
  }
  void add_beetle_components(int32_t beetle_components) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BEETLE_COMPONENTS, beetle_components, 0);
  }
  void add_small_waterskin(int32_t small_waterskin) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_SMALL_WATERSKIN, small_waterskin, 0);
  }
  void add_big_waterskin(int32_t big_waterskin) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BIG_WATERSKIN, big_waterskin, 0);
  }
  void add_has_binoculars(bool has_binoculars) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_BINOCULARS, static_cast<uint8_t>(has_binoculars), 0);
  }
  void add_has_crowbar(bool has_crowbar) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_CROWBAR, static_cast<uint8_t>(has_crowbar), 0);
  }
  void add_has_torch(bool has_torch) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_TORCH, static_cast<uint8_t>(has_torch), 0);
  }
  void add_has_lasersight(bool has_lasersight) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_LASERSIGHT, static_cast<uint8_t>(has_lasersight), 0);
  }
  void add_has_silencer(bool has_silencer) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_SILENCER, static_cast<uint8_t>(has_silencer), 0);
  }
  void add_total_small_medipacks(int32_t total_small_medipacks) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_SMALL_MEDIPACKS, total_small_medipacks, 0);
  }
  void add_total_large_medipacks(int32_t total_large_medipacks) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_LARGE_MEDIPACKS, total_large_medipacks, 0);
  }
  void add_total_flares(int32_t total_flares) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_FLARES, total_flares, 0);
  }
  void add_total_secrets(uint32_t total_secrets) {
    fbb_.AddElement<uint32_t>(LaraInventoryData::VT_TOTAL_SECRETS, total_secrets, 0);
  }
  void add_puzzles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles) {
    fbb_.AddOffset(LaraInventoryData::VT_PUZZLES, puzzles);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys) {
    fbb_.AddOffset(LaraInventoryData::VT_KEYS, keys);
  }
  void add_pickups(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups) {
    fbb_.AddOffset(LaraInventoryData::VT_PICKUPS, pickups);
  }
  void add_examines(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines) {
    fbb_.AddOffset(LaraInventoryData::VT_EXAMINES, examines);
  }
  void add_puzzles_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_PUZZLES_COMBO, puzzles_combo);
  }
  void add_keys_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_KEYS_COMBO, keys_combo);
  }
  void add_pickups_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_PICKUPS_COMBO, pickups_combo);
  }
  void add_examines_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_EXAMINES_COMBO, examines_combo);
  }
  explicit LaraInventoryDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraInventoryData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraInventoryData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_busy = false,
    bool old_busy = false,
    int32_t beetle_life = 0,
    int32_t beetle_components = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    bool has_binoculars = false,
    bool has_crowbar = false,
    bool has_torch = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    int32_t total_small_medipacks = 0,
    int32_t total_large_medipacks = 0,
    int32_t total_flares = 0,
    uint32_t total_secrets = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo = 0) {
  LaraInventoryDataBuilder builder_(_fbb);
  builder_.add_examines_combo(examines_combo);
  builder_.add_pickups_combo(pickups_combo);
  builder_.add_keys_combo(keys_combo);
  builder_.add_puzzles_combo(puzzles_combo);
  builder_.add_examines(examines);
  builder_.add_pickups(pickups);
  builder_.add_keys(keys);
  builder_.add_puzzles(puzzles);
  builder_.add_total_secrets(total_secrets);
  builder_.add_total_flares(total_flares);
  builder_.add_total_large_medipacks(total_large_medipacks);
  builder_.add_total_small_medipacks(total_small_medipacks);
  builder_.add_big_waterskin(big_waterskin);
  builder_.add_small_waterskin(small_waterskin);
  builder_.add_beetle_components(beetle_components);
  builder_.add_beetle_life(beetle_life);
  builder_.add_has_silencer(has_silencer);
  builder_.add_has_lasersight(has_lasersight);
  builder_.add_has_torch(has_torch);
  builder_.add_has_crowbar(has_crowbar);
  builder_.add_has_binoculars(has_binoculars);
  builder_.add_old_busy(old_busy);
  builder_.add_is_busy(is_busy);
  return builder_.Finish();
}

struct LaraInventoryData::Traits {
  using type = LaraInventoryData;
  static auto constexpr Create = CreateLaraInventoryData;
};

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_busy = false,
    bool old_busy = false,
    int32_t beetle_life = 0,
    int32_t beetle_components = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    bool has_binoculars = false,
    bool has_crowbar = false,
    bool has_torch = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    int32_t total_small_medipacks = 0,
    int32_t total_large_medipacks = 0,
    int32_t total_flares = 0,
    uint32_t total_secrets = 0,
    const std::vector<int32_t> *puzzles = nullptr,
    const std::vector<int32_t> *keys = nullptr,
    const std::vector<int32_t> *pickups = nullptr,
    const std::vector<int32_t> *examines = nullptr,
    const std::vector<int32_t> *puzzles_combo = nullptr,
    const std::vector<int32_t> *keys_combo = nullptr,
    const std::vector<int32_t> *pickups_combo = nullptr,
    const std::vector<int32_t> *examines_combo = nullptr) {
  auto puzzles__ = puzzles ? _fbb.CreateVector<int32_t>(*puzzles) : 0;
  auto keys__ = keys ? _fbb.CreateVector<int32_t>(*keys) : 0;
  auto pickups__ = pickups ? _fbb.CreateVector<int32_t>(*pickups) : 0;
  auto examines__ = examines ? _fbb.CreateVector<int32_t>(*examines) : 0;
  auto puzzles_combo__ = puzzles_combo ? _fbb.CreateVector<int32_t>(*puzzles_combo) : 0;
  auto keys_combo__ = keys_combo ? _fbb.CreateVector<int32_t>(*keys_combo) : 0;
  auto pickups_combo__ = pickups_combo ? _fbb.CreateVector<int32_t>(*pickups_combo) : 0;
  auto examines_combo__ = examines_combo ? _fbb.CreateVector<int32_t>(*examines_combo) : 0;
  return TEN::Save::CreateLaraInventoryData(
      _fbb,
      is_busy,
      old_busy,
      beetle_life,
      beetle_components,
      small_waterskin,
      big_waterskin,
      has_binoculars,
      has_crowbar,
      has_torch,
      has_lasersight,
      has_silencer,
      total_small_medipacks,
      total_large_medipacks,
      total_flares,
      total_secrets,
      puzzles__,
      keys__,
      pickups__,
      examines__,
      puzzles_combo__,
      keys_combo__,
      pickups_combo__,
      examines_combo__);
}

flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraCountDataT : public flatbuffers::NativeTable {
  typedef LaraCountData TableType;
  uint32_t run_jump = 0;
  uint32_t position_adjust = 0;
  uint32_t pose = 0;
  uint32_t death = 0;
  uint32_t no_cheat = 0;
};

struct LaraCountData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraCountDataT NativeTableType;
  typedef LaraCountDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RUN_JUMP = 4,
    VT_POSITION_ADJUST = 6,
    VT_POSE = 8,
    VT_DEATH = 10,
    VT_NO_CHEAT = 12
  };
  uint32_t run_jump() const {
    return GetField<uint32_t>(VT_RUN_JUMP, 0);
  }
  uint32_t position_adjust() const {
    return GetField<uint32_t>(VT_POSITION_ADJUST, 0);
  }
  uint32_t pose() const {
    return GetField<uint32_t>(VT_POSE, 0);
  }
  uint32_t death() const {
    return GetField<uint32_t>(VT_DEATH, 0);
  }
  uint32_t no_cheat() const {
    return GetField<uint32_t>(VT_NO_CHEAT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RUN_JUMP) &&
           VerifyField<uint32_t>(verifier, VT_POSITION_ADJUST) &&
           VerifyField<uint32_t>(verifier, VT_POSE) &&
           VerifyField<uint32_t>(verifier, VT_DEATH) &&
           VerifyField<uint32_t>(verifier, VT_NO_CHEAT) &&
           verifier.EndTable();
  }
  LaraCountDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraCountDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraCountData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraCountDataBuilder {
  typedef LaraCountData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_run_jump(uint32_t run_jump) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_RUN_JUMP, run_jump, 0);
  }
  void add_position_adjust(uint32_t position_adjust) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_POSITION_ADJUST, position_adjust, 0);
  }
  void add_pose(uint32_t pose) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_POSE, pose, 0);
  }
  void add_death(uint32_t death) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_DEATH, death, 0);
  }
  void add_no_cheat(uint32_t no_cheat) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_NO_CHEAT, no_cheat, 0);
  }
  explicit LaraCountDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraCountData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraCountData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraCountData> CreateLaraCountData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t run_jump = 0,
    uint32_t position_adjust = 0,
    uint32_t pose = 0,
    uint32_t death = 0,
    uint32_t no_cheat = 0) {
  LaraCountDataBuilder builder_(_fbb);
  builder_.add_no_cheat(no_cheat);
  builder_.add_death(death);
  builder_.add_pose(pose);
  builder_.add_position_adjust(position_adjust);
  builder_.add_run_jump(run_jump);
  return builder_.Finish();
}

struct LaraCountData::Traits {
  using type = LaraCountData;
  static auto constexpr Create = CreateLaraCountData;
};

flatbuffers::Offset<LaraCountData> CreateLaraCountData(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponControlDataT : public flatbuffers::NativeTable {
  typedef WeaponControlData TableType;
  int32_t weapon_item = 0;
  bool has_fired = false;
  bool fired = false;
  bool uzi_left = false;
  bool uzi_right = false;
  int32_t gun_type = 0;
  int32_t request_gun_type = 0;
  int32_t last_gun_type = 0;
  std::unique_ptr<TEN::Save::HolsterInfoT> holster_info{};
};

struct WeaponControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponControlDataT NativeTableType;
  typedef WeaponControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEAPON_ITEM = 4,
    VT_HAS_FIRED = 6,
    VT_FIRED = 8,
    VT_UZI_LEFT = 10,
    VT_UZI_RIGHT = 12,
    VT_GUN_TYPE = 14,
    VT_REQUEST_GUN_TYPE = 16,
    VT_LAST_GUN_TYPE = 18,
    VT_HOLSTER_INFO = 20
  };
  int32_t weapon_item() const {
    return GetField<int32_t>(VT_WEAPON_ITEM, 0);
  }
  bool has_fired() const {
    return GetField<uint8_t>(VT_HAS_FIRED, 0) != 0;
  }
  bool fired() const {
    return GetField<uint8_t>(VT_FIRED, 0) != 0;
  }
  bool uzi_left() const {
    return GetField<uint8_t>(VT_UZI_LEFT, 0) != 0;
  }
  bool uzi_right() const {
    return GetField<uint8_t>(VT_UZI_RIGHT, 0) != 0;
  }
  int32_t gun_type() const {
    return GetField<int32_t>(VT_GUN_TYPE, 0);
  }
  int32_t request_gun_type() const {
    return GetField<int32_t>(VT_REQUEST_GUN_TYPE, 0);
  }
  int32_t last_gun_type() const {
    return GetField<int32_t>(VT_LAST_GUN_TYPE, 0);
  }
  const TEN::Save::HolsterInfo *holster_info() const {
    return GetPointer<const TEN::Save::HolsterInfo *>(VT_HOLSTER_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_ITEM) &&
           VerifyField<uint8_t>(verifier, VT_HAS_FIRED) &&
           VerifyField<uint8_t>(verifier, VT_FIRED) &&
           VerifyField<uint8_t>(verifier, VT_UZI_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_UZI_RIGHT) &&
           VerifyField<int32_t>(verifier, VT_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LAST_GUN_TYPE) &&
           VerifyOffset(verifier, VT_HOLSTER_INFO) &&
           verifier.VerifyTable(holster_info()) &&
           verifier.EndTable();
  }
  WeaponControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WeaponControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponControlDataBuilder {
  typedef WeaponControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weapon_item(int32_t weapon_item) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_WEAPON_ITEM, weapon_item, 0);
  }
  void add_has_fired(bool has_fired) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_HAS_FIRED, static_cast<uint8_t>(has_fired), 0);
  }
  void add_fired(bool fired) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_FIRED, static_cast<uint8_t>(fired), 0);
  }
  void add_uzi_left(bool uzi_left) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_UZI_LEFT, static_cast<uint8_t>(uzi_left), 0);
  }
  void add_uzi_right(bool uzi_right) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_UZI_RIGHT, static_cast<uint8_t>(uzi_right), 0);
  }
  void add_gun_type(int32_t gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_GUN_TYPE, gun_type, 0);
  }
  void add_request_gun_type(int32_t request_gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_REQUEST_GUN_TYPE, request_gun_type, 0);
  }
  void add_last_gun_type(int32_t last_gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_LAST_GUN_TYPE, last_gun_type, 0);
  }
  void add_holster_info(flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info) {
    fbb_.AddOffset(WeaponControlData::VT_HOLSTER_INFO, holster_info);
  }
  explicit WeaponControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeaponControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeaponControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t weapon_item = 0,
    bool has_fired = false,
    bool fired = false,
    bool uzi_left = false,
    bool uzi_right = false,
    int32_t gun_type = 0,
    int32_t request_gun_type = 0,
    int32_t last_gun_type = 0,
    flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info = 0) {
  WeaponControlDataBuilder builder_(_fbb);
  builder_.add_holster_info(holster_info);
  builder_.add_last_gun_type(last_gun_type);
  builder_.add_request_gun_type(request_gun_type);
  builder_.add_gun_type(gun_type);
  builder_.add_weapon_item(weapon_item);
  builder_.add_uzi_right(uzi_right);
  builder_.add_uzi_left(uzi_left);
  builder_.add_fired(fired);
  builder_.add_has_fired(has_fired);
  return builder_.Finish();
}

struct WeaponControlData::Traits {
  using type = WeaponControlData;
  static auto constexpr Create = CreateWeaponControlData;
};

flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeControlDataT : public flatbuffers::NativeTable {
  typedef RopeControlData TableType;
  int32_t segment = 0;
  int32_t direction = 0;
  int32_t arc_front = 0;
  int32_t arc_back = 0;
  int32_t last_x = 0;
  int32_t max_x_forward = 0;
  int32_t max_x_backward = 0;
  int32_t dframe = 0;
  int32_t frame = 0;
  int32_t frame_rate = 0;
  int32_t y = 0;
  int32_t ptr = 0;
  int32_t offset = 0;
  int32_t down_vel = 0;
  int32_t flag = 0;
  int32_t count = 0;
};

struct RopeControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeControlDataT NativeTableType;
  typedef RopeControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4,
    VT_DIRECTION = 6,
    VT_ARC_FRONT = 8,
    VT_ARC_BACK = 10,
    VT_LAST_X = 12,
    VT_MAX_X_FORWARD = 14,
    VT_MAX_X_BACKWARD = 16,
    VT_DFRAME = 18,
    VT_FRAME = 20,
    VT_FRAME_RATE = 22,
    VT_Y = 24,
    VT_PTR = 26,
    VT_OFFSET = 28,
    VT_DOWN_VEL = 30,
    VT_FLAG = 32,
    VT_COUNT = 34
  };
  int32_t segment() const {
    return GetField<int32_t>(VT_SEGMENT, 0);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  int32_t arc_front() const {
    return GetField<int32_t>(VT_ARC_FRONT, 0);
  }
  int32_t arc_back() const {
    return GetField<int32_t>(VT_ARC_BACK, 0);
  }
  int32_t last_x() const {
    return GetField<int32_t>(VT_LAST_X, 0);
  }
  int32_t max_x_forward() const {
    return GetField<int32_t>(VT_MAX_X_FORWARD, 0);
  }
  int32_t max_x_backward() const {
    return GetField<int32_t>(VT_MAX_X_BACKWARD, 0);
  }
  int32_t dframe() const {
    return GetField<int32_t>(VT_DFRAME, 0);
  }
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  int32_t frame_rate() const {
    return GetField<int32_t>(VT_FRAME_RATE, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t ptr() const {
    return GetField<int32_t>(VT_PTR, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  int32_t down_vel() const {
    return GetField<int32_t>(VT_DOWN_VEL, 0);
  }
  int32_t flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEGMENT) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_ARC_FRONT) &&
           VerifyField<int32_t>(verifier, VT_ARC_BACK) &&
           VerifyField<int32_t>(verifier, VT_LAST_X) &&
           VerifyField<int32_t>(verifier, VT_MAX_X_FORWARD) &&
           VerifyField<int32_t>(verifier, VT_MAX_X_BACKWARD) &&
           VerifyField<int32_t>(verifier, VT_DFRAME) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_FRAME_RATE) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_PTR) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_DOWN_VEL) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  RopeControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RopeControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeControlDataBuilder {
  typedef RopeControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(int32_t segment) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_SEGMENT, segment, 0);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DIRECTION, direction, 0);
  }
  void add_arc_front(int32_t arc_front) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_ARC_FRONT, arc_front, 0);
  }
  void add_arc_back(int32_t arc_back) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_ARC_BACK, arc_back, 0);
  }
  void add_last_x(int32_t last_x) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_LAST_X, last_x, 0);
  }
  void add_max_x_forward(int32_t max_x_forward) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_MAX_X_FORWARD, max_x_forward, 0);
  }
  void add_max_x_backward(int32_t max_x_backward) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_MAX_X_BACKWARD, max_x_backward, 0);
  }
  void add_dframe(int32_t dframe) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DFRAME, dframe, 0);
  }
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FRAME, frame, 0);
  }
  void add_frame_rate(int32_t frame_rate) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FRAME_RATE, frame_rate, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_Y, y, 0);
  }
  void add_ptr(int32_t ptr) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_PTR, ptr, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_OFFSET, offset, 0);
  }
  void add_down_vel(int32_t down_vel) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DOWN_VEL, down_vel, 0);
  }
  void add_flag(int32_t flag) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FLAG, flag, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_COUNT, count, 0);
  }
  explicit RopeControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RopeControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RopeControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RopeControlData> CreateRopeControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t segment = 0,
    int32_t direction = 0,
    int32_t arc_front = 0,
    int32_t arc_back = 0,
    int32_t last_x = 0,
    int32_t max_x_forward = 0,
    int32_t max_x_backward = 0,
    int32_t dframe = 0,
    int32_t frame = 0,
    int32_t frame_rate = 0,
    int32_t y = 0,
    int32_t ptr = 0,
    int32_t offset = 0,
    int32_t down_vel = 0,
    int32_t flag = 0,
    int32_t count = 0) {
  RopeControlDataBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_flag(flag);
  builder_.add_down_vel(down_vel);
  builder_.add_offset(offset);
  builder_.add_ptr(ptr);
  builder_.add_y(y);
  builder_.add_frame_rate(frame_rate);
  builder_.add_frame(frame);
  builder_.add_dframe(dframe);
  builder_.add_max_x_backward(max_x_backward);
  builder_.add_max_x_forward(max_x_forward);
  builder_.add_last_x(last_x);
  builder_.add_arc_back(arc_back);
  builder_.add_arc_front(arc_front);
  builder_.add_direction(direction);
  builder_.add_segment(segment);
  return builder_.Finish();
}

struct RopeControlData::Traits {
  using type = RopeControlData;
  static auto constexpr Create = CreateRopeControlData;
};

flatbuffers::Offset<RopeControlData> CreateRopeControlData(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TightropeControlDataT : public flatbuffers::NativeTable {
  typedef TightropeControlData TableType;
  float balance = 0.0f;
  uint32_t time_on_tightrope = 0;
  bool can_dismount = false;
  int32_t tightrope_item = 0;
};

struct TightropeControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TightropeControlDataT NativeTableType;
  typedef TightropeControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BALANCE = 4,
    VT_TIME_ON_TIGHTROPE = 6,
    VT_CAN_DISMOUNT = 8,
    VT_TIGHTROPE_ITEM = 10
  };
  float balance() const {
    return GetField<float>(VT_BALANCE, 0.0f);
  }
  uint32_t time_on_tightrope() const {
    return GetField<uint32_t>(VT_TIME_ON_TIGHTROPE, 0);
  }
  bool can_dismount() const {
    return GetField<uint8_t>(VT_CAN_DISMOUNT, 0) != 0;
  }
  int32_t tightrope_item() const {
    return GetField<int32_t>(VT_TIGHTROPE_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BALANCE) &&
           VerifyField<uint32_t>(verifier, VT_TIME_ON_TIGHTROPE) &&
           VerifyField<uint8_t>(verifier, VT_CAN_DISMOUNT) &&
           VerifyField<int32_t>(verifier, VT_TIGHTROPE_ITEM) &&
           verifier.EndTable();
  }
  TightropeControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TightropeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TightropeControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TightropeControlDataBuilder {
  typedef TightropeControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(float balance) {
    fbb_.AddElement<float>(TightropeControlData::VT_BALANCE, balance, 0.0f);
  }
  void add_time_on_tightrope(uint32_t time_on_tightrope) {
    fbb_.AddElement<uint32_t>(TightropeControlData::VT_TIME_ON_TIGHTROPE, time_on_tightrope, 0);
  }
  void add_can_dismount(bool can_dismount) {
    fbb_.AddElement<uint8_t>(TightropeControlData::VT_CAN_DISMOUNT, static_cast<uint8_t>(can_dismount), 0);
  }
  void add_tightrope_item(int32_t tightrope_item) {
    fbb_.AddElement<int32_t>(TightropeControlData::VT_TIGHTROPE_ITEM, tightrope_item, 0);
  }
  explicit TightropeControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TightropeControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TightropeControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float balance = 0.0f,
    uint32_t time_on_tightrope = 0,
    bool can_dismount = false,
    int32_t tightrope_item = 0) {
  TightropeControlDataBuilder builder_(_fbb);
  builder_.add_tightrope_item(tightrope_item);
  builder_.add_time_on_tightrope(time_on_tightrope);
  builder_.add_balance(balance);
  builder_.add_can_dismount(can_dismount);
  return builder_.Finish();
}

struct TightropeControlData::Traits {
  using type = TightropeControlData;
  static auto constexpr Create = CreateTightropeControlData;
};

flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubsuitControlDataT : public flatbuffers::NativeTable {
  typedef SubsuitControlData TableType;
  int32_t x_rot = 0;
  int32_t d_x_rot = 0;
  std::vector<int32_t> velocity{};
  int32_t vertical_velocity = 0;
  int32_t x_rot_vel = 0;
  uint32_t hit_count = 0;
};

struct SubsuitControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubsuitControlDataT NativeTableType;
  typedef SubsuitControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_ROT = 4,
    VT_D_X_ROT = 6,
    VT_VELOCITY = 8,
    VT_VERTICAL_VELOCITY = 10,
    VT_X_ROT_VEL = 12,
    VT_HIT_COUNT = 14
  };
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t d_x_rot() const {
    return GetField<int32_t>(VT_D_X_ROT, 0);
  }
  const flatbuffers::Vector<int32_t> *velocity() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VELOCITY);
  }
  int32_t vertical_velocity() const {
    return GetField<int32_t>(VT_VERTICAL_VELOCITY, 0);
  }
  int32_t x_rot_vel() const {
    return GetField<int32_t>(VT_X_ROT_VEL, 0);
  }
  uint32_t hit_count() const {
    return GetField<uint32_t>(VT_HIT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_D_X_ROT) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyVector(velocity()) &&
           VerifyField<int32_t>(verifier, VT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_X_ROT_VEL) &&
           VerifyField<uint32_t>(verifier, VT_HIT_COUNT) &&
           verifier.EndTable();
  }
  SubsuitControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubsuitControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubsuitControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubsuitControlDataBuilder {
  typedef SubsuitControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_X_ROT, x_rot, 0);
  }
  void add_d_x_rot(int32_t d_x_rot) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_D_X_ROT, d_x_rot, 0);
  }
  void add_velocity(flatbuffers::Offset<flatbuffers::Vector<int32_t>> velocity) {
    fbb_.AddOffset(SubsuitControlData::VT_VELOCITY, velocity);
  }
  void add_vertical_velocity(int32_t vertical_velocity) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_VERTICAL_VELOCITY, vertical_velocity, 0);
  }
  void add_x_rot_vel(int32_t x_rot_vel) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_X_ROT_VEL, x_rot_vel, 0);
  }
  void add_hit_count(uint32_t hit_count) {
    fbb_.AddElement<uint32_t>(SubsuitControlData::VT_HIT_COUNT, hit_count, 0);
  }
  explicit SubsuitControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubsuitControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubsuitControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_rot = 0,
    int32_t d_x_rot = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> velocity = 0,
    int32_t vertical_velocity = 0,
    int32_t x_rot_vel = 0,
    uint32_t hit_count = 0) {
  SubsuitControlDataBuilder builder_(_fbb);
  builder_.add_hit_count(hit_count);
  builder_.add_x_rot_vel(x_rot_vel);
  builder_.add_vertical_velocity(vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_d_x_rot(d_x_rot);
  builder_.add_x_rot(x_rot);
  return builder_.Finish();
}

struct SubsuitControlData::Traits {
  using type = SubsuitControlData;
  static auto constexpr Create = CreateSubsuitControlData;
};

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_rot = 0,
    int32_t d_x_rot = 0,
    const std::vector<int32_t> *velocity = nullptr,
    int32_t vertical_velocity = 0,
    int32_t x_rot_vel = 0,
    uint32_t hit_count = 0) {
  auto velocity__ = velocity ? _fbb.CreateVector<int32_t>(*velocity) : 0;
  return TEN::Save::CreateSubsuitControlData(
      _fbb,
      x_rot,
      d_x_rot,
      velocity__,
      vertical_velocity,
      x_rot_vel,
      hit_count);
}

flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraControlDataT : public flatbuffers::NativeTable {
  typedef LaraControlData TableType;
  int32_t move_angle = 0;
  int32_t turn_rate = 0;
  int32_t calculated_jump_velocity = 0;
  int32_t jump_direction = 0;
  int32_t hand_status = 0;
  int32_t water_status = 0;
  std::unique_ptr<TEN::Save::LaraCountDataT> count{};
  bool can_look = false;
  bool is_moving = false;
  bool keep_low = false;
  bool is_low = false;
  bool can_climb_ladder = false;
  bool is_climbing_ladder = false;
  bool can_monkey_swing = false;
  bool run_jump_queued = false;
  bool locked = false;
  std::unique_ptr<TEN::Save::WeaponControlDataT> weapon{};
  std::unique_ptr<TEN::Save::RopeControlDataT> rope{};
  std::unique_ptr<TEN::Save::TightropeControlDataT> tightrope{};
  std::unique_ptr<TEN::Save::SubsuitControlDataT> subsuit{};
};

struct LaraControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraControlDataT NativeTableType;
  typedef LaraControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOVE_ANGLE = 4,
    VT_TURN_RATE = 6,
    VT_CALCULATED_JUMP_VELOCITY = 8,
    VT_JUMP_DIRECTION = 10,
    VT_HAND_STATUS = 12,
    VT_WATER_STATUS = 14,
    VT_COUNT = 16,
    VT_CAN_LOOK = 18,
    VT_IS_MOVING = 20,
    VT_KEEP_LOW = 22,
    VT_IS_LOW = 24,
    VT_CAN_CLIMB_LADDER = 26,
    VT_IS_CLIMBING_LADDER = 28,
    VT_CAN_MONKEY_SWING = 30,
    VT_RUN_JUMP_QUEUED = 32,
    VT_LOCKED = 34,
    VT_WEAPON = 36,
    VT_ROPE = 38,
    VT_TIGHTROPE = 40,
    VT_SUBSUIT = 42
  };
  int32_t move_angle() const {
    return GetField<int32_t>(VT_MOVE_ANGLE, 0);
  }
  int32_t turn_rate() const {
    return GetField<int32_t>(VT_TURN_RATE, 0);
  }
  int32_t calculated_jump_velocity() const {
    return GetField<int32_t>(VT_CALCULATED_JUMP_VELOCITY, 0);
  }
  int32_t jump_direction() const {
    return GetField<int32_t>(VT_JUMP_DIRECTION, 0);
  }
  int32_t hand_status() const {
    return GetField<int32_t>(VT_HAND_STATUS, 0);
  }
  int32_t water_status() const {
    return GetField<int32_t>(VT_WATER_STATUS, 0);
  }
  const TEN::Save::LaraCountData *count() const {
    return GetPointer<const TEN::Save::LaraCountData *>(VT_COUNT);
  }
  bool can_look() const {
    return GetField<uint8_t>(VT_CAN_LOOK, 0) != 0;
  }
  bool is_moving() const {
    return GetField<uint8_t>(VT_IS_MOVING, 0) != 0;
  }
  bool keep_low() const {
    return GetField<uint8_t>(VT_KEEP_LOW, 0) != 0;
  }
  bool is_low() const {
    return GetField<uint8_t>(VT_IS_LOW, 0) != 0;
  }
  bool can_climb_ladder() const {
    return GetField<uint8_t>(VT_CAN_CLIMB_LADDER, 0) != 0;
  }
  bool is_climbing_ladder() const {
    return GetField<uint8_t>(VT_IS_CLIMBING_LADDER, 0) != 0;
  }
  bool can_monkey_swing() const {
    return GetField<uint8_t>(VT_CAN_MONKEY_SWING, 0) != 0;
  }
  bool run_jump_queued() const {
    return GetField<uint8_t>(VT_RUN_JUMP_QUEUED, 0) != 0;
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  const TEN::Save::WeaponControlData *weapon() const {
    return GetPointer<const TEN::Save::WeaponControlData *>(VT_WEAPON);
  }
  const TEN::Save::RopeControlData *rope() const {
    return GetPointer<const TEN::Save::RopeControlData *>(VT_ROPE);
  }
  const TEN::Save::TightropeControlData *tightrope() const {
    return GetPointer<const TEN::Save::TightropeControlData *>(VT_TIGHTROPE);
  }
  const TEN::Save::SubsuitControlData *subsuit() const {
    return GetPointer<const TEN::Save::SubsuitControlData *>(VT_SUBSUIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MOVE_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_TURN_RATE) &&
           VerifyField<int32_t>(verifier, VT_CALCULATED_JUMP_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_JUMP_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_HAND_STATUS) &&
           VerifyField<int32_t>(verifier, VT_WATER_STATUS) &&
           VerifyOffset(verifier, VT_COUNT) &&
           verifier.VerifyTable(count()) &&
           VerifyField<uint8_t>(verifier, VT_CAN_LOOK) &&
           VerifyField<uint8_t>(verifier, VT_IS_MOVING) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_LOW) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOW) &&
           VerifyField<uint8_t>(verifier, VT_CAN_CLIMB_LADDER) &&
           VerifyField<uint8_t>(verifier, VT_IS_CLIMBING_LADDER) &&
           VerifyField<uint8_t>(verifier, VT_CAN_MONKEY_SWING) &&
           VerifyField<uint8_t>(verifier, VT_RUN_JUMP_QUEUED) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           VerifyOffset(verifier, VT_WEAPON) &&
           verifier.VerifyTable(weapon()) &&
           VerifyOffset(verifier, VT_ROPE) &&
           verifier.VerifyTable(rope()) &&
           VerifyOffset(verifier, VT_TIGHTROPE) &&
           verifier.VerifyTable(tightrope()) &&
           VerifyOffset(verifier, VT_SUBSUIT) &&
           verifier.VerifyTable(subsuit()) &&
           verifier.EndTable();
  }
  LaraControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraControlDataBuilder {
  typedef LaraControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_move_angle(int32_t move_angle) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_MOVE_ANGLE, move_angle, 0);
  }
  void add_turn_rate(int32_t turn_rate) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_TURN_RATE, turn_rate, 0);
  }
  void add_calculated_jump_velocity(int32_t calculated_jump_velocity) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_CALCULATED_JUMP_VELOCITY, calculated_jump_velocity, 0);
  }
  void add_jump_direction(int32_t jump_direction) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_JUMP_DIRECTION, jump_direction, 0);
  }
  void add_hand_status(int32_t hand_status) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_HAND_STATUS, hand_status, 0);
  }
  void add_water_status(int32_t water_status) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_WATER_STATUS, water_status, 0);
  }
  void add_count(flatbuffers::Offset<TEN::Save::LaraCountData> count) {
    fbb_.AddOffset(LaraControlData::VT_COUNT, count);
  }
  void add_can_look(bool can_look) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_CAN_LOOK, static_cast<uint8_t>(can_look), 0);
  }
  void add_is_moving(bool is_moving) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_MOVING, static_cast<uint8_t>(is_moving), 0);
  }
  void add_keep_low(bool keep_low) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_KEEP_LOW, static_cast<uint8_t>(keep_low), 0);
  }
  void add_is_low(bool is_low) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_LOW, static_cast<uint8_t>(is_low), 0);
  }
  void add_can_climb_ladder(bool can_climb_ladder) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_CAN_CLIMB_LADDER, static_cast<uint8_t>(can_climb_ladder), 0);
  }
  void add_is_climbing_ladder(bool is_climbing_ladder) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_CLIMBING_LADDER, static_cast<uint8_t>(is_climbing_ladder), 0);
  }
  void add_can_monkey_swing(bool can_monkey_swing) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_CAN_MONKEY_SWING, static_cast<uint8_t>(can_monkey_swing), 0);
  }
  void add_run_jump_queued(bool run_jump_queued) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_RUN_JUMP_QUEUED, static_cast<uint8_t>(run_jump_queued), 0);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  void add_weapon(flatbuffers::Offset<TEN::Save::WeaponControlData> weapon) {
    fbb_.AddOffset(LaraControlData::VT_WEAPON, weapon);
  }
  void add_rope(flatbuffers::Offset<TEN::Save::RopeControlData> rope) {
    fbb_.AddOffset(LaraControlData::VT_ROPE, rope);
  }
  void add_tightrope(flatbuffers::Offset<TEN::Save::TightropeControlData> tightrope) {
    fbb_.AddOffset(LaraControlData::VT_TIGHTROPE, tightrope);
  }
  void add_subsuit(flatbuffers::Offset<TEN::Save::SubsuitControlData> subsuit) {
    fbb_.AddOffset(LaraControlData::VT_SUBSUIT, subsuit);
  }
  explicit LaraControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraControlData> CreateLaraControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t move_angle = 0,
    int32_t turn_rate = 0,
    int32_t calculated_jump_velocity = 0,
    int32_t jump_direction = 0,
    int32_t hand_status = 0,
    int32_t water_status = 0,
    flatbuffers::Offset<TEN::Save::LaraCountData> count = 0,
    bool can_look = false,
    bool is_moving = false,
    bool keep_low = false,
    bool is_low = false,
    bool can_climb_ladder = false,
    bool is_climbing_ladder = false,
    bool can_monkey_swing = false,
    bool run_jump_queued = false,
    bool locked = false,
    flatbuffers::Offset<TEN::Save::WeaponControlData> weapon = 0,
    flatbuffers::Offset<TEN::Save::RopeControlData> rope = 0,
    flatbuffers::Offset<TEN::Save::TightropeControlData> tightrope = 0,
    flatbuffers::Offset<TEN::Save::SubsuitControlData> subsuit = 0) {
  LaraControlDataBuilder builder_(_fbb);
  builder_.add_subsuit(subsuit);
  builder_.add_tightrope(tightrope);
  builder_.add_rope(rope);
  builder_.add_weapon(weapon);
  builder_.add_count(count);
  builder_.add_water_status(water_status);
  builder_.add_hand_status(hand_status);
  builder_.add_jump_direction(jump_direction);
  builder_.add_calculated_jump_velocity(calculated_jump_velocity);
  builder_.add_turn_rate(turn_rate);
  builder_.add_move_angle(move_angle);
  builder_.add_locked(locked);
  builder_.add_run_jump_queued(run_jump_queued);
  builder_.add_can_monkey_swing(can_monkey_swing);
  builder_.add_is_climbing_ladder(is_climbing_ladder);
  builder_.add_can_climb_ladder(can_climb_ladder);
  builder_.add_is_low(is_low);
  builder_.add_keep_low(keep_low);
  builder_.add_is_moving(is_moving);
  builder_.add_can_look(can_look);
  return builder_.Finish();
}

struct LaraControlData::Traits {
  using type = LaraControlData;
  static auto constexpr Create = CreateLaraControlData;
};

flatbuffers::Offset<LaraControlData> CreateLaraControlData(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraT : public flatbuffers::NativeTable {
  typedef Lara TableType;
  int32_t item_number = 0;
  std::unique_ptr<TEN::Save::LaraControlDataT> control{};
  std::unique_ptr<TEN::Save::LaraInventoryDataT> inventory{};
  std::vector<std::unique_ptr<TEN::Save::CarriedWeaponInfoT>> weapons{};
  std::unique_ptr<TEN::Save::FlareDataT> flare{};
  std::unique_ptr<TEN::Save::TorchDataT> torch{};
  std::unique_ptr<TEN::Save::Vector3> extra_head_rot{};
  std::unique_ptr<TEN::Save::Vector3> extra_torso_rot{};
  std::unique_ptr<TEN::Save::Vector3> extra_velocity{};
  int32_t water_current_active = 0;
  std::unique_ptr<TEN::Save::Vector3> water_current_pull{};
  std::unique_ptr<TEN::Save::ArmInfoT> left_arm{};
  std::unique_ptr<TEN::Save::ArmInfoT> right_arm{};
  std::vector<int32_t> target_arm_angles{};
  int32_t target_entity_number = 0;
  int32_t air = 0;
  int32_t sprint_energy = 0;
  int32_t poison_potency = 0;
  int32_t vehicle = 0;
  int32_t extra_anim = 0;
  int32_t hit_frame = 0;
  int32_t hit_direction = 0;
  int32_t projected_floor_height = 0;
  int32_t target_facing_angle = 0;
  int32_t water_surface_dist = 0;
  int32_t interacted_item = 0;
  std::unique_ptr<TEN::Save::Vector3> next_corner_position{};
  std::unique_ptr<TEN::Save::Vector3> next_corner_rotation{};
  int32_t burn_type = 0;
  uint32_t burn_count = 0;
  bool burn = false;
  int32_t burn_blue = 0;
  bool burn_smoke = false;
  std::vector<bool> wet{};
  std::vector<int32_t> mesh_ptrs{};
  int32_t location = 0;
  int32_t highest_location = 0;
  int32_t location_pad = 0;
};

struct Lara FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraT NativeTableType;
  typedef LaraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_NUMBER = 4,
    VT_CONTROL = 6,
    VT_INVENTORY = 8,
    VT_WEAPONS = 10,
    VT_FLARE = 12,
    VT_TORCH = 14,
    VT_EXTRA_HEAD_ROT = 16,
    VT_EXTRA_TORSO_ROT = 18,
    VT_EXTRA_VELOCITY = 20,
    VT_WATER_CURRENT_ACTIVE = 22,
    VT_WATER_CURRENT_PULL = 24,
    VT_LEFT_ARM = 26,
    VT_RIGHT_ARM = 28,
    VT_TARGET_ARM_ANGLES = 30,
    VT_TARGET_ENTITY_NUMBER = 32,
    VT_AIR = 34,
    VT_SPRINT_ENERGY = 36,
    VT_POISON_POTENCY = 38,
    VT_VEHICLE = 40,
    VT_EXTRA_ANIM = 42,
    VT_HIT_FRAME = 44,
    VT_HIT_DIRECTION = 46,
    VT_PROJECTED_FLOOR_HEIGHT = 48,
    VT_TARGET_FACING_ANGLE = 50,
    VT_WATER_SURFACE_DIST = 52,
    VT_INTERACTED_ITEM = 54,
    VT_NEXT_CORNER_POSITION = 56,
    VT_NEXT_CORNER_ROTATION = 58,
    VT_BURN_TYPE = 60,
    VT_BURN_COUNT = 62,
    VT_BURN = 64,
    VT_BURN_BLUE = 66,
    VT_BURN_SMOKE = 68,
    VT_WET = 70,
    VT_MESH_PTRS = 72,
    VT_LOCATION = 74,
    VT_HIGHEST_LOCATION = 76,
    VT_LOCATION_PAD = 78
  };
  int32_t item_number() const {
    return GetField<int32_t>(VT_ITEM_NUMBER, 0);
  }
  const TEN::Save::LaraControlData *control() const {
    return GetPointer<const TEN::Save::LaraControlData *>(VT_CONTROL);
  }
  const TEN::Save::LaraInventoryData *inventory() const {
    return GetPointer<const TEN::Save::LaraInventoryData *>(VT_INVENTORY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *>(VT_WEAPONS);
  }
  const TEN::Save::FlareData *flare() const {
    return GetPointer<const TEN::Save::FlareData *>(VT_FLARE);
  }
  const TEN::Save::TorchData *torch() const {
    return GetPointer<const TEN::Save::TorchData *>(VT_TORCH);
  }
  const TEN::Save::Vector3 *extra_head_rot() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EXTRA_HEAD_ROT);
  }
  const TEN::Save::Vector3 *extra_torso_rot() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EXTRA_TORSO_ROT);
  }
  const TEN::Save::Vector3 *extra_velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EXTRA_VELOCITY);
  }
  int32_t water_current_active() const {
    return GetField<int32_t>(VT_WATER_CURRENT_ACTIVE, 0);
  }
  const TEN::Save::Vector3 *water_current_pull() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_WATER_CURRENT_PULL);
  }
  const TEN::Save::ArmInfo *left_arm() const {
    return GetPointer<const TEN::Save::ArmInfo *>(VT_LEFT_ARM);
  }
  const TEN::Save::ArmInfo *right_arm() const {
    return GetPointer<const TEN::Save::ArmInfo *>(VT_RIGHT_ARM);
  }
  const flatbuffers::Vector<int32_t> *target_arm_angles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TARGET_ARM_ANGLES);
  }
  int32_t target_entity_number() const {
    return GetField<int32_t>(VT_TARGET_ENTITY_NUMBER, 0);
  }
  int32_t air() const {
    return GetField<int32_t>(VT_AIR, 0);
  }
  int32_t sprint_energy() const {
    return GetField<int32_t>(VT_SPRINT_ENERGY, 0);
  }
  int32_t poison_potency() const {
    return GetField<int32_t>(VT_POISON_POTENCY, 0);
  }
  int32_t vehicle() const {
    return GetField<int32_t>(VT_VEHICLE, 0);
  }
  int32_t extra_anim() const {
    return GetField<int32_t>(VT_EXTRA_ANIM, 0);
  }
  int32_t hit_frame() const {
    return GetField<int32_t>(VT_HIT_FRAME, 0);
  }
  int32_t hit_direction() const {
    return GetField<int32_t>(VT_HIT_DIRECTION, 0);
  }
  int32_t projected_floor_height() const {
    return GetField<int32_t>(VT_PROJECTED_FLOOR_HEIGHT, 0);
  }
  int32_t target_facing_angle() const {
    return GetField<int32_t>(VT_TARGET_FACING_ANGLE, 0);
  }
  int32_t water_surface_dist() const {
    return GetField<int32_t>(VT_WATER_SURFACE_DIST, 0);
  }
  int32_t interacted_item() const {
    return GetField<int32_t>(VT_INTERACTED_ITEM, 0);
  }
  const TEN::Save::Vector3 *next_corner_position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_NEXT_CORNER_POSITION);
  }
  const TEN::Save::Vector3 *next_corner_rotation() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_NEXT_CORNER_ROTATION);
  }
  int32_t burn_type() const {
    return GetField<int32_t>(VT_BURN_TYPE, 0);
  }
  uint32_t burn_count() const {
    return GetField<uint32_t>(VT_BURN_COUNT, 0);
  }
  bool burn() const {
    return GetField<uint8_t>(VT_BURN, 0) != 0;
  }
  int32_t burn_blue() const {
    return GetField<int32_t>(VT_BURN_BLUE, 0);
  }
  bool burn_smoke() const {
    return GetField<uint8_t>(VT_BURN_SMOKE, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *wet() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WET);
  }
  const flatbuffers::Vector<int32_t> *mesh_ptrs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MESH_PTRS);
  }
  int32_t location() const {
    return GetField<int32_t>(VT_LOCATION, 0);
  }
  int32_t highest_location() const {
    return GetField<int32_t>(VT_HIGHEST_LOCATION, 0);
  }
  int32_t location_pad() const {
    return GetField<int32_t>(VT_LOCATION_PAD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM_NUMBER) &&
           VerifyOffset(verifier, VT_CONTROL) &&
           verifier.VerifyTable(control()) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyTable(inventory()) &&
           VerifyOffset(verifier, VT_WEAPONS) &&
           verifier.VerifyVector(weapons()) &&
           verifier.VerifyVectorOfTables(weapons()) &&
           VerifyOffset(verifier, VT_FLARE) &&
           verifier.VerifyTable(flare()) &&
           VerifyOffset(verifier, VT_TORCH) &&
           verifier.VerifyTable(torch()) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EXTRA_HEAD_ROT) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EXTRA_TORSO_ROT) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EXTRA_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_WATER_CURRENT_ACTIVE) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_WATER_CURRENT_PULL) &&
           VerifyOffset(verifier, VT_LEFT_ARM) &&
           verifier.VerifyTable(left_arm()) &&
           VerifyOffset(verifier, VT_RIGHT_ARM) &&
           verifier.VerifyTable(right_arm()) &&
           VerifyOffset(verifier, VT_TARGET_ARM_ANGLES) &&
           verifier.VerifyVector(target_arm_angles()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_ENTITY_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_AIR) &&
           VerifyField<int32_t>(verifier, VT_SPRINT_ENERGY) &&
           VerifyField<int32_t>(verifier, VT_POISON_POTENCY) &&
           VerifyField<int32_t>(verifier, VT_VEHICLE) &&
           VerifyField<int32_t>(verifier, VT_EXTRA_ANIM) &&
           VerifyField<int32_t>(verifier, VT_HIT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_HIT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_PROJECTED_FLOOR_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_TARGET_FACING_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_WATER_SURFACE_DIST) &&
           VerifyField<int32_t>(verifier, VT_INTERACTED_ITEM) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_NEXT_CORNER_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_NEXT_CORNER_ROTATION) &&
           VerifyField<int32_t>(verifier, VT_BURN_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BURN_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_BURN) &&
           VerifyField<int32_t>(verifier, VT_BURN_BLUE) &&
           VerifyField<uint8_t>(verifier, VT_BURN_SMOKE) &&
           VerifyOffset(verifier, VT_WET) &&
           verifier.VerifyVector(wet()) &&
           VerifyOffset(verifier, VT_MESH_PTRS) &&
           verifier.VerifyVector(mesh_ptrs()) &&
           VerifyField<int32_t>(verifier, VT_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_HIGHEST_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_LOCATION_PAD) &&
           verifier.EndTable();
  }
  LaraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lara> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraBuilder {
  typedef Lara Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_number(int32_t item_number) {
    fbb_.AddElement<int32_t>(Lara::VT_ITEM_NUMBER, item_number, 0);
  }
  void add_control(flatbuffers::Offset<TEN::Save::LaraControlData> control) {
    fbb_.AddOffset(Lara::VT_CONTROL, control);
  }
  void add_inventory(flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory) {
    fbb_.AddOffset(Lara::VT_INVENTORY, inventory);
  }
  void add_weapons(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons) {
    fbb_.AddOffset(Lara::VT_WEAPONS, weapons);
  }
  void add_flare(flatbuffers::Offset<TEN::Save::FlareData> flare) {
    fbb_.AddOffset(Lara::VT_FLARE, flare);
  }
  void add_torch(flatbuffers::Offset<TEN::Save::TorchData> torch) {
    fbb_.AddOffset(Lara::VT_TORCH, torch);
  }
  void add_extra_head_rot(const TEN::Save::Vector3 *extra_head_rot) {
    fbb_.AddStruct(Lara::VT_EXTRA_HEAD_ROT, extra_head_rot);
  }
  void add_extra_torso_rot(const TEN::Save::Vector3 *extra_torso_rot) {
    fbb_.AddStruct(Lara::VT_EXTRA_TORSO_ROT, extra_torso_rot);
  }
  void add_extra_velocity(const TEN::Save::Vector3 *extra_velocity) {
    fbb_.AddStruct(Lara::VT_EXTRA_VELOCITY, extra_velocity);
  }
  void add_water_current_active(int32_t water_current_active) {
    fbb_.AddElement<int32_t>(Lara::VT_WATER_CURRENT_ACTIVE, water_current_active, 0);
  }
  void add_water_current_pull(const TEN::Save::Vector3 *water_current_pull) {
    fbb_.AddStruct(Lara::VT_WATER_CURRENT_PULL, water_current_pull);
  }
  void add_left_arm(flatbuffers::Offset<TEN::Save::ArmInfo> left_arm) {
    fbb_.AddOffset(Lara::VT_LEFT_ARM, left_arm);
  }
  void add_right_arm(flatbuffers::Offset<TEN::Save::ArmInfo> right_arm) {
    fbb_.AddOffset(Lara::VT_RIGHT_ARM, right_arm);
  }
  void add_target_arm_angles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_arm_angles) {
    fbb_.AddOffset(Lara::VT_TARGET_ARM_ANGLES, target_arm_angles);
  }
  void add_target_entity_number(int32_t target_entity_number) {
    fbb_.AddElement<int32_t>(Lara::VT_TARGET_ENTITY_NUMBER, target_entity_number, 0);
  }
  void add_air(int32_t air) {
    fbb_.AddElement<int32_t>(Lara::VT_AIR, air, 0);
  }
  void add_sprint_energy(int32_t sprint_energy) {
    fbb_.AddElement<int32_t>(Lara::VT_SPRINT_ENERGY, sprint_energy, 0);
  }
  void add_poison_potency(int32_t poison_potency) {
    fbb_.AddElement<int32_t>(Lara::VT_POISON_POTENCY, poison_potency, 0);
  }
  void add_vehicle(int32_t vehicle) {
    fbb_.AddElement<int32_t>(Lara::VT_VEHICLE, vehicle, 0);
  }
  void add_extra_anim(int32_t extra_anim) {
    fbb_.AddElement<int32_t>(Lara::VT_EXTRA_ANIM, extra_anim, 0);
  }
  void add_hit_frame(int32_t hit_frame) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_FRAME, hit_frame, 0);
  }
  void add_hit_direction(int32_t hit_direction) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_DIRECTION, hit_direction, 0);
  }
  void add_projected_floor_height(int32_t projected_floor_height) {
    fbb_.AddElement<int32_t>(Lara::VT_PROJECTED_FLOOR_HEIGHT, projected_floor_height, 0);
  }
  void add_target_facing_angle(int32_t target_facing_angle) {
    fbb_.AddElement<int32_t>(Lara::VT_TARGET_FACING_ANGLE, target_facing_angle, 0);
  }
  void add_water_surface_dist(int32_t water_surface_dist) {
    fbb_.AddElement<int32_t>(Lara::VT_WATER_SURFACE_DIST, water_surface_dist, 0);
  }
  void add_interacted_item(int32_t interacted_item) {
    fbb_.AddElement<int32_t>(Lara::VT_INTERACTED_ITEM, interacted_item, 0);
  }
  void add_next_corner_position(const TEN::Save::Vector3 *next_corner_position) {
    fbb_.AddStruct(Lara::VT_NEXT_CORNER_POSITION, next_corner_position);
  }
  void add_next_corner_rotation(const TEN::Save::Vector3 *next_corner_rotation) {
    fbb_.AddStruct(Lara::VT_NEXT_CORNER_ROTATION, next_corner_rotation);
  }
  void add_burn_type(int32_t burn_type) {
    fbb_.AddElement<int32_t>(Lara::VT_BURN_TYPE, burn_type, 0);
  }
  void add_burn_count(uint32_t burn_count) {
    fbb_.AddElement<uint32_t>(Lara::VT_BURN_COUNT, burn_count, 0);
  }
  void add_burn(bool burn) {
    fbb_.AddElement<uint8_t>(Lara::VT_BURN, static_cast<uint8_t>(burn), 0);
  }
  void add_burn_blue(int32_t burn_blue) {
    fbb_.AddElement<int32_t>(Lara::VT_BURN_BLUE, burn_blue, 0);
  }
  void add_burn_smoke(bool burn_smoke) {
    fbb_.AddElement<uint8_t>(Lara::VT_BURN_SMOKE, static_cast<uint8_t>(burn_smoke), 0);
  }
  void add_wet(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> wet) {
    fbb_.AddOffset(Lara::VT_WET, wet);
  }
  void add_mesh_ptrs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_ptrs) {
    fbb_.AddOffset(Lara::VT_MESH_PTRS, mesh_ptrs);
  }
  void add_location(int32_t location) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION, location, 0);
  }
  void add_highest_location(int32_t highest_location) {
    fbb_.AddElement<int32_t>(Lara::VT_HIGHEST_LOCATION, highest_location, 0);
  }
  void add_location_pad(int32_t location_pad) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION_PAD, location_pad, 0);
  }
  explicit LaraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lara> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lara>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lara> CreateLara(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_number = 0,
    flatbuffers::Offset<TEN::Save::LaraControlData> control = 0,
    flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons = 0,
    flatbuffers::Offset<TEN::Save::FlareData> flare = 0,
    flatbuffers::Offset<TEN::Save::TorchData> torch = 0,
    const TEN::Save::Vector3 *extra_head_rot = 0,
    const TEN::Save::Vector3 *extra_torso_rot = 0,
    const TEN::Save::Vector3 *extra_velocity = 0,
    int32_t water_current_active = 0,
    const TEN::Save::Vector3 *water_current_pull = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> left_arm = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> right_arm = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_arm_angles = 0,
    int32_t target_entity_number = 0,
    int32_t air = 0,
    int32_t sprint_energy = 0,
    int32_t poison_potency = 0,
    int32_t vehicle = 0,
    int32_t extra_anim = 0,
    int32_t hit_frame = 0,
    int32_t hit_direction = 0,
    int32_t projected_floor_height = 0,
    int32_t target_facing_angle = 0,
    int32_t water_surface_dist = 0,
    int32_t interacted_item = 0,
    const TEN::Save::Vector3 *next_corner_position = 0,
    const TEN::Save::Vector3 *next_corner_rotation = 0,
    int32_t burn_type = 0,
    uint32_t burn_count = 0,
    bool burn = false,
    int32_t burn_blue = 0,
    bool burn_smoke = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> wet = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_ptrs = 0,
    int32_t location = 0,
    int32_t highest_location = 0,
    int32_t location_pad = 0) {
  LaraBuilder builder_(_fbb);
  builder_.add_location_pad(location_pad);
  builder_.add_highest_location(highest_location);
  builder_.add_location(location);
  builder_.add_mesh_ptrs(mesh_ptrs);
  builder_.add_wet(wet);
  builder_.add_burn_blue(burn_blue);
  builder_.add_burn_count(burn_count);
  builder_.add_burn_type(burn_type);
  builder_.add_next_corner_rotation(next_corner_rotation);
  builder_.add_next_corner_position(next_corner_position);
  builder_.add_interacted_item(interacted_item);
  builder_.add_water_surface_dist(water_surface_dist);
  builder_.add_target_facing_angle(target_facing_angle);
  builder_.add_projected_floor_height(projected_floor_height);
  builder_.add_hit_direction(hit_direction);
  builder_.add_hit_frame(hit_frame);
  builder_.add_extra_anim(extra_anim);
  builder_.add_vehicle(vehicle);
  builder_.add_poison_potency(poison_potency);
  builder_.add_sprint_energy(sprint_energy);
  builder_.add_air(air);
  builder_.add_target_entity_number(target_entity_number);
  builder_.add_target_arm_angles(target_arm_angles);
  builder_.add_right_arm(right_arm);
  builder_.add_left_arm(left_arm);
  builder_.add_water_current_pull(water_current_pull);
  builder_.add_water_current_active(water_current_active);
  builder_.add_extra_velocity(extra_velocity);
  builder_.add_extra_torso_rot(extra_torso_rot);
  builder_.add_extra_head_rot(extra_head_rot);
  builder_.add_torch(torch);
  builder_.add_flare(flare);
  builder_.add_weapons(weapons);
  builder_.add_inventory(inventory);
  builder_.add_control(control);
  builder_.add_item_number(item_number);
  builder_.add_burn_smoke(burn_smoke);
  builder_.add_burn(burn);
  return builder_.Finish();
}

struct Lara::Traits {
  using type = Lara;
  static auto constexpr Create = CreateLara;
};

inline flatbuffers::Offset<Lara> CreateLaraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_number = 0,
    flatbuffers::Offset<TEN::Save::LaraControlData> control = 0,
    flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons = nullptr,
    flatbuffers::Offset<TEN::Save::FlareData> flare = 0,
    flatbuffers::Offset<TEN::Save::TorchData> torch = 0,
    const TEN::Save::Vector3 *extra_head_rot = 0,
    const TEN::Save::Vector3 *extra_torso_rot = 0,
    const TEN::Save::Vector3 *extra_velocity = 0,
    int32_t water_current_active = 0,
    const TEN::Save::Vector3 *water_current_pull = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> left_arm = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> right_arm = 0,
    const std::vector<int32_t> *target_arm_angles = nullptr,
    int32_t target_entity_number = 0,
    int32_t air = 0,
    int32_t sprint_energy = 0,
    int32_t poison_potency = 0,
    int32_t vehicle = 0,
    int32_t extra_anim = 0,
    int32_t hit_frame = 0,
    int32_t hit_direction = 0,
    int32_t projected_floor_height = 0,
    int32_t target_facing_angle = 0,
    int32_t water_surface_dist = 0,
    int32_t interacted_item = 0,
    const TEN::Save::Vector3 *next_corner_position = 0,
    const TEN::Save::Vector3 *next_corner_rotation = 0,
    int32_t burn_type = 0,
    uint32_t burn_count = 0,
    bool burn = false,
    int32_t burn_blue = 0,
    bool burn_smoke = false,
    const std::vector<uint8_t> *wet = nullptr,
    const std::vector<int32_t> *mesh_ptrs = nullptr,
    int32_t location = 0,
    int32_t highest_location = 0,
    int32_t location_pad = 0) {
  auto weapons__ = weapons ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>(*weapons) : 0;
  auto target_arm_angles__ = target_arm_angles ? _fbb.CreateVector<int32_t>(*target_arm_angles) : 0;
  auto wet__ = wet ? _fbb.CreateVector<uint8_t>(*wet) : 0;
  auto mesh_ptrs__ = mesh_ptrs ? _fbb.CreateVector<int32_t>(*mesh_ptrs) : 0;
  return TEN::Save::CreateLara(
      _fbb,
      item_number,
      control,
      inventory,
      weapons__,
      flare,
      torch,
      extra_head_rot,
      extra_torso_rot,
      extra_velocity,
      water_current_active,
      water_current_pull,
      left_arm,
      right_arm,
      target_arm_angles__,
      target_entity_number,
      air,
      sprint_energy,
      poison_potency,
      vehicle,
      extra_anim,
      hit_frame,
      hit_direction,
      projected_floor_height,
      target_facing_angle,
      water_surface_dist,
      interacted_item,
      next_corner_position,
      next_corner_rotation,
      burn_type,
      burn_count,
      burn,
      burn_blue,
      burn_smoke,
      wet__,
      mesh_ptrs__,
      location,
      highest_location,
      location_pad);
}

flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FixedCameraT : public flatbuffers::NativeTable {
  typedef FixedCamera TableType;
  int32_t flags = 0;
};

struct FixedCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixedCameraT NativeTableType;
  typedef FixedCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FixedCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FixedCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixedCameraBuilder {
  typedef FixedCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FixedCamera::VT_FLAGS, flags, 0);
  }
  explicit FixedCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FixedCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FixedCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FixedCamera::Traits {
  using type = FixedCamera;
  static auto constexpr Create = CreateFixedCamera;
};

flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlyByCameraT : public flatbuffers::NativeTable {
  typedef FlyByCamera TableType;
  int32_t flags = 0;
};

struct FlyByCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlyByCameraT NativeTableType;
  typedef FlyByCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FlyByCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlyByCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlyByCameraBuilder {
  typedef FlyByCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FlyByCamera::VT_FLAGS, flags, 0);
  }
  explicit FlyByCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlyByCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlyByCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FlyByCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FlyByCamera::Traits {
  using type = FlyByCamera;
  static auto constexpr Create = CreateFlyByCamera;
};

flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SinkT : public flatbuffers::NativeTable {
  typedef Sink TableType;
  int32_t flags = 0;
};

struct Sink FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinkT NativeTableType;
  typedef SinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sink> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SinkBuilder {
  typedef Sink Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Sink::VT_FLAGS, flags, 0);
  }
  explicit SinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sink>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sink> CreateSink(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  SinkBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct Sink::Traits {
  using type = Sink;
  static auto constexpr Create = CreateSink;
};

flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StaticMeshInfoT : public flatbuffers::NativeTable {
  typedef StaticMeshInfo TableType;
  int32_t number = 0;
  int32_t room_number = 0;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector3> rotation{};
  std::unique_ptr<TEN::Save::Vector4> color{};
  int32_t hit_points = 0;
  int32_t flags = 0;
};

struct StaticMeshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StaticMeshInfoT NativeTableType;
  typedef StaticMeshInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_ROOM_NUMBER = 6,
    VT_POSITION = 8,
    VT_ROTATION = 10,
    VT_COLOR = 12,
    VT_HIT_POINTS = 14,
    VT_FLAGS = 16
  };
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector3 *rotation() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_ROTATION);
  }
  const TEN::Save::Vector4 *color() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_COLOR);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_ROTATION) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  StaticMeshInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StaticMeshInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StaticMeshInfoBuilder {
  typedef StaticMeshInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_NUMBER, number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(StaticMeshInfo::VT_POSITION, position);
  }
  void add_rotation(const TEN::Save::Vector3 *rotation) {
    fbb_.AddStruct(StaticMeshInfo::VT_ROTATION, rotation);
  }
  void add_color(const TEN::Save::Vector4 *color) {
    fbb_.AddStruct(StaticMeshInfo::VT_COLOR, color);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_HIT_POINTS, hit_points, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_FLAGS, flags, 0);
  }
  explicit StaticMeshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StaticMeshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StaticMeshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t number = 0,
    int32_t room_number = 0,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector3 *rotation = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t hit_points = 0,
    int32_t flags = 0) {
  StaticMeshInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_hit_points(hit_points);
  builder_.add_color(color);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_room_number(room_number);
  builder_.add_number(number);
  return builder_.Finish();
}

struct StaticMeshInfo::Traits {
  using type = StaticMeshInfo;
  static auto constexpr Create = CreateStaticMeshInfo;
};

flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ParticleInfoT : public flatbuffers::NativeTable {
  typedef ParticleInfo TableType;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_vel = 0;
  int32_t y_vel = 0;
  int32_t z_vel = 0;
  int32_t gravity = 0;
  int32_t rot_ang = 0;
  int32_t flags = 0;
  float s_size = 0.0f;
  float d_size = 0.0f;
  float size = 0.0f;
  int32_t friction = 0;
  int32_t scalar = 0;
  int32_t sprite_index = 0;
  int32_t rot_add = 0;
  int32_t max_y_vel = 0;
  bool on = false;
  int32_t s_r = 0;
  int32_t s_g = 0;
  int32_t s_b = 0;
  int32_t d_r = 0;
  int32_t d_g = 0;
  int32_t d_b = 0;
  int32_t r = 0;
  int32_t g = 0;
  int32_t b = 0;
  int32_t col_fade_speed = 0;
  int32_t fade_to_black = 0;
  int32_t s_life = 0;
  int32_t life = 0;
  int32_t blend_mode = 0;
  int32_t extras = 0;
  int32_t dynamic = 0;
  int32_t fx_obj = 0;
  int32_t room_number = 0;
  int32_t node_number = 0;
};

struct ParticleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParticleInfoT NativeTableType;
  typedef ParticleInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_X_VEL = 10,
    VT_Y_VEL = 12,
    VT_Z_VEL = 14,
    VT_GRAVITY = 16,
    VT_ROT_ANG = 18,
    VT_FLAGS = 20,
    VT_S_SIZE = 22,
    VT_D_SIZE = 24,
    VT_SIZE = 26,
    VT_FRICTION = 28,
    VT_SCALAR = 30,
    VT_SPRITE_INDEX = 32,
    VT_ROT_ADD = 34,
    VT_MAX_Y_VEL = 36,
    VT_ON = 38,
    VT_S_R = 40,
    VT_S_G = 42,
    VT_S_B = 44,
    VT_D_R = 46,
    VT_D_G = 48,
    VT_D_B = 50,
    VT_R = 52,
    VT_G = 54,
    VT_B = 56,
    VT_COL_FADE_SPEED = 58,
    VT_FADE_TO_BLACK = 60,
    VT_S_LIFE = 62,
    VT_LIFE = 64,
    VT_BLEND_MODE = 66,
    VT_EXTRAS = 68,
    VT_DYNAMIC = 70,
    VT_FX_OBJ = 72,
    VT_ROOM_NUMBER = 74,
    VT_NODE_NUMBER = 76
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_vel() const {
    return GetField<int32_t>(VT_X_VEL, 0);
  }
  int32_t y_vel() const {
    return GetField<int32_t>(VT_Y_VEL, 0);
  }
  int32_t z_vel() const {
    return GetField<int32_t>(VT_Z_VEL, 0);
  }
  int32_t gravity() const {
    return GetField<int32_t>(VT_GRAVITY, 0);
  }
  int32_t rot_ang() const {
    return GetField<int32_t>(VT_ROT_ANG, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  float s_size() const {
    return GetField<float>(VT_S_SIZE, 0.0f);
  }
  float d_size() const {
    return GetField<float>(VT_D_SIZE, 0.0f);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  int32_t friction() const {
    return GetField<int32_t>(VT_FRICTION, 0);
  }
  int32_t scalar() const {
    return GetField<int32_t>(VT_SCALAR, 0);
  }
  int32_t sprite_index() const {
    return GetField<int32_t>(VT_SPRITE_INDEX, 0);
  }
  int32_t rot_add() const {
    return GetField<int32_t>(VT_ROT_ADD, 0);
  }
  int32_t max_y_vel() const {
    return GetField<int32_t>(VT_MAX_Y_VEL, 0);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t s_r() const {
    return GetField<int32_t>(VT_S_R, 0);
  }
  int32_t s_g() const {
    return GetField<int32_t>(VT_S_G, 0);
  }
  int32_t s_b() const {
    return GetField<int32_t>(VT_S_B, 0);
  }
  int32_t d_r() const {
    return GetField<int32_t>(VT_D_R, 0);
  }
  int32_t d_g() const {
    return GetField<int32_t>(VT_D_G, 0);
  }
  int32_t d_b() const {
    return GetField<int32_t>(VT_D_B, 0);
  }
  int32_t r() const {
    return GetField<int32_t>(VT_R, 0);
  }
  int32_t g() const {
    return GetField<int32_t>(VT_G, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  int32_t col_fade_speed() const {
    return GetField<int32_t>(VT_COL_FADE_SPEED, 0);
  }
  int32_t fade_to_black() const {
    return GetField<int32_t>(VT_FADE_TO_BLACK, 0);
  }
  int32_t s_life() const {
    return GetField<int32_t>(VT_S_LIFE, 0);
  }
  int32_t life() const {
    return GetField<int32_t>(VT_LIFE, 0);
  }
  int32_t blend_mode() const {
    return GetField<int32_t>(VT_BLEND_MODE, 0);
  }
  int32_t extras() const {
    return GetField<int32_t>(VT_EXTRAS, 0);
  }
  int32_t dynamic() const {
    return GetField<int32_t>(VT_DYNAMIC, 0);
  }
  int32_t fx_obj() const {
    return GetField<int32_t>(VT_FX_OBJ, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t node_number() const {
    return GetField<int32_t>(VT_NODE_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_VEL) &&
           VerifyField<int32_t>(verifier, VT_Y_VEL) &&
           VerifyField<int32_t>(verifier, VT_Z_VEL) &&
           VerifyField<int32_t>(verifier, VT_GRAVITY) &&
           VerifyField<int32_t>(verifier, VT_ROT_ANG) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<float>(verifier, VT_S_SIZE) &&
           VerifyField<float>(verifier, VT_D_SIZE) &&
           VerifyField<float>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FRICTION) &&
           VerifyField<int32_t>(verifier, VT_SCALAR) &&
           VerifyField<int32_t>(verifier, VT_SPRITE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ROT_ADD) &&
           VerifyField<int32_t>(verifier, VT_MAX_Y_VEL) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_S_R) &&
           VerifyField<int32_t>(verifier, VT_S_G) &&
           VerifyField<int32_t>(verifier, VT_S_B) &&
           VerifyField<int32_t>(verifier, VT_D_R) &&
           VerifyField<int32_t>(verifier, VT_D_G) &&
           VerifyField<int32_t>(verifier, VT_D_B) &&
           VerifyField<int32_t>(verifier, VT_R) &&
           VerifyField<int32_t>(verifier, VT_G) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           VerifyField<int32_t>(verifier, VT_COL_FADE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FADE_TO_BLACK) &&
           VerifyField<int32_t>(verifier, VT_S_LIFE) &&
           VerifyField<int32_t>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_BLEND_MODE) &&
           VerifyField<int32_t>(verifier, VT_EXTRAS) &&
           VerifyField<int32_t>(verifier, VT_DYNAMIC) &&
           VerifyField<int32_t>(verifier, VT_FX_OBJ) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_NODE_NUMBER) &&
           verifier.EndTable();
  }
  ParticleInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ParticleInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ParticleInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ParticleInfoBuilder {
  typedef ParticleInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Z, z, 0);
  }
  void add_x_vel(int32_t x_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_X_VEL, x_vel, 0);
  }
  void add_y_vel(int32_t y_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Y_VEL, y_vel, 0);
  }
  void add_z_vel(int32_t z_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Z_VEL, z_vel, 0);
  }
  void add_gravity(int32_t gravity) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_GRAVITY, gravity, 0);
  }
  void add_rot_ang(int32_t rot_ang) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROT_ANG, rot_ang, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FLAGS, flags, 0);
  }
  void add_s_size(float s_size) {
    fbb_.AddElement<float>(ParticleInfo::VT_S_SIZE, s_size, 0.0f);
  }
  void add_d_size(float d_size) {
    fbb_.AddElement<float>(ParticleInfo::VT_D_SIZE, d_size, 0.0f);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(ParticleInfo::VT_SIZE, size, 0.0f);
  }
  void add_friction(int32_t friction) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FRICTION, friction, 0);
  }
  void add_scalar(int32_t scalar) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SCALAR, scalar, 0);
  }
  void add_sprite_index(int32_t sprite_index) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SPRITE_INDEX, sprite_index, 0);
  }
  void add_rot_add(int32_t rot_add) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROT_ADD, rot_add, 0);
  }
  void add_max_y_vel(int32_t max_y_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_MAX_Y_VEL, max_y_vel, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(ParticleInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_s_r(int32_t s_r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_R, s_r, 0);
  }
  void add_s_g(int32_t s_g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_G, s_g, 0);
  }
  void add_s_b(int32_t s_b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_B, s_b, 0);
  }
  void add_d_r(int32_t d_r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_R, d_r, 0);
  }
  void add_d_g(int32_t d_g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_G, d_g, 0);
  }
  void add_d_b(int32_t d_b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_B, d_b, 0);
  }
  void add_r(int32_t r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_R, r, 0);
  }
  void add_g(int32_t g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_G, g, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_B, b, 0);
  }
  void add_col_fade_speed(int32_t col_fade_speed) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_COL_FADE_SPEED, col_fade_speed, 0);
  }
  void add_fade_to_black(int32_t fade_to_black) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FADE_TO_BLACK, fade_to_black, 0);
  }
  void add_s_life(int32_t s_life) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_LIFE, s_life, 0);
  }
  void add_life(int32_t life) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_LIFE, life, 0);
  }
  void add_blend_mode(int32_t blend_mode) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_BLEND_MODE, blend_mode, 0);
  }
  void add_extras(int32_t extras) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_EXTRAS, extras, 0);
  }
  void add_dynamic(int32_t dynamic) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_DYNAMIC, dynamic, 0);
  }
  void add_fx_obj(int32_t fx_obj) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FX_OBJ, fx_obj, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_node_number(int32_t node_number) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_NODE_NUMBER, node_number, 0);
  }
  explicit ParticleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParticleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParticleInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParticleInfo> CreateParticleInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_vel = 0,
    int32_t y_vel = 0,
    int32_t z_vel = 0,
    int32_t gravity = 0,
    int32_t rot_ang = 0,
    int32_t flags = 0,
    float s_size = 0.0f,
    float d_size = 0.0f,
    float size = 0.0f,
    int32_t friction = 0,
    int32_t scalar = 0,
    int32_t sprite_index = 0,
    int32_t rot_add = 0,
    int32_t max_y_vel = 0,
    bool on = false,
    int32_t s_r = 0,
    int32_t s_g = 0,
    int32_t s_b = 0,
    int32_t d_r = 0,
    int32_t d_g = 0,
    int32_t d_b = 0,
    int32_t r = 0,
    int32_t g = 0,
    int32_t b = 0,
    int32_t col_fade_speed = 0,
    int32_t fade_to_black = 0,
    int32_t s_life = 0,
    int32_t life = 0,
    int32_t blend_mode = 0,
    int32_t extras = 0,
    int32_t dynamic = 0,
    int32_t fx_obj = 0,
    int32_t room_number = 0,
    int32_t node_number = 0) {
  ParticleInfoBuilder builder_(_fbb);
  builder_.add_node_number(node_number);
  builder_.add_room_number(room_number);
  builder_.add_fx_obj(fx_obj);
  builder_.add_dynamic(dynamic);
  builder_.add_extras(extras);
  builder_.add_blend_mode(blend_mode);
  builder_.add_life(life);
  builder_.add_s_life(s_life);
  builder_.add_fade_to_black(fade_to_black);
  builder_.add_col_fade_speed(col_fade_speed);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  builder_.add_d_b(d_b);
  builder_.add_d_g(d_g);
  builder_.add_d_r(d_r);
  builder_.add_s_b(s_b);
  builder_.add_s_g(s_g);
  builder_.add_s_r(s_r);
  builder_.add_max_y_vel(max_y_vel);
  builder_.add_rot_add(rot_add);
  builder_.add_sprite_index(sprite_index);
  builder_.add_scalar(scalar);
  builder_.add_friction(friction);
  builder_.add_size(size);
  builder_.add_d_size(d_size);
  builder_.add_s_size(s_size);
  builder_.add_flags(flags);
  builder_.add_rot_ang(rot_ang);
  builder_.add_gravity(gravity);
  builder_.add_z_vel(z_vel);
  builder_.add_y_vel(y_vel);
  builder_.add_x_vel(x_vel);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct ParticleInfo::Traits {
  using type = ParticleInfo;
  static auto constexpr Create = CreateParticleInfo;
};

flatbuffers::Offset<ParticleInfo> CreateParticleInfo(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RatInfoT : public flatbuffers::NativeTable {
  typedef RatInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct RatInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RatInfoT NativeTableType;
  typedef RatInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  RatInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RatInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RatInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RatInfoBuilder {
  typedef RatInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(RatInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(RatInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(RatInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(RatInfo::VT_FLAGS, flags, 0);
  }
  explicit RatInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RatInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RatInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RatInfo> CreateRatInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  RatInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct RatInfo::Traits {
  using type = RatInfo;
  static auto constexpr Create = CreateRatInfo;
};

flatbuffers::Offset<RatInfo> CreateRatInfo(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpiderInfoT : public flatbuffers::NativeTable {
  typedef SpiderInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct SpiderInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpiderInfoT NativeTableType;
  typedef SpiderInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SpiderInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpiderInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpiderInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpiderInfoBuilder {
  typedef SpiderInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(SpiderInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_FLAGS, flags, 0);
  }
  explicit SpiderInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpiderInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpiderInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  SpiderInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct SpiderInfo::Traits {
  using type = SpiderInfo;
  static auto constexpr Create = CreateSpiderInfo;
};

flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScarabInfoT : public flatbuffers::NativeTable {
  typedef ScarabInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct ScarabInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScarabInfoT NativeTableType;
  typedef ScarabInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  ScarabInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScarabInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScarabInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScarabInfoBuilder {
  typedef ScarabInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(ScarabInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_FLAGS, flags, 0);
  }
  explicit ScarabInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScarabInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScarabInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScarabInfo> CreateScarabInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  ScarabInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct ScarabInfo::Traits {
  using type = ScarabInfo;
  static auto constexpr Create = CreateScarabInfo;
};

flatbuffers::Offset<ScarabInfo> CreateScarabInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatInfoT : public flatbuffers::NativeTable {
  typedef BatInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t counter = 0;
};

struct BatInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatInfoT NativeTableType;
  typedef BatInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_COUNTER = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t counter() const {
    return GetField<int32_t>(VT_COUNTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_COUNTER) &&
           verifier.EndTable();
  }
  BatInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatInfoBuilder {
  typedef BatInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(BatInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(BatInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(BatInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_counter(int32_t counter) {
    fbb_.AddElement<int32_t>(BatInfo::VT_COUNTER, counter, 0);
  }
  explicit BatInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatInfo> CreateBatInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t counter = 0) {
  BatInfoBuilder builder_(_fbb);
  builder_.add_counter(counter);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct BatInfo::Traits {
  using type = BatInfo;
  static auto constexpr Create = CreateBatInfo;
};

flatbuffers::Offset<BatInfo> CreateBatInfo(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeT : public flatbuffers::NativeTable {
  typedef Rope TableType;
  std::vector<TEN::Save::Vector3> segments{};
  std::vector<TEN::Save::Vector3> velocities{};
  std::vector<TEN::Save::Vector3> normalised_segments{};
  std::vector<TEN::Save::Vector3> mesh_segments{};
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::vector<TEN::Save::Vector3> coords{};
  int32_t segment_length = 0;
  int32_t active = 0;
  int32_t coiled = 0;
};

struct Rope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeT NativeTableType;
  typedef RopeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENTS = 4,
    VT_VELOCITIES = 6,
    VT_NORMALISED_SEGMENTS = 8,
    VT_MESH_SEGMENTS = 10,
    VT_POSITION = 12,
    VT_COORDS = 14,
    VT_SEGMENT_LENGTH = 16,
    VT_ACTIVE = 18,
    VT_COILED = 20
  };
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_SEGMENTS);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *velocities() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_VELOCITIES);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *normalised_segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_NORMALISED_SEGMENTS);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *mesh_segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_MESH_SEGMENTS);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *coords() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_COORDS);
  }
  int32_t segment_length() const {
    return GetField<int32_t>(VT_SEGMENT_LENGTH, 0);
  }
  int32_t active() const {
    return GetField<int32_t>(VT_ACTIVE, 0);
  }
  int32_t coiled() const {
    return GetField<int32_t>(VT_COILED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           VerifyOffset(verifier, VT_VELOCITIES) &&
           verifier.VerifyVector(velocities()) &&
           VerifyOffset(verifier, VT_NORMALISED_SEGMENTS) &&
           verifier.VerifyVector(normalised_segments()) &&
           VerifyOffset(verifier, VT_MESH_SEGMENTS) &&
           verifier.VerifyVector(mesh_segments()) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_COORDS) &&
           verifier.VerifyVector(coords()) &&
           VerifyField<int32_t>(verifier, VT_SEGMENT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_COILED) &&
           verifier.EndTable();
  }
  RopeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rope> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeBuilder {
  typedef Rope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> segments) {
    fbb_.AddOffset(Rope::VT_SEGMENTS, segments);
  }
  void add_velocities(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> velocities) {
    fbb_.AddOffset(Rope::VT_VELOCITIES, velocities);
  }
  void add_normalised_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> normalised_segments) {
    fbb_.AddOffset(Rope::VT_NORMALISED_SEGMENTS, normalised_segments);
  }
  void add_mesh_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> mesh_segments) {
    fbb_.AddOffset(Rope::VT_MESH_SEGMENTS, mesh_segments);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Rope::VT_POSITION, position);
  }
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> coords) {
    fbb_.AddOffset(Rope::VT_COORDS, coords);
  }
  void add_segment_length(int32_t segment_length) {
    fbb_.AddElement<int32_t>(Rope::VT_SEGMENT_LENGTH, segment_length, 0);
  }
  void add_active(int32_t active) {
    fbb_.AddElement<int32_t>(Rope::VT_ACTIVE, active, 0);
  }
  void add_coiled(int32_t coiled) {
    fbb_.AddElement<int32_t>(Rope::VT_COILED, coiled, 0);
  }
  explicit RopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rope>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rope> CreateRope(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> segments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> velocities = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> normalised_segments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> mesh_segments = 0,
    const TEN::Save::Vector3 *position = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> coords = 0,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  RopeBuilder builder_(_fbb);
  builder_.add_coiled(coiled);
  builder_.add_active(active);
  builder_.add_segment_length(segment_length);
  builder_.add_coords(coords);
  builder_.add_position(position);
  builder_.add_mesh_segments(mesh_segments);
  builder_.add_normalised_segments(normalised_segments);
  builder_.add_velocities(velocities);
  builder_.add_segments(segments);
  return builder_.Finish();
}

struct Rope::Traits {
  using type = Rope;
  static auto constexpr Create = CreateRope;
};

inline flatbuffers::Offset<Rope> CreateRopeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<TEN::Save::Vector3> *segments = nullptr,
    const std::vector<TEN::Save::Vector3> *velocities = nullptr,
    const std::vector<TEN::Save::Vector3> *normalised_segments = nullptr,
    const std::vector<TEN::Save::Vector3> *mesh_segments = nullptr,
    const TEN::Save::Vector3 *position = 0,
    const std::vector<TEN::Save::Vector3> *coords = nullptr,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  auto segments__ = segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*segments) : 0;
  auto velocities__ = velocities ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*velocities) : 0;
  auto normalised_segments__ = normalised_segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*normalised_segments) : 0;
  auto mesh_segments__ = mesh_segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*mesh_segments) : 0;
  auto coords__ = coords ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*coords) : 0;
  return TEN::Save::CreateRope(
      _fbb,
      segments__,
      velocities__,
      normalised_segments__,
      mesh_segments__,
      position,
      coords__,
      segment_length,
      active,
      coiled);
}

flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PendulumT : public flatbuffers::NativeTable {
  typedef Pendulum TableType;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector3> velocity{};
  int32_t node = 0;
};

struct Pendulum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PendulumT NativeTableType;
  typedef PendulumBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6,
    VT_NODE = 8
  };
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector3 *velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VELOCITY);
  }
  int32_t node() const {
    return GetField<int32_t>(VT_NODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_NODE) &&
           verifier.EndTable();
  }
  PendulumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pendulum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PendulumBuilder {
  typedef Pendulum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Pendulum::VT_POSITION, position);
  }
  void add_velocity(const TEN::Save::Vector3 *velocity) {
    fbb_.AddStruct(Pendulum::VT_VELOCITY, velocity);
  }
  void add_node(int32_t node) {
    fbb_.AddElement<int32_t>(Pendulum::VT_NODE, node, 0);
  }
  explicit PendulumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pendulum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pendulum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pendulum> CreatePendulum(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector3 *velocity = 0,
    int32_t node = 0) {
  PendulumBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Pendulum::Traits {
  using type = Pendulum;
  static auto constexpr Create = CreatePendulum;
};

flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventSetCallCountersT : public flatbuffers::NativeTable {
  typedef EventSetCallCounters TableType;
  int32_t on_enter = 0;
  int32_t on_inside = 0;
  int32_t on_leave = 0;
};

struct EventSetCallCounters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventSetCallCountersT NativeTableType;
  typedef EventSetCallCountersBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON_ENTER = 4,
    VT_ON_INSIDE = 6,
    VT_ON_LEAVE = 8
  };
  int32_t on_enter() const {
    return GetField<int32_t>(VT_ON_ENTER, 0);
  }
  int32_t on_inside() const {
    return GetField<int32_t>(VT_ON_INSIDE, 0);
  }
  int32_t on_leave() const {
    return GetField<int32_t>(VT_ON_LEAVE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ON_ENTER) &&
           VerifyField<int32_t>(verifier, VT_ON_INSIDE) &&
           VerifyField<int32_t>(verifier, VT_ON_LEAVE) &&
           verifier.EndTable();
  }
  EventSetCallCountersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventSetCallCountersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventSetCallCounters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSetCallCountersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventSetCallCountersBuilder {
  typedef EventSetCallCounters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on_enter(int32_t on_enter) {
    fbb_.AddElement<int32_t>(EventSetCallCounters::VT_ON_ENTER, on_enter, 0);
  }
  void add_on_inside(int32_t on_inside) {
    fbb_.AddElement<int32_t>(EventSetCallCounters::VT_ON_INSIDE, on_inside, 0);
  }
  void add_on_leave(int32_t on_leave) {
    fbb_.AddElement<int32_t>(EventSetCallCounters::VT_ON_LEAVE, on_leave, 0);
  }
  explicit EventSetCallCountersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EventSetCallCounters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventSetCallCounters>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventSetCallCounters> CreateEventSetCallCounters(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t on_enter = 0,
    int32_t on_inside = 0,
    int32_t on_leave = 0) {
  EventSetCallCountersBuilder builder_(_fbb);
  builder_.add_on_leave(on_leave);
  builder_.add_on_inside(on_inside);
  builder_.add_on_enter(on_enter);
  return builder_.Finish();
}

struct EventSetCallCounters::Traits {
  using type = EventSetCallCounters;
  static auto constexpr Create = CreateEventSetCallCounters;
};

flatbuffers::Offset<EventSetCallCounters> CreateEventSetCallCounters(flatbuffers::FlatBufferBuilder &_fbb, const EventSetCallCountersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolumeStateT : public flatbuffers::NativeTable {
  typedef VolumeState TableType;
  int32_t number = 0;
  int32_t room_number = 0;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector4> rotation{};
  std::unique_ptr<TEN::Save::Vector3> scale{};
  int32_t state = 0;
  int32_t triggerer = 0;
  int32_t timeout = 0;
};

struct VolumeState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VolumeStateT NativeTableType;
  typedef VolumeStateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_ROOM_NUMBER = 6,
    VT_POSITION = 8,
    VT_ROTATION = 10,
    VT_SCALE = 12,
    VT_STATE = 14,
    VT_TRIGGERER = 16,
    VT_TIMEOUT = 18
  };
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector4 *rotation() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_ROTATION);
  }
  const TEN::Save::Vector3 *scale() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_SCALE);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t triggerer() const {
    return GetField<int32_t>(VT_TRIGGERER, 0);
  }
  int32_t timeout() const {
    return GetField<int32_t>(VT_TIMEOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_ROTATION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_TRIGGERER) &&
           VerifyField<int32_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
  VolumeStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolumeStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VolumeState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VolumeStateBuilder {
  typedef VolumeState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(VolumeState::VT_NUMBER, number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(VolumeState::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(VolumeState::VT_POSITION, position);
  }
  void add_rotation(const TEN::Save::Vector4 *rotation) {
    fbb_.AddStruct(VolumeState::VT_ROTATION, rotation);
  }
  void add_scale(const TEN::Save::Vector3 *scale) {
    fbb_.AddStruct(VolumeState::VT_SCALE, scale);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(VolumeState::VT_STATE, state, 0);
  }
  void add_triggerer(int32_t triggerer) {
    fbb_.AddElement<int32_t>(VolumeState::VT_TRIGGERER, triggerer, 0);
  }
  void add_timeout(int32_t timeout) {
    fbb_.AddElement<int32_t>(VolumeState::VT_TIMEOUT, timeout, 0);
  }
  explicit VolumeStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VolumeState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VolumeState>(end);
    return o;
  }
};

inline flatbuffers::Offset<VolumeState> CreateVolumeState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t number = 0,
    int32_t room_number = 0,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector4 *rotation = 0,
    const TEN::Save::Vector3 *scale = 0,
    int32_t state = 0,
    int32_t triggerer = 0,
    int32_t timeout = 0) {
  VolumeStateBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  builder_.add_triggerer(triggerer);
  builder_.add_state(state);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_room_number(room_number);
  builder_.add_number(number);
  return builder_.Finish();
}

struct VolumeState::Traits {
  using type = VolumeState;
  static auto constexpr Create = CreateVolumeState;
};

flatbuffers::Offset<VolumeState> CreateVolumeState(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScriptTableT : public flatbuffers::NativeTable {
  typedef ScriptTable TableType;
  std::vector<TEN::Save::KeyValPair> keys_vals{};
};

struct ScriptTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScriptTableT NativeTableType;
  typedef ScriptTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS_VALS = 4
  };
  const flatbuffers::Vector<const TEN::Save::KeyValPair *> *keys_vals() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::KeyValPair *> *>(VT_KEYS_VALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS_VALS) &&
           verifier.VerifyVector(keys_vals()) &&
           verifier.EndTable();
  }
  ScriptTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScriptTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScriptTableBuilder {
  typedef ScriptTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys_vals(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals) {
    fbb_.AddOffset(ScriptTable::VT_KEYS_VALS, keys_vals);
  }
  explicit ScriptTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScriptTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScriptTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals = 0) {
  ScriptTableBuilder builder_(_fbb);
  builder_.add_keys_vals(keys_vals);
  return builder_.Finish();
}

struct ScriptTable::Traits {
  using type = ScriptTable;
  static auto constexpr Create = CreateScriptTable;
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<TEN::Save::KeyValPair> *keys_vals = nullptr) {
  auto keys_vals__ = keys_vals ? _fbb.CreateVectorOfStructs<TEN::Save::KeyValPair>(*keys_vals) : 0;
  return TEN::Save::CreateScriptTable(
      _fbb,
      keys_vals__);
}

flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct stringTableT : public flatbuffers::NativeTable {
  typedef stringTable TableType;
  std::string str{};
};

struct stringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef stringTableT NativeTableType;
  typedef stringTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4
  };
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
  stringTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<stringTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct stringTableBuilder {
  typedef stringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(stringTable::VT_STR, str);
  }
  explicit stringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<stringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<stringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<stringTable> CreatestringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  stringTableBuilder builder_(_fbb);
  builder_.add_str(str);
  return builder_.Finish();
}

struct stringTable::Traits {
  using type = stringTable;
  static auto constexpr Create = CreatestringTable;
};

inline flatbuffers::Offset<stringTable> CreatestringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return TEN::Save::CreatestringTable(
      _fbb,
      str__);
}

flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct doubleTableT : public flatbuffers::NativeTable {
  typedef doubleTable TableType;
  double scalar = 0.0;
};

struct doubleTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef doubleTableT NativeTableType;
  typedef doubleTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  double scalar() const {
    return GetField<double>(VT_SCALAR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  doubleTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<doubleTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct doubleTableBuilder {
  typedef doubleTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(double scalar) {
    fbb_.AddElement<double>(doubleTable::VT_SCALAR, scalar, 0.0);
  }
  explicit doubleTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<doubleTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<doubleTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scalar = 0.0) {
  doubleTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct doubleTable::Traits {
  using type = doubleTable;
  static auto constexpr Create = CreatedoubleTable;
};

flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct boolTableT : public flatbuffers::NativeTable {
  typedef boolTable TableType;
  bool scalar = false;
};

struct boolTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef boolTableT NativeTableType;
  typedef boolTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  bool scalar() const {
    return GetField<uint8_t>(VT_SCALAR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  boolTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(boolTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<boolTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct boolTableBuilder {
  typedef boolTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(bool scalar) {
    fbb_.AddElement<uint8_t>(boolTable::VT_SCALAR, static_cast<uint8_t>(scalar), 0);
  }
  explicit boolTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<boolTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<boolTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<boolTable> CreateboolTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool scalar = false) {
  boolTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct boolTable::Traits {
  using type = boolTable;
  static auto constexpr Create = CreateboolTable;
};

flatbuffers::Offset<boolTable> CreateboolTable(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionTableT : public flatbuffers::NativeTable {
  typedef UnionTable TableType;
  TEN::Save::VarUnionUnion u{};
};

struct UnionTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionTableT NativeTableType;
  typedef UnionTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U_TYPE = 4,
    VT_U = 6
  };
  TEN::Save::VarUnion u_type() const {
    return static_cast<TEN::Save::VarUnion>(GetField<uint8_t>(VT_U_TYPE, 0));
  }
  const void *u() const {
    return GetPointer<const void *>(VT_U);
  }
  template<typename T> const T *u_as() const;
  const TEN::Save::stringTable *u_as_str() const {
    return u_type() == TEN::Save::VarUnion::str ? static_cast<const TEN::Save::stringTable *>(u()) : nullptr;
  }
  const TEN::Save::ScriptTable *u_as_tab() const {
    return u_type() == TEN::Save::VarUnion::tab ? static_cast<const TEN::Save::ScriptTable *>(u()) : nullptr;
  }
  const TEN::Save::doubleTable *u_as_num() const {
    return u_type() == TEN::Save::VarUnion::num ? static_cast<const TEN::Save::doubleTable *>(u()) : nullptr;
  }
  const TEN::Save::boolTable *u_as_boolean() const {
    return u_type() == TEN::Save::VarUnion::boolean ? static_cast<const TEN::Save::boolTable *>(u()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_U_TYPE) &&
           VerifyOffset(verifier, VT_U) &&
           VerifyVarUnion(verifier, u(), u_type()) &&
           verifier.EndTable();
  }
  UnionTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::stringTable *UnionTable::u_as<TEN::Save::stringTable>() const {
  return u_as_str();
}

template<> inline const TEN::Save::ScriptTable *UnionTable::u_as<TEN::Save::ScriptTable>() const {
  return u_as_tab();
}

template<> inline const TEN::Save::doubleTable *UnionTable::u_as<TEN::Save::doubleTable>() const {
  return u_as_num();
}

template<> inline const TEN::Save::boolTable *UnionTable::u_as<TEN::Save::boolTable>() const {
  return u_as_boolean();
}

struct UnionTableBuilder {
  typedef UnionTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_u_type(TEN::Save::VarUnion u_type) {
    fbb_.AddElement<uint8_t>(UnionTable::VT_U_TYPE, static_cast<uint8_t>(u_type), 0);
  }
  void add_u(flatbuffers::Offset<void> u) {
    fbb_.AddOffset(UnionTable::VT_U, u);
  }
  explicit UnionTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionTable> CreateUnionTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    TEN::Save::VarUnion u_type = TEN::Save::VarUnion::NONE,
    flatbuffers::Offset<void> u = 0) {
  UnionTableBuilder builder_(_fbb);
  builder_.add_u(u);
  builder_.add_u_type(u_type);
  return builder_.Finish();
}

struct UnionTable::Traits {
  using type = UnionTable;
  static auto constexpr Create = CreateUnionTable;
};

flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionVecT : public flatbuffers::NativeTable {
  typedef UnionVec TableType;
  std::vector<std::unique_ptr<TEN::Save::UnionTableT>> members{};
};

struct UnionVec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionVecT NativeTableType;
  typedef UnionVecBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEMBERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
  UnionVecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionVec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnionVecBuilder {
  typedef UnionVec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members) {
    fbb_.AddOffset(UnionVec::VT_MEMBERS, members);
  }
  explicit UnionVecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionVec>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionVec> CreateUnionVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members = 0) {
  UnionVecBuilder builder_(_fbb);
  builder_.add_members(members);
  return builder_.Finish();
}

struct UnionVec::Traits {
  using type = UnionVec;
  static auto constexpr Create = CreateUnionVec;
};

inline flatbuffers::Offset<UnionVec> CreateUnionVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members = nullptr) {
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>>(*members) : 0;
  return TEN::Save::CreateUnionVec(
      _fbb,
      members__);
}

flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameHeaderT : public flatbuffers::NativeTable {
  typedef SaveGameHeader TableType;
  std::string level_name{};
  int32_t days = 0;
  int32_t hours = 0;
  int32_t minutes = 0;
  int32_t seconds = 0;
  int32_t level = 0;
  int32_t timer = 0;
  int32_t count = 0;
};

struct SaveGameHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameHeaderT NativeTableType;
  typedef SaveGameHeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL_NAME = 4,
    VT_DAYS = 6,
    VT_HOURS = 8,
    VT_MINUTES = 10,
    VT_SECONDS = 12,
    VT_LEVEL = 14,
    VT_TIMER = 16,
    VT_COUNT = 18
  };
  const flatbuffers::String *level_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEVEL_NAME);
  }
  int32_t days() const {
    return GetField<int32_t>(VT_DAYS, 0);
  }
  int32_t hours() const {
    return GetField<int32_t>(VT_HOURS, 0);
  }
  int32_t minutes() const {
    return GetField<int32_t>(VT_MINUTES, 0);
  }
  int32_t seconds() const {
    return GetField<int32_t>(VT_SECONDS, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEVEL_NAME) &&
           verifier.VerifyString(level_name()) &&
           VerifyField<int32_t>(verifier, VT_DAYS) &&
           VerifyField<int32_t>(verifier, VT_HOURS) &&
           VerifyField<int32_t>(verifier, VT_MINUTES) &&
           VerifyField<int32_t>(verifier, VT_SECONDS) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  SaveGameHeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameHeader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameHeaderBuilder {
  typedef SaveGameHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level_name(flatbuffers::Offset<flatbuffers::String> level_name) {
    fbb_.AddOffset(SaveGameHeader::VT_LEVEL_NAME, level_name);
  }
  void add_days(int32_t days) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_DAYS, days, 0);
  }
  void add_hours(int32_t hours) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_HOURS, hours, 0);
  }
  void add_minutes(int32_t minutes) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_MINUTES, minutes, 0);
  }
  void add_seconds(int32_t seconds) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_SECONDS, seconds, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_LEVEL, level, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_TIMER, timer, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_COUNT, count, 0);
  }
  explicit SaveGameHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> level_name = 0,
    int32_t days = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  SaveGameHeaderBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_timer(timer);
  builder_.add_level(level);
  builder_.add_seconds(seconds);
  builder_.add_minutes(minutes);
  builder_.add_hours(hours);
  builder_.add_days(days);
  builder_.add_level_name(level_name);
  return builder_.Finish();
}

struct SaveGameHeader::Traits {
  using type = SaveGameHeader;
  static auto constexpr Create = CreateSaveGameHeader;
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *level_name = nullptr,
    int32_t days = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  auto level_name__ = level_name ? _fbb.CreateString(level_name) : 0;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      level_name__,
      days,
      hours,
      minutes,
      seconds,
      level,
      timer,
      count);
}

flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameStatisticsT : public flatbuffers::NativeTable {
  typedef SaveGameStatistics TableType;
  int32_t ammo_hits = 0;
  int32_t ammo_used = 0;
  int32_t medipacks_used = 0;
  int32_t distance = 0;
  int32_t kills = 0;
  int32_t secrets = 0;
  int32_t timer = 0;
};

struct SaveGameStatistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameStatisticsT NativeTableType;
  typedef SaveGameStatisticsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMMO_HITS = 4,
    VT_AMMO_USED = 6,
    VT_MEDIPACKS_USED = 8,
    VT_DISTANCE = 10,
    VT_KILLS = 12,
    VT_SECRETS = 14,
    VT_TIMER = 16
  };
  int32_t ammo_hits() const {
    return GetField<int32_t>(VT_AMMO_HITS, 0);
  }
  int32_t ammo_used() const {
    return GetField<int32_t>(VT_AMMO_USED, 0);
  }
  int32_t medipacks_used() const {
    return GetField<int32_t>(VT_MEDIPACKS_USED, 0);
  }
  int32_t distance() const {
    return GetField<int32_t>(VT_DISTANCE, 0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t secrets() const {
    return GetField<int32_t>(VT_SECRETS, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AMMO_HITS) &&
           VerifyField<int32_t>(verifier, VT_AMMO_USED) &&
           VerifyField<int32_t>(verifier, VT_MEDIPACKS_USED) &&
           VerifyField<int32_t>(verifier, VT_DISTANCE) &&
           VerifyField<int32_t>(verifier, VT_KILLS) &&
           VerifyField<int32_t>(verifier, VT_SECRETS) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           verifier.EndTable();
  }
  SaveGameStatisticsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameStatistics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameStatisticsBuilder {
  typedef SaveGameStatistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ammo_hits(int32_t ammo_hits) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_HITS, ammo_hits, 0);
  }
  void add_ammo_used(int32_t ammo_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_USED, ammo_used, 0);
  }
  void add_medipacks_used(int32_t medipacks_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_MEDIPACKS_USED, medipacks_used, 0);
  }
  void add_distance(int32_t distance) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_DISTANCE, distance, 0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_KILLS, kills, 0);
  }
  void add_secrets(int32_t secrets) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_SECRETS, secrets, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_TIMER, timer, 0);
  }
  explicit SaveGameStatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameStatistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameStatistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ammo_hits = 0,
    int32_t ammo_used = 0,
    int32_t medipacks_used = 0,
    int32_t distance = 0,
    int32_t kills = 0,
    int32_t secrets = 0,
    int32_t timer = 0) {
  SaveGameStatisticsBuilder builder_(_fbb);
  builder_.add_timer(timer);
  builder_.add_secrets(secrets);
  builder_.add_kills(kills);
  builder_.add_distance(distance);
  builder_.add_medipacks_used(medipacks_used);
  builder_.add_ammo_used(ammo_used);
  builder_.add_ammo_hits(ammo_hits);
  return builder_.Finish();
}

struct SaveGameStatistics::Traits {
  using type = SaveGameStatistics;
  static auto constexpr Create = CreateSaveGameStatistics;
};

flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameT : public flatbuffers::NativeTable {
  typedef SaveGame TableType;
  std::unique_ptr<TEN::Save::SaveGameHeaderT> header{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> game{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> level{};
  std::unique_ptr<TEN::Save::LaraT> lara{};
  std::vector<std::unique_ptr<TEN::Save::ItemT>> items{};
  int32_t next_item_free = 0;
  int32_t next_item_active = 0;
  std::vector<int32_t> room_items{};
  std::vector<std::unique_ptr<TEN::Save::FXInfoT>> fxinfos{};
  int32_t next_fx_free = 0;
  int32_t next_fx_active = 0;
  std::vector<std::unique_ptr<TEN::Save::FixedCameraT>> fixed_cameras{};
  std::vector<std::unique_ptr<TEN::Save::SinkT>> sinks{};
  std::vector<std::unique_ptr<TEN::Save::StaticMeshInfoT>> static_meshes{};
  std::vector<std::unique_ptr<TEN::Save::FlyByCameraT>> flyby_cameras{};
  std::vector<std::unique_ptr<TEN::Save::ParticleInfoT>> particles{};
  std::vector<std::unique_ptr<TEN::Save::RatInfoT>> rats{};
  std::vector<std::unique_ptr<TEN::Save::SpiderInfoT>> spiders{};
  std::vector<std::unique_ptr<TEN::Save::ScarabInfoT>> scarabs{};
  std::vector<std::unique_ptr<TEN::Save::BatInfoT>> bats{};
  std::vector<int32_t> flip_maps{};
  std::vector<int32_t> flip_stats{};
  int32_t flip_effect = 0;
  int32_t flip_timer = 0;
  int32_t flip_status = 0;
  std::string ambient_track{};
  uint64_t ambient_position = 0;
  std::string oneshot_track{};
  uint64_t oneshot_position = 0;
  std::vector<int32_t> cd_flags{};
  std::unique_ptr<TEN::Save::RopeT> rope{};
  std::unique_ptr<TEN::Save::PendulumT> pendulum{};
  std::unique_ptr<TEN::Save::PendulumT> alternate_pendulum{};
  std::vector<std::unique_ptr<TEN::Save::VolumeStateT>> volume_states{};
  std::vector<std::unique_ptr<TEN::Save::EventSetCallCountersT>> call_counters{};
  std::unique_ptr<TEN::Save::UnionVecT> script_vars{};
};

struct SaveGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameT NativeTableType;
  typedef SaveGameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GAME = 6,
    VT_LEVEL = 8,
    VT_LARA = 10,
    VT_ITEMS = 12,
    VT_NEXT_ITEM_FREE = 14,
    VT_NEXT_ITEM_ACTIVE = 16,
    VT_ROOM_ITEMS = 18,
    VT_FXINFOS = 20,
    VT_NEXT_FX_FREE = 22,
    VT_NEXT_FX_ACTIVE = 24,
    VT_FIXED_CAMERAS = 26,
    VT_SINKS = 28,
    VT_STATIC_MESHES = 30,
    VT_FLYBY_CAMERAS = 32,
    VT_PARTICLES = 34,
    VT_RATS = 36,
    VT_SPIDERS = 38,
    VT_SCARABS = 40,
    VT_BATS = 42,
    VT_FLIP_MAPS = 44,
    VT_FLIP_STATS = 46,
    VT_FLIP_EFFECT = 48,
    VT_FLIP_TIMER = 50,
    VT_FLIP_STATUS = 52,
    VT_AMBIENT_TRACK = 54,
    VT_AMBIENT_POSITION = 56,
    VT_ONESHOT_TRACK = 58,
    VT_ONESHOT_POSITION = 60,
    VT_CD_FLAGS = 62,
    VT_ROPE = 64,
    VT_PENDULUM = 66,
    VT_ALTERNATE_PENDULUM = 68,
    VT_VOLUME_STATES = 70,
    VT_CALL_COUNTERS = 72,
    VT_SCRIPT_VARS = 74
  };
  const TEN::Save::SaveGameHeader *header() const {
    return GetPointer<const TEN::Save::SaveGameHeader *>(VT_HEADER);
  }
  const TEN::Save::SaveGameStatistics *game() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_GAME);
  }
  const TEN::Save::SaveGameStatistics *level() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_LEVEL);
  }
  const TEN::Save::Lara *lara() const {
    return GetPointer<const TEN::Save::Lara *>(VT_LARA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *>(VT_ITEMS);
  }
  int32_t next_item_free() const {
    return GetField<int32_t>(VT_NEXT_ITEM_FREE, 0);
  }
  int32_t next_item_active() const {
    return GetField<int32_t>(VT_NEXT_ITEM_ACTIVE, 0);
  }
  const flatbuffers::Vector<int32_t> *room_items() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ROOM_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>> *fxinfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>> *>(VT_FXINFOS);
  }
  int32_t next_fx_free() const {
    return GetField<int32_t>(VT_NEXT_FX_FREE, 0);
  }
  int32_t next_fx_active() const {
    return GetField<int32_t>(VT_NEXT_FX_ACTIVE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *>(VT_FIXED_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *>(VT_SINKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *>(VT_STATIC_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *>(VT_FLYBY_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *particles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *>(VT_PARTICLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>> *rats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>> *>(VT_RATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *spiders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *>(VT_SPIDERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *scarabs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *>(VT_SCARABS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>> *bats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>> *>(VT_BATS);
  }
  const flatbuffers::Vector<int32_t> *flip_maps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_MAPS);
  }
  const flatbuffers::Vector<int32_t> *flip_stats() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_STATS);
  }
  int32_t flip_effect() const {
    return GetField<int32_t>(VT_FLIP_EFFECT, 0);
  }
  int32_t flip_timer() const {
    return GetField<int32_t>(VT_FLIP_TIMER, 0);
  }
  int32_t flip_status() const {
    return GetField<int32_t>(VT_FLIP_STATUS, 0);
  }
  const flatbuffers::String *ambient_track() const {
    return GetPointer<const flatbuffers::String *>(VT_AMBIENT_TRACK);
  }
  uint64_t ambient_position() const {
    return GetField<uint64_t>(VT_AMBIENT_POSITION, 0);
  }
  const flatbuffers::String *oneshot_track() const {
    return GetPointer<const flatbuffers::String *>(VT_ONESHOT_TRACK);
  }
  uint64_t oneshot_position() const {
    return GetField<uint64_t>(VT_ONESHOT_POSITION, 0);
  }
  const flatbuffers::Vector<int32_t> *cd_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CD_FLAGS);
  }
  const TEN::Save::Rope *rope() const {
    return GetPointer<const TEN::Save::Rope *>(VT_ROPE);
  }
  const TEN::Save::Pendulum *pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_PENDULUM);
  }
  const TEN::Save::Pendulum *alternate_pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_ALTERNATE_PENDULUM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>> *volume_states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>> *>(VT_VOLUME_STATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>> *call_counters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>> *>(VT_CALL_COUNTERS);
  }
  const TEN::Save::UnionVec *script_vars() const {
    return GetPointer<const TEN::Save::UnionVec *>(VT_SCRIPT_VARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_GAME) &&
           verifier.VerifyTable(game()) &&
           VerifyOffset(verifier, VT_LEVEL) &&
           verifier.VerifyTable(level()) &&
           VerifyOffset(verifier, VT_LARA) &&
           verifier.VerifyTable(lara()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_FREE) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_ACTIVE) &&
           VerifyOffset(verifier, VT_ROOM_ITEMS) &&
           verifier.VerifyVector(room_items()) &&
           VerifyOffset(verifier, VT_FXINFOS) &&
           verifier.VerifyVector(fxinfos()) &&
           verifier.VerifyVectorOfTables(fxinfos()) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX_FREE) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX_ACTIVE) &&
           VerifyOffset(verifier, VT_FIXED_CAMERAS) &&
           verifier.VerifyVector(fixed_cameras()) &&
           verifier.VerifyVectorOfTables(fixed_cameras()) &&
           VerifyOffset(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_STATIC_MESHES) &&
           verifier.VerifyVector(static_meshes()) &&
           verifier.VerifyVectorOfTables(static_meshes()) &&
           VerifyOffset(verifier, VT_FLYBY_CAMERAS) &&
           verifier.VerifyVector(flyby_cameras()) &&
           verifier.VerifyVectorOfTables(flyby_cameras()) &&
           VerifyOffset(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffset(verifier, VT_RATS) &&
           verifier.VerifyVector(rats()) &&
           verifier.VerifyVectorOfTables(rats()) &&
           VerifyOffset(verifier, VT_SPIDERS) &&
           verifier.VerifyVector(spiders()) &&
           verifier.VerifyVectorOfTables(spiders()) &&
           VerifyOffset(verifier, VT_SCARABS) &&
           verifier.VerifyVector(scarabs()) &&
           verifier.VerifyVectorOfTables(scarabs()) &&
           VerifyOffset(verifier, VT_BATS) &&
           verifier.VerifyVector(bats()) &&
           verifier.VerifyVectorOfTables(bats()) &&
           VerifyOffset(verifier, VT_FLIP_MAPS) &&
           verifier.VerifyVector(flip_maps()) &&
           VerifyOffset(verifier, VT_FLIP_STATS) &&
           verifier.VerifyVector(flip_stats()) &&
           VerifyField<int32_t>(verifier, VT_FLIP_EFFECT) &&
           VerifyField<int32_t>(verifier, VT_FLIP_TIMER) &&
           VerifyField<int32_t>(verifier, VT_FLIP_STATUS) &&
           VerifyOffset(verifier, VT_AMBIENT_TRACK) &&
           verifier.VerifyString(ambient_track()) &&
           VerifyField<uint64_t>(verifier, VT_AMBIENT_POSITION) &&
           VerifyOffset(verifier, VT_ONESHOT_TRACK) &&
           verifier.VerifyString(oneshot_track()) &&
           VerifyField<uint64_t>(verifier, VT_ONESHOT_POSITION) &&
           VerifyOffset(verifier, VT_CD_FLAGS) &&
           verifier.VerifyVector(cd_flags()) &&
           VerifyOffset(verifier, VT_ROPE) &&
           verifier.VerifyTable(rope()) &&
           VerifyOffset(verifier, VT_PENDULUM) &&
           verifier.VerifyTable(pendulum()) &&
           VerifyOffset(verifier, VT_ALTERNATE_PENDULUM) &&
           verifier.VerifyTable(alternate_pendulum()) &&
           VerifyOffset(verifier, VT_VOLUME_STATES) &&
           verifier.VerifyVector(volume_states()) &&
           verifier.VerifyVectorOfTables(volume_states()) &&
           VerifyOffset(verifier, VT_CALL_COUNTERS) &&
           verifier.VerifyVector(call_counters()) &&
           verifier.VerifyVectorOfTables(call_counters()) &&
           VerifyOffset(verifier, VT_SCRIPT_VARS) &&
           verifier.VerifyTable(script_vars()) &&
           verifier.EndTable();
  }
  SaveGameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameBuilder {
  typedef SaveGame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<TEN::Save::SaveGameHeader> header) {
    fbb_.AddOffset(SaveGame::VT_HEADER, header);
  }
  void add_game(flatbuffers::Offset<TEN::Save::SaveGameStatistics> game) {
    fbb_.AddOffset(SaveGame::VT_GAME, game);
  }
  void add_level(flatbuffers::Offset<TEN::Save::SaveGameStatistics> level) {
    fbb_.AddOffset(SaveGame::VT_LEVEL, level);
  }
  void add_lara(flatbuffers::Offset<TEN::Save::Lara> lara) {
    fbb_.AddOffset(SaveGame::VT_LARA, lara);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items) {
    fbb_.AddOffset(SaveGame::VT_ITEMS, items);
  }
  void add_next_item_free(int32_t next_item_free) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_ITEM_FREE, next_item_free, 0);
  }
  void add_next_item_active(int32_t next_item_active) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_ITEM_ACTIVE, next_item_active, 0);
  }
  void add_room_items(flatbuffers::Offset<flatbuffers::Vector<int32_t>> room_items) {
    fbb_.AddOffset(SaveGame::VT_ROOM_ITEMS, room_items);
  }
  void add_fxinfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>>> fxinfos) {
    fbb_.AddOffset(SaveGame::VT_FXINFOS, fxinfos);
  }
  void add_next_fx_free(int32_t next_fx_free) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_FX_FREE, next_fx_free, 0);
  }
  void add_next_fx_active(int32_t next_fx_active) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_FX_ACTIVE, next_fx_active, 0);
  }
  void add_fixed_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras) {
    fbb_.AddOffset(SaveGame::VT_FIXED_CAMERAS, fixed_cameras);
  }
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks) {
    fbb_.AddOffset(SaveGame::VT_SINKS, sinks);
  }
  void add_static_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes) {
    fbb_.AddOffset(SaveGame::VT_STATIC_MESHES, static_meshes);
  }
  void add_flyby_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras) {
    fbb_.AddOffset(SaveGame::VT_FLYBY_CAMERAS, flyby_cameras);
  }
  void add_particles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>>> particles) {
    fbb_.AddOffset(SaveGame::VT_PARTICLES, particles);
  }
  void add_rats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>>> rats) {
    fbb_.AddOffset(SaveGame::VT_RATS, rats);
  }
  void add_spiders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>>> spiders) {
    fbb_.AddOffset(SaveGame::VT_SPIDERS, spiders);
  }
  void add_scarabs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>>> scarabs) {
    fbb_.AddOffset(SaveGame::VT_SCARABS, scarabs);
  }
  void add_bats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>>> bats) {
    fbb_.AddOffset(SaveGame::VT_BATS, bats);
  }
  void add_flip_maps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps) {
    fbb_.AddOffset(SaveGame::VT_FLIP_MAPS, flip_maps);
  }
  void add_flip_stats(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats) {
    fbb_.AddOffset(SaveGame::VT_FLIP_STATS, flip_stats);
  }
  void add_flip_effect(int32_t flip_effect) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_EFFECT, flip_effect, 0);
  }
  void add_flip_timer(int32_t flip_timer) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_TIMER, flip_timer, 0);
  }
  void add_flip_status(int32_t flip_status) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_STATUS, flip_status, 0);
  }
  void add_ambient_track(flatbuffers::Offset<flatbuffers::String> ambient_track) {
    fbb_.AddOffset(SaveGame::VT_AMBIENT_TRACK, ambient_track);
  }
  void add_ambient_position(uint64_t ambient_position) {
    fbb_.AddElement<uint64_t>(SaveGame::VT_AMBIENT_POSITION, ambient_position, 0);
  }
  void add_oneshot_track(flatbuffers::Offset<flatbuffers::String> oneshot_track) {
    fbb_.AddOffset(SaveGame::VT_ONESHOT_TRACK, oneshot_track);
  }
  void add_oneshot_position(uint64_t oneshot_position) {
    fbb_.AddElement<uint64_t>(SaveGame::VT_ONESHOT_POSITION, oneshot_position, 0);
  }
  void add_cd_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags) {
    fbb_.AddOffset(SaveGame::VT_CD_FLAGS, cd_flags);
  }
  void add_rope(flatbuffers::Offset<TEN::Save::Rope> rope) {
    fbb_.AddOffset(SaveGame::VT_ROPE, rope);
  }
  void add_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> pendulum) {
    fbb_.AddOffset(SaveGame::VT_PENDULUM, pendulum);
  }
  void add_alternate_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum) {
    fbb_.AddOffset(SaveGame::VT_ALTERNATE_PENDULUM, alternate_pendulum);
  }
  void add_volume_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>>> volume_states) {
    fbb_.AddOffset(SaveGame::VT_VOLUME_STATES, volume_states);
  }
  void add_call_counters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>>> call_counters) {
    fbb_.AddOffset(SaveGame::VT_CALL_COUNTERS, call_counters);
  }
  void add_script_vars(flatbuffers::Offset<TEN::Save::UnionVec> script_vars) {
    fbb_.AddOffset(SaveGame::VT_SCRIPT_VARS, script_vars);
  }
  explicit SaveGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGame> CreateSaveGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items = 0,
    int32_t next_item_free = 0,
    int32_t next_item_active = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> room_items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>>> fxinfos = 0,
    int32_t next_fx_free = 0,
    int32_t next_fx_active = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>>> particles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>>> rats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>>> spiders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>>> scarabs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>>> bats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats = 0,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    flatbuffers::Offset<flatbuffers::String> ambient_track = 0,
    uint64_t ambient_position = 0,
    flatbuffers::Offset<flatbuffers::String> oneshot_track = 0,
    uint64_t oneshot_position = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags = 0,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>>> volume_states = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>>> call_counters = 0,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0) {
  SaveGameBuilder builder_(_fbb);
  builder_.add_oneshot_position(oneshot_position);
  builder_.add_ambient_position(ambient_position);
  builder_.add_script_vars(script_vars);
  builder_.add_call_counters(call_counters);
  builder_.add_volume_states(volume_states);
  builder_.add_alternate_pendulum(alternate_pendulum);
  builder_.add_pendulum(pendulum);
  builder_.add_rope(rope);
  builder_.add_cd_flags(cd_flags);
  builder_.add_oneshot_track(oneshot_track);
  builder_.add_ambient_track(ambient_track);
  builder_.add_flip_status(flip_status);
  builder_.add_flip_timer(flip_timer);
  builder_.add_flip_effect(flip_effect);
  builder_.add_flip_stats(flip_stats);
  builder_.add_flip_maps(flip_maps);
  builder_.add_bats(bats);
  builder_.add_scarabs(scarabs);
  builder_.add_spiders(spiders);
  builder_.add_rats(rats);
  builder_.add_particles(particles);
  builder_.add_flyby_cameras(flyby_cameras);
  builder_.add_static_meshes(static_meshes);
  builder_.add_sinks(sinks);
  builder_.add_fixed_cameras(fixed_cameras);
  builder_.add_next_fx_active(next_fx_active);
  builder_.add_next_fx_free(next_fx_free);
  builder_.add_fxinfos(fxinfos);
  builder_.add_room_items(room_items);
  builder_.add_next_item_active(next_item_active);
  builder_.add_next_item_free(next_item_free);
  builder_.add_items(items);
  builder_.add_lara(lara);
  builder_.add_level(level);
  builder_.add_game(game);
  builder_.add_header(header);
  return builder_.Finish();
}

struct SaveGame::Traits {
  using type = SaveGame;
  static auto constexpr Create = CreateSaveGame;
};

inline flatbuffers::Offset<SaveGame> CreateSaveGameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::Item>> *items = nullptr,
    int32_t next_item_free = 0,
    int32_t next_item_active = 0,
    const std::vector<int32_t> *room_items = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FXInfo>> *fxinfos = nullptr,
    int32_t next_fx_free = 0,
    int32_t next_fx_active = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *particles = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::RatInfo>> *rats = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *spiders = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *scarabs = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::BatInfo>> *bats = nullptr,
    const std::vector<int32_t> *flip_maps = nullptr,
    const std::vector<int32_t> *flip_stats = nullptr,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    const char *ambient_track = nullptr,
    uint64_t ambient_position = 0,
    const char *oneshot_track = nullptr,
    uint64_t oneshot_position = 0,
    const std::vector<int32_t> *cd_flags = nullptr,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::VolumeState>> *volume_states = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>> *call_counters = nullptr,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>>(*items) : 0;
  auto room_items__ = room_items ? _fbb.CreateVector<int32_t>(*room_items) : 0;
  auto fxinfos__ = fxinfos ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FXInfo>>(*fxinfos) : 0;
  auto fixed_cameras__ = fixed_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>>(*fixed_cameras) : 0;
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>>(*sinks) : 0;
  auto static_meshes__ = static_meshes ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>(*static_meshes) : 0;
  auto flyby_cameras__ = flyby_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>>(*flyby_cameras) : 0;
  auto particles__ = particles ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ParticleInfo>>(*particles) : 0;
  auto rats__ = rats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RatInfo>>(*rats) : 0;
  auto spiders__ = spiders ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SpiderInfo>>(*spiders) : 0;
  auto scarabs__ = scarabs ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ScarabInfo>>(*scarabs) : 0;
  auto bats__ = bats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::BatInfo>>(*bats) : 0;
  auto flip_maps__ = flip_maps ? _fbb.CreateVector<int32_t>(*flip_maps) : 0;
  auto flip_stats__ = flip_stats ? _fbb.CreateVector<int32_t>(*flip_stats) : 0;
  auto ambient_track__ = ambient_track ? _fbb.CreateString(ambient_track) : 0;
  auto oneshot_track__ = oneshot_track ? _fbb.CreateString(oneshot_track) : 0;
  auto cd_flags__ = cd_flags ? _fbb.CreateVector<int32_t>(*cd_flags) : 0;
  auto volume_states__ = volume_states ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::VolumeState>>(*volume_states) : 0;
  auto call_counters__ = call_counters ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>>(*call_counters) : 0;
  return TEN::Save::CreateSaveGame(
      _fbb,
      header,
      game,
      level,
      lara,
      items__,
      next_item_free,
      next_item_active,
      room_items__,
      fxinfos__,
      next_fx_free,
      next_fx_active,
      fixed_cameras__,
      sinks__,
      static_meshes__,
      flyby_cameras__,
      particles__,
      rats__,
      spiders__,
      scarabs__,
      bats__,
      flip_maps__,
      flip_stats__,
      flip_effect,
      flip_timer,
      flip_status,
      ambient_track__,
      ambient_position,
      oneshot_track__,
      oneshot_position,
      cd_flags__,
      rope,
      pendulum,
      alternate_pendulum,
      volume_states__,
      call_counters__,
      script_vars);
}

flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ItemT *Item::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ItemT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = floor(); _o->floor = _e; }
  { auto _e = touch_bits(); _o->touch_bits = _e; }
  { auto _e = mesh_bits(); _o->mesh_bits = _e; }
  { auto _e = object_id(); _o->object_id = _e; }
  { auto _e = active_state(); _o->active_state = _e; }
  { auto _e = target_state(); _o->target_state = _e; }
  { auto _e = required_state(); _o->required_state = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = vertical_velocity(); _o->vertical_velocity = _e; }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = box_number(); _o->box_number = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = trigger_flags(); _o->trigger_flags = _e; }
  { auto _e = carried_item(); _o->carried_item = _e; }
  { auto _e = after_death(); _o->after_death = _e; }
  { auto _e = item_flags(); if (_e) { _o->item_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->item_flags[_i] = _e->Get(_i); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
  { auto _e = next_item(); _o->next_item = _e; }
  { auto _e = next_item_active(); _o->next_item_active = _e; }
  { auto _e = triggered(); _o->triggered = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = status(); _o->status = _e; }
  { auto _e = is_airborne(); _o->is_airborne = _e; }
  { auto _e = hit_stauts(); _o->hit_stauts = _e; }
  { auto _e = collidable(); _o->collidable = _e; }
  { auto _e = looked_at(); _o->looked_at = _e; }
  { auto _e = ai_bits(); _o->ai_bits = _e; }
  { auto _e = swap_mesh_flags(); _o->swap_mesh_flags = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = TEN::Save::ItemDataUnion::UnPack(_e, data_type(), _resolver); }
  { auto _e = lua_name(); if (_e) _o->lua_name = _e->str(); }
  { auto _e = lua_on_killed_name(); if (_e) _o->lua_on_killed_name = _e->str(); }
  { auto _e = lua_on_hit_name(); if (_e) _o->lua_on_hit_name = _e->str(); }
  { auto _e = lua_on_collided_with_object_name(); if (_e) _o->lua_on_collided_with_object_name = _e->str(); }
  { auto _e = lua_on_collided_with_room_name(); if (_e) _o->lua_on_collided_with_room_name = _e->str(); }
}

inline flatbuffers::Offset<Item> Item::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _floor = _o->floor;
  auto _touch_bits = _o->touch_bits;
  auto _mesh_bits = _o->mesh_bits;
  auto _object_id = _o->object_id;
  auto _active_state = _o->active_state;
  auto _target_state = _o->target_state;
  auto _required_state = _o->required_state;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _room_number = _o->room_number;
  auto _velocity = _o->velocity;
  auto _vertical_velocity = _o->vertical_velocity;
  auto _hit_points = _o->hit_points;
  auto _box_number = _o->box_number;
  auto _timer = _o->timer;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _flags = _o->flags;
  auto _trigger_flags = _o->trigger_flags;
  auto _carried_item = _o->carried_item;
  auto _after_death = _o->after_death;
  auto _item_flags = _fbb.CreateVector(_o->item_flags);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _next_item = _o->next_item;
  auto _next_item_active = _o->next_item_active;
  auto _triggered = _o->triggered;
  auto _active = _o->active;
  auto _status = _o->status;
  auto _is_airborne = _o->is_airborne;
  auto _hit_stauts = _o->hit_stauts;
  auto _collidable = _o->collidable;
  auto _looked_at = _o->looked_at;
  auto _ai_bits = _o->ai_bits;
  auto _swap_mesh_flags = _o->swap_mesh_flags;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  auto _lua_name = _o->lua_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_name);
  auto _lua_on_killed_name = _o->lua_on_killed_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_killed_name);
  auto _lua_on_hit_name = _o->lua_on_hit_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_hit_name);
  auto _lua_on_collided_with_object_name = _o->lua_on_collided_with_object_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_collided_with_object_name);
  auto _lua_on_collided_with_room_name = _o->lua_on_collided_with_room_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_collided_with_room_name);
  return TEN::Save::CreateItem(
      _fbb,
      _floor,
      _touch_bits,
      _mesh_bits,
      _object_id,
      _active_state,
      _target_state,
      _required_state,
      _anim_number,
      _frame_number,
      _room_number,
      _velocity,
      _vertical_velocity,
      _hit_points,
      _box_number,
      _timer,
      _color,
      _flags,
      _trigger_flags,
      _carried_item,
      _after_death,
      _item_flags,
      _position,
      _next_item,
      _next_item_active,
      _triggered,
      _active,
      _status,
      _is_airborne,
      _hit_stauts,
      _collidable,
      _looked_at,
      _ai_bits,
      _swap_mesh_flags,
      _data_type,
      _data,
      _lua_name,
      _lua_on_killed_name,
      _lua_on_hit_name,
      _lua_on_collided_with_object_name,
      _lua_on_collided_with_room_name);
}

inline FXInfoT *FXInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FXInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FXInfo::UnPackTo(FXInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = next_fx(); _o->next_fx = _e; }
  { auto _e = next_active(); _o->next_active = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = fall_speed(); _o->fall_speed = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = counter(); _o->counter = _e; }
  { auto _e = shade(); _o->shade = _e; }
  { auto _e = flag1(); _o->flag1 = _e; }
  { auto _e = flag2(); _o->flag2 = _e; }
}

inline flatbuffers::Offset<FXInfo> FXInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFXInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FXInfo> CreateFXInfo(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FXInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _room_number = _o->room_number;
  auto _object_number = _o->object_number;
  auto _next_fx = _o->next_fx;
  auto _next_active = _o->next_active;
  auto _speed = _o->speed;
  auto _fall_speed = _o->fall_speed;
  auto _frame_number = _o->frame_number;
  auto _counter = _o->counter;
  auto _shade = _o->shade;
  auto _flag1 = _o->flag1;
  auto _flag2 = _o->flag2;
  return TEN::Save::CreateFXInfo(
      _fbb,
      _pos,
      _room_number,
      _object_number,
      _next_fx,
      _next_active,
      _speed,
      _fall_speed,
      _frame_number,
      _counter,
      _shade,
      _flag1,
      _flag2);
}

inline AmmoInfoT *AmmoInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AmmoInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AmmoInfo::UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; }
  { auto _e = is_infinite(); _o->is_infinite = _e; }
}

inline flatbuffers::Offset<AmmoInfo> AmmoInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAmmoInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AmmoInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _is_infinite = _o->is_infinite;
  return TEN::Save::CreateAmmoInfo(
      _fbb,
      _count,
      _is_infinite);
}

inline HolsterInfoT *HolsterInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<HolsterInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HolsterInfo::UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = left_holster(); _o->left_holster = _e; }
  { auto _e = right_holster(); _o->right_holster = _e; }
  { auto _e = back_holster(); _o->back_holster = _e; }
}

inline flatbuffers::Offset<HolsterInfo> HolsterInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHolsterInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HolsterInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _left_holster = _o->left_holster;
  auto _right_holster = _o->right_holster;
  auto _back_holster = _o->back_holster;
  return TEN::Save::CreateHolsterInfo(
      _fbb,
      _left_holster,
      _right_holster,
      _back_holster);
}

inline CarriedWeaponInfoT *CarriedWeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CarriedWeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CarriedWeaponInfo::UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = present(); _o->present = _e; }
  { auto _e = ammo(); if (_e) { _o->ammo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ammo[_i] = std::unique_ptr<TEN::Save::AmmoInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = selected_ammo(); _o->selected_ammo = _e; }
  { auto _e = has_lasersight(); _o->has_lasersight = _e; }
  { auto _e = has_silencer(); _o->has_silencer = _e; }
}

inline flatbuffers::Offset<CarriedWeaponInfo> CarriedWeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCarriedWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CarriedWeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _present = _o->present;
  auto _ammo = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>> (_o->ammo.size(), [](size_t i, _VectorArgs *__va) { return CreateAmmoInfo(*__va->__fbb, __va->__o->ammo[i].get(), __va->__rehasher); }, &_va );
  auto _selected_ammo = _o->selected_ammo;
  auto _has_lasersight = _o->has_lasersight;
  auto _has_silencer = _o->has_silencer;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      _present,
      _ammo,
      _selected_ammo,
      _has_lasersight,
      _has_silencer);
}

inline WeaponInfoT *WeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponInfo::UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = active_state(); _o->active_state = _e; }
  { auto _e = target_state(); _o->target_state = _e; }
}

inline flatbuffers::Offset<WeaponInfo> WeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_number = _o->object_number;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _active_state = _o->active_state;
  auto _target_state = _o->target_state;
  return TEN::Save::CreateWeaponInfo(
      _fbb,
      _object_number,
      _anim_number,
      _frame_number,
      _active_state,
      _target_state);
}

inline ArmInfoT *ArmInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ArmInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArmInfo::UnPackTo(ArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = frame_base(); _o->frame_base = _e; }
  { auto _e = locked(); _o->locked = _e; }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = gun_flash(); _o->gun_flash = _e; }
  { auto _e = gun_smoke(); _o->gun_smoke = _e; }
}

inline flatbuffers::Offset<ArmInfo> ArmInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArmInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArmInfo> CreateArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArmInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _frame_base = _o->frame_base;
  auto _locked = _o->locked;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _gun_flash = _o->gun_flash;
  auto _gun_smoke = _o->gun_smoke;
  return TEN::Save::CreateArmInfo(
      _fbb,
      _anim_number,
      _frame_number,
      _frame_base,
      _locked,
      _rotation,
      _gun_flash,
      _gun_smoke);
}

inline FlareDataT *FlareData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FlareDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlareData::UnPackTo(FlareDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = life(); _o->life = _e; }
  { auto _e = frame(); _o->frame = _e; }
  { auto _e = control_left(); _o->control_left = _e; }
}

inline flatbuffers::Offset<FlareData> FlareData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlareData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlareData> CreateFlareData(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlareDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _life = _o->life;
  auto _frame = _o->frame;
  auto _control_left = _o->control_left;
  return TEN::Save::CreateFlareData(
      _fbb,
      _life,
      _frame,
      _control_left);
}

inline TorchDataT *TorchData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TorchDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TorchData::UnPackTo(TorchDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
  { auto _e = is_lit(); _o->is_lit = _e; }
}

inline flatbuffers::Offset<TorchData> TorchData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTorchData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TorchData> CreateTorchData(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TorchDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  auto _is_lit = _o->is_lit;
  return TEN::Save::CreateTorchData(
      _fbb,
      _state,
      _is_lit);
}

inline LaraInventoryDataT *LaraInventoryData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraInventoryDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraInventoryData::UnPackTo(LaraInventoryDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_busy(); _o->is_busy = _e; }
  { auto _e = old_busy(); _o->old_busy = _e; }
  { auto _e = beetle_life(); _o->beetle_life = _e; }
  { auto _e = beetle_components(); _o->beetle_components = _e; }
  { auto _e = small_waterskin(); _o->small_waterskin = _e; }
  { auto _e = big_waterskin(); _o->big_waterskin = _e; }
  { auto _e = has_binoculars(); _o->has_binoculars = _e; }
  { auto _e = has_crowbar(); _o->has_crowbar = _e; }
  { auto _e = has_torch(); _o->has_torch = _e; }
  { auto _e = has_lasersight(); _o->has_lasersight = _e; }
  { auto _e = has_silencer(); _o->has_silencer = _e; }
  { auto _e = total_small_medipacks(); _o->total_small_medipacks = _e; }
  { auto _e = total_large_medipacks(); _o->total_large_medipacks = _e; }
  { auto _e = total_flares(); _o->total_flares = _e; }
  { auto _e = total_secrets(); _o->total_secrets = _e; }
  { auto _e = puzzles(); if (_e) { _o->puzzles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles[_i] = _e->Get(_i); } } }
  { auto _e = keys(); if (_e) { _o->keys.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys[_i] = _e->Get(_i); } } }
  { auto _e = pickups(); if (_e) { _o->pickups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups[_i] = _e->Get(_i); } } }
  { auto _e = examines(); if (_e) { _o->examines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines[_i] = _e->Get(_i); } } }
  { auto _e = puzzles_combo(); if (_e) { _o->puzzles_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles_combo[_i] = _e->Get(_i); } } }
  { auto _e = keys_combo(); if (_e) { _o->keys_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_combo[_i] = _e->Get(_i); } } }
  { auto _e = pickups_combo(); if (_e) { _o->pickups_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups_combo[_i] = _e->Get(_i); } } }
  { auto _e = examines_combo(); if (_e) { _o->examines_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines_combo[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LaraInventoryData> LaraInventoryData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraInventoryData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraInventoryDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_busy = _o->is_busy;
  auto _old_busy = _o->old_busy;
  auto _beetle_life = _o->beetle_life;
  auto _beetle_components = _o->beetle_components;
  auto _small_waterskin = _o->small_waterskin;
  auto _big_waterskin = _o->big_waterskin;
  auto _has_binoculars = _o->has_binoculars;
  auto _has_crowbar = _o->has_crowbar;
  auto _has_torch = _o->has_torch;
  auto _has_lasersight = _o->has_lasersight;
  auto _has_silencer = _o->has_silencer;
  auto _total_small_medipacks = _o->total_small_medipacks;
  auto _total_large_medipacks = _o->total_large_medipacks;
  auto _total_flares = _o->total_flares;
  auto _total_secrets = _o->total_secrets;
  auto _puzzles = _fbb.CreateVector(_o->puzzles);
  auto _keys = _fbb.CreateVector(_o->keys);
  auto _pickups = _fbb.CreateVector(_o->pickups);
  auto _examines = _fbb.CreateVector(_o->examines);
  auto _puzzles_combo = _fbb.CreateVector(_o->puzzles_combo);
  auto _keys_combo = _fbb.CreateVector(_o->keys_combo);
  auto _pickups_combo = _fbb.CreateVector(_o->pickups_combo);
  auto _examines_combo = _fbb.CreateVector(_o->examines_combo);
  return TEN::Save::CreateLaraInventoryData(
      _fbb,
      _is_busy,
      _old_busy,
      _beetle_life,
      _beetle_components,
      _small_waterskin,
      _big_waterskin,
      _has_binoculars,
      _has_crowbar,
      _has_torch,
      _has_lasersight,
      _has_silencer,
      _total_small_medipacks,
      _total_large_medipacks,
      _total_flares,
      _total_secrets,
      _puzzles,
      _keys,
      _pickups,
      _examines,
      _puzzles_combo,
      _keys_combo,
      _pickups_combo,
      _examines_combo);
}

inline LaraCountDataT *LaraCountData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraCountDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraCountData::UnPackTo(LaraCountDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = run_jump(); _o->run_jump = _e; }
  { auto _e = position_adjust(); _o->position_adjust = _e; }
  { auto _e = pose(); _o->pose = _e; }
  { auto _e = death(); _o->death = _e; }
  { auto _e = no_cheat(); _o->no_cheat = _e; }
}

inline flatbuffers::Offset<LaraCountData> LaraCountData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraCountData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraCountData> CreateLaraCountData(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraCountDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _run_jump = _o->run_jump;
  auto _position_adjust = _o->position_adjust;
  auto _pose = _o->pose;
  auto _death = _o->death;
  auto _no_cheat = _o->no_cheat;
  return TEN::Save::CreateLaraCountData(
      _fbb,
      _run_jump,
      _position_adjust,
      _pose,
      _death,
      _no_cheat);
}

inline WeaponControlDataT *WeaponControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WeaponControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponControlData::UnPackTo(WeaponControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weapon_item(); _o->weapon_item = _e; }
  { auto _e = has_fired(); _o->has_fired = _e; }
  { auto _e = fired(); _o->fired = _e; }
  { auto _e = uzi_left(); _o->uzi_left = _e; }
  { auto _e = uzi_right(); _o->uzi_right = _e; }
  { auto _e = gun_type(); _o->gun_type = _e; }
  { auto _e = request_gun_type(); _o->request_gun_type = _e; }
  { auto _e = last_gun_type(); _o->last_gun_type = _e; }
  { auto _e = holster_info(); if (_e) _o->holster_info = std::unique_ptr<TEN::Save::HolsterInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<WeaponControlData> WeaponControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWeaponControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WeaponControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weapon_item = _o->weapon_item;
  auto _has_fired = _o->has_fired;
  auto _fired = _o->fired;
  auto _uzi_left = _o->uzi_left;
  auto _uzi_right = _o->uzi_right;
  auto _gun_type = _o->gun_type;
  auto _request_gun_type = _o->request_gun_type;
  auto _last_gun_type = _o->last_gun_type;
  auto _holster_info = _o->holster_info ? CreateHolsterInfo(_fbb, _o->holster_info.get(), _rehasher) : 0;
  return TEN::Save::CreateWeaponControlData(
      _fbb,
      _weapon_item,
      _has_fired,
      _fired,
      _uzi_left,
      _uzi_right,
      _gun_type,
      _request_gun_type,
      _last_gun_type,
      _holster_info);
}

inline RopeControlDataT *RopeControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RopeControlData::UnPackTo(RopeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segment(); _o->segment = _e; }
  { auto _e = direction(); _o->direction = _e; }
  { auto _e = arc_front(); _o->arc_front = _e; }
  { auto _e = arc_back(); _o->arc_back = _e; }
  { auto _e = last_x(); _o->last_x = _e; }
  { auto _e = max_x_forward(); _o->max_x_forward = _e; }
  { auto _e = max_x_backward(); _o->max_x_backward = _e; }
  { auto _e = dframe(); _o->dframe = _e; }
  { auto _e = frame(); _o->frame = _e; }
  { auto _e = frame_rate(); _o->frame_rate = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = ptr(); _o->ptr = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = down_vel(); _o->down_vel = _e; }
  { auto _e = flag(); _o->flag = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<RopeControlData> RopeControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRopeControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RopeControlData> CreateRopeControlData(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segment = _o->segment;
  auto _direction = _o->direction;
  auto _arc_front = _o->arc_front;
  auto _arc_back = _o->arc_back;
  auto _last_x = _o->last_x;
  auto _max_x_forward = _o->max_x_forward;
  auto _max_x_backward = _o->max_x_backward;
  auto _dframe = _o->dframe;
  auto _frame = _o->frame;
  auto _frame_rate = _o->frame_rate;
  auto _y = _o->y;
  auto _ptr = _o->ptr;
  auto _offset = _o->offset;
  auto _down_vel = _o->down_vel;
  auto _flag = _o->flag;
  auto _count = _o->count;
  return TEN::Save::CreateRopeControlData(
      _fbb,
      _segment,
      _direction,
      _arc_front,
      _arc_back,
      _last_x,
      _max_x_forward,
      _max_x_backward,
      _dframe,
      _frame,
      _frame_rate,
      _y,
      _ptr,
      _offset,
      _down_vel,
      _flag,
      _count);
}

inline TightropeControlDataT *TightropeControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TightropeControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TightropeControlData::UnPackTo(TightropeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = balance(); _o->balance = _e; }
  { auto _e = time_on_tightrope(); _o->time_on_tightrope = _e; }
  { auto _e = can_dismount(); _o->can_dismount = _e; }
  { auto _e = tightrope_item(); _o->tightrope_item = _e; }
}

inline flatbuffers::Offset<TightropeControlData> TightropeControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTightropeControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TightropeControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _balance = _o->balance;
  auto _time_on_tightrope = _o->time_on_tightrope;
  auto _can_dismount = _o->can_dismount;
  auto _tightrope_item = _o->tightrope_item;
  return TEN::Save::CreateTightropeControlData(
      _fbb,
      _balance,
      _time_on_tightrope,
      _can_dismount,
      _tightrope_item);
}

inline SubsuitControlDataT *SubsuitControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SubsuitControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubsuitControlData::UnPackTo(SubsuitControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = d_x_rot(); _o->d_x_rot = _e; }
  { auto _e = velocity(); if (_e) { _o->velocity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->velocity[_i] = _e->Get(_i); } } }
  { auto _e = vertical_velocity(); _o->vertical_velocity = _e; }
  { auto _e = x_rot_vel(); _o->x_rot_vel = _e; }
  { auto _e = hit_count(); _o->hit_count = _e; }
}

inline flatbuffers::Offset<SubsuitControlData> SubsuitControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubsuitControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubsuitControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x_rot = _o->x_rot;
  auto _d_x_rot = _o->d_x_rot;
  auto _velocity = _fbb.CreateVector(_o->velocity);
  auto _vertical_velocity = _o->vertical_velocity;
  auto _x_rot_vel = _o->x_rot_vel;
  auto _hit_count = _o->hit_count;
  return TEN::Save::CreateSubsuitControlData(
      _fbb,
      _x_rot,
      _d_x_rot,
      _velocity,
      _vertical_velocity,
      _x_rot_vel,
      _hit_count);
}

inline LaraControlDataT *LaraControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraControlData::UnPackTo(LaraControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = move_angle(); _o->move_angle = _e; }
  { auto _e = turn_rate(); _o->turn_rate = _e; }
  { auto _e = calculated_jump_velocity(); _o->calculated_jump_velocity = _e; }
  { auto _e = jump_direction(); _o->jump_direction = _e; }
  { auto _e = hand_status(); _o->hand_status = _e; }
  { auto _e = water_status(); _o->water_status = _e; }
  { auto _e = count(); if (_e) _o->count = std::unique_ptr<TEN::Save::LaraCountDataT>(_e->UnPack(_resolver)); }
  { auto _e = can_look(); _o->can_look = _e; }
  { auto _e = is_moving(); _o->is_moving = _e; }
  { auto _e = keep_low(); _o->keep_low = _e; }
  { auto _e = is_low(); _o->is_low = _e; }
  { auto _e = can_climb_ladder(); _o->can_climb_ladder = _e; }
  { auto _e = is_climbing_ladder(); _o->is_climbing_ladder = _e; }
  { auto _e = can_monkey_swing(); _o->can_monkey_swing = _e; }
  { auto _e = run_jump_queued(); _o->run_jump_queued = _e; }
  { auto _e = locked(); _o->locked = _e; }
  { auto _e = weapon(); if (_e) _o->weapon = std::unique_ptr<TEN::Save::WeaponControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = rope(); if (_e) _o->rope = std::unique_ptr<TEN::Save::RopeControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = tightrope(); if (_e) _o->tightrope = std::unique_ptr<TEN::Save::TightropeControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = subsuit(); if (_e) _o->subsuit = std::unique_ptr<TEN::Save::SubsuitControlDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<LaraControlData> LaraControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraControlData> CreateLaraControlData(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _move_angle = _o->move_angle;
  auto _turn_rate = _o->turn_rate;
  auto _calculated_jump_velocity = _o->calculated_jump_velocity;
  auto _jump_direction = _o->jump_direction;
  auto _hand_status = _o->hand_status;
  auto _water_status = _o->water_status;
  auto _count = _o->count ? CreateLaraCountData(_fbb, _o->count.get(), _rehasher) : 0;
  auto _can_look = _o->can_look;
  auto _is_moving = _o->is_moving;
  auto _keep_low = _o->keep_low;
  auto _is_low = _o->is_low;
  auto _can_climb_ladder = _o->can_climb_ladder;
  auto _is_climbing_ladder = _o->is_climbing_ladder;
  auto _can_monkey_swing = _o->can_monkey_swing;
  auto _run_jump_queued = _o->run_jump_queued;
  auto _locked = _o->locked;
  auto _weapon = _o->weapon ? CreateWeaponControlData(_fbb, _o->weapon.get(), _rehasher) : 0;
  auto _rope = _o->rope ? CreateRopeControlData(_fbb, _o->rope.get(), _rehasher) : 0;
  auto _tightrope = _o->tightrope ? CreateTightropeControlData(_fbb, _o->tightrope.get(), _rehasher) : 0;
  auto _subsuit = _o->subsuit ? CreateSubsuitControlData(_fbb, _o->subsuit.get(), _rehasher) : 0;
  return TEN::Save::CreateLaraControlData(
      _fbb,
      _move_angle,
      _turn_rate,
      _calculated_jump_velocity,
      _jump_direction,
      _hand_status,
      _water_status,
      _count,
      _can_look,
      _is_moving,
      _keep_low,
      _is_low,
      _can_climb_ladder,
      _is_climbing_ladder,
      _can_monkey_swing,
      _run_jump_queued,
      _locked,
      _weapon,
      _rope,
      _tightrope,
      _subsuit);
}

inline LaraT *Lara::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lara::UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item_number(); _o->item_number = _e; }
  { auto _e = control(); if (_e) _o->control = std::unique_ptr<TEN::Save::LaraControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = inventory(); if (_e) _o->inventory = std::unique_ptr<TEN::Save::LaraInventoryDataT>(_e->UnPack(_resolver)); }
  { auto _e = weapons(); if (_e) { _o->weapons.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weapons[_i] = std::unique_ptr<TEN::Save::CarriedWeaponInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flare(); if (_e) _o->flare = std::unique_ptr<TEN::Save::FlareDataT>(_e->UnPack(_resolver)); }
  { auto _e = torch(); if (_e) _o->torch = std::unique_ptr<TEN::Save::TorchDataT>(_e->UnPack(_resolver)); }
  { auto _e = extra_head_rot(); if (_e) _o->extra_head_rot = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = extra_torso_rot(); if (_e) _o->extra_torso_rot = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = extra_velocity(); if (_e) _o->extra_velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = water_current_active(); _o->water_current_active = _e; }
  { auto _e = water_current_pull(); if (_e) _o->water_current_pull = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = left_arm(); if (_e) _o->left_arm = std::unique_ptr<TEN::Save::ArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = right_arm(); if (_e) _o->right_arm = std::unique_ptr<TEN::Save::ArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = target_arm_angles(); if (_e) { _o->target_arm_angles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->target_arm_angles[_i] = _e->Get(_i); } } }
  { auto _e = target_entity_number(); _o->target_entity_number = _e; }
  { auto _e = air(); _o->air = _e; }
  { auto _e = sprint_energy(); _o->sprint_energy = _e; }
  { auto _e = poison_potency(); _o->poison_potency = _e; }
  { auto _e = vehicle(); _o->vehicle = _e; }
  { auto _e = extra_anim(); _o->extra_anim = _e; }
  { auto _e = hit_frame(); _o->hit_frame = _e; }
  { auto _e = hit_direction(); _o->hit_direction = _e; }
  { auto _e = projected_floor_height(); _o->projected_floor_height = _e; }
  { auto _e = target_facing_angle(); _o->target_facing_angle = _e; }
  { auto _e = water_surface_dist(); _o->water_surface_dist = _e; }
  { auto _e = interacted_item(); _o->interacted_item = _e; }
  { auto _e = next_corner_position(); if (_e) _o->next_corner_position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = next_corner_rotation(); if (_e) _o->next_corner_rotation = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = burn_type(); _o->burn_type = _e; }
  { auto _e = burn_count(); _o->burn_count = _e; }
  { auto _e = burn(); _o->burn = _e; }
  { auto _e = burn_blue(); _o->burn_blue = _e; }
  { auto _e = burn_smoke(); _o->burn_smoke = _e; }
  { auto _e = wet(); if (_e) { _o->wet.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->wet[_i] = _e->Get(_i) != 0; } } }
  { auto _e = mesh_ptrs(); if (_e) { _o->mesh_ptrs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mesh_ptrs[_i] = _e->Get(_i); } } }
  { auto _e = location(); _o->location = _e; }
  { auto _e = highest_location(); _o->highest_location = _e; }
  { auto _e = location_pad(); _o->location_pad = _e; }
}

inline flatbuffers::Offset<Lara> Lara::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLara(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item_number = _o->item_number;
  auto _control = _o->control ? CreateLaraControlData(_fbb, _o->control.get(), _rehasher) : 0;
  auto _inventory = _o->inventory ? CreateLaraInventoryData(_fbb, _o->inventory.get(), _rehasher) : 0;
  auto _weapons = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> (_o->weapons.size(), [](size_t i, _VectorArgs *__va) { return CreateCarriedWeaponInfo(*__va->__fbb, __va->__o->weapons[i].get(), __va->__rehasher); }, &_va );
  auto _flare = _o->flare ? CreateFlareData(_fbb, _o->flare.get(), _rehasher) : 0;
  auto _torch = _o->torch ? CreateTorchData(_fbb, _o->torch.get(), _rehasher) : 0;
  auto _extra_head_rot = _o->extra_head_rot ? _o->extra_head_rot.get() : 0;
  auto _extra_torso_rot = _o->extra_torso_rot ? _o->extra_torso_rot.get() : 0;
  auto _extra_velocity = _o->extra_velocity ? _o->extra_velocity.get() : 0;
  auto _water_current_active = _o->water_current_active;
  auto _water_current_pull = _o->water_current_pull ? _o->water_current_pull.get() : 0;
  auto _left_arm = _o->left_arm ? CreateArmInfo(_fbb, _o->left_arm.get(), _rehasher) : 0;
  auto _right_arm = _o->right_arm ? CreateArmInfo(_fbb, _o->right_arm.get(), _rehasher) : 0;
  auto _target_arm_angles = _fbb.CreateVector(_o->target_arm_angles);
  auto _target_entity_number = _o->target_entity_number;
  auto _air = _o->air;
  auto _sprint_energy = _o->sprint_energy;
  auto _poison_potency = _o->poison_potency;
  auto _vehicle = _o->vehicle;
  auto _extra_anim = _o->extra_anim;
  auto _hit_frame = _o->hit_frame;
  auto _hit_direction = _o->hit_direction;
  auto _projected_floor_height = _o->projected_floor_height;
  auto _target_facing_angle = _o->target_facing_angle;
  auto _water_surface_dist = _o->water_surface_dist;
  auto _interacted_item = _o->interacted_item;
  auto _next_corner_position = _o->next_corner_position ? _o->next_corner_position.get() : 0;
  auto _next_corner_rotation = _o->next_corner_rotation ? _o->next_corner_rotation.get() : 0;
  auto _burn_type = _o->burn_type;
  auto _burn_count = _o->burn_count;
  auto _burn = _o->burn;
  auto _burn_blue = _o->burn_blue;
  auto _burn_smoke = _o->burn_smoke;
  auto _wet = _fbb.CreateVector(_o->wet);
  auto _mesh_ptrs = _fbb.CreateVector(_o->mesh_ptrs);
  auto _location = _o->location;
  auto _highest_location = _o->highest_location;
  auto _location_pad = _o->location_pad;
  return TEN::Save::CreateLara(
      _fbb,
      _item_number,
      _control,
      _inventory,
      _weapons,
      _flare,
      _torch,
      _extra_head_rot,
      _extra_torso_rot,
      _extra_velocity,
      _water_current_active,
      _water_current_pull,
      _left_arm,
      _right_arm,
      _target_arm_angles,
      _target_entity_number,
      _air,
      _sprint_energy,
      _poison_potency,
      _vehicle,
      _extra_anim,
      _hit_frame,
      _hit_direction,
      _projected_floor_height,
      _target_facing_angle,
      _water_surface_dist,
      _interacted_item,
      _next_corner_position,
      _next_corner_rotation,
      _burn_type,
      _burn_count,
      _burn,
      _burn_blue,
      _burn_smoke,
      _wet,
      _mesh_ptrs,
      _location,
      _highest_location,
      _location_pad);
}

inline FixedCameraT *FixedCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FixedCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FixedCamera::UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FixedCamera> FixedCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixedCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FixedCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFixedCamera(
      _fbb,
      _flags);
}

inline FlyByCameraT *FlyByCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FlyByCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlyByCamera::UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FlyByCamera> FlyByCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlyByCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlyByCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFlyByCamera(
      _fbb,
      _flags);
}

inline SinkT *Sink::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SinkT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sink::UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<Sink> Sink::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateSink(
      _fbb,
      _flags);
}

inline StaticMeshInfoT *StaticMeshInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StaticMeshInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StaticMeshInfo::UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = number(); _o->number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<StaticMeshInfo> StaticMeshInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStaticMeshInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StaticMeshInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _number = _o->number;
  auto _room_number = _o->room_number;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _hit_points = _o->hit_points;
  auto _flags = _o->flags;
  return TEN::Save::CreateStaticMeshInfo(
      _fbb,
      _number,
      _room_number,
      _position,
      _rotation,
      _color,
      _hit_points,
      _flags);
}

inline ParticleInfoT *ParticleInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ParticleInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ParticleInfo::UnPackTo(ParticleInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_vel(); _o->x_vel = _e; }
  { auto _e = y_vel(); _o->y_vel = _e; }
  { auto _e = z_vel(); _o->z_vel = _e; }
  { auto _e = gravity(); _o->gravity = _e; }
  { auto _e = rot_ang(); _o->rot_ang = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = s_size(); _o->s_size = _e; }
  { auto _e = d_size(); _o->d_size = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = friction(); _o->friction = _e; }
  { auto _e = scalar(); _o->scalar = _e; }
  { auto _e = sprite_index(); _o->sprite_index = _e; }
  { auto _e = rot_add(); _o->rot_add = _e; }
  { auto _e = max_y_vel(); _o->max_y_vel = _e; }
  { auto _e = on(); _o->on = _e; }
  { auto _e = s_r(); _o->s_r = _e; }
  { auto _e = s_g(); _o->s_g = _e; }
  { auto _e = s_b(); _o->s_b = _e; }
  { auto _e = d_r(); _o->d_r = _e; }
  { auto _e = d_g(); _o->d_g = _e; }
  { auto _e = d_b(); _o->d_b = _e; }
  { auto _e = r(); _o->r = _e; }
  { auto _e = g(); _o->g = _e; }
  { auto _e = b(); _o->b = _e; }
  { auto _e = col_fade_speed(); _o->col_fade_speed = _e; }
  { auto _e = fade_to_black(); _o->fade_to_black = _e; }
  { auto _e = s_life(); _o->s_life = _e; }
  { auto _e = life(); _o->life = _e; }
  { auto _e = blend_mode(); _o->blend_mode = _e; }
  { auto _e = extras(); _o->extras = _e; }
  { auto _e = dynamic(); _o->dynamic = _e; }
  { auto _e = fx_obj(); _o->fx_obj = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = node_number(); _o->node_number = _e; }
}

inline flatbuffers::Offset<ParticleInfo> ParticleInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateParticleInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ParticleInfo> CreateParticleInfo(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ParticleInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_vel = _o->x_vel;
  auto _y_vel = _o->y_vel;
  auto _z_vel = _o->z_vel;
  auto _gravity = _o->gravity;
  auto _rot_ang = _o->rot_ang;
  auto _flags = _o->flags;
  auto _s_size = _o->s_size;
  auto _d_size = _o->d_size;
  auto _size = _o->size;
  auto _friction = _o->friction;
  auto _scalar = _o->scalar;
  auto _sprite_index = _o->sprite_index;
  auto _rot_add = _o->rot_add;
  auto _max_y_vel = _o->max_y_vel;
  auto _on = _o->on;
  auto _s_r = _o->s_r;
  auto _s_g = _o->s_g;
  auto _s_b = _o->s_b;
  auto _d_r = _o->d_r;
  auto _d_g = _o->d_g;
  auto _d_b = _o->d_b;
  auto _r = _o->r;
  auto _g = _o->g;
  auto _b = _o->b;
  auto _col_fade_speed = _o->col_fade_speed;
  auto _fade_to_black = _o->fade_to_black;
  auto _s_life = _o->s_life;
  auto _life = _o->life;
  auto _blend_mode = _o->blend_mode;
  auto _extras = _o->extras;
  auto _dynamic = _o->dynamic;
  auto _fx_obj = _o->fx_obj;
  auto _room_number = _o->room_number;
  auto _node_number = _o->node_number;
  return TEN::Save::CreateParticleInfo(
      _fbb,
      _x,
      _y,
      _z,
      _x_vel,
      _y_vel,
      _z_vel,
      _gravity,
      _rot_ang,
      _flags,
      _s_size,
      _d_size,
      _size,
      _friction,
      _scalar,
      _sprite_index,
      _rot_add,
      _max_y_vel,
      _on,
      _s_r,
      _s_g,
      _s_b,
      _d_r,
      _d_g,
      _d_b,
      _r,
      _g,
      _b,
      _col_fade_speed,
      _fade_to_black,
      _s_life,
      _life,
      _blend_mode,
      _extras,
      _dynamic,
      _fx_obj,
      _room_number,
      _node_number);
}

inline RatInfoT *RatInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RatInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RatInfo::UnPackTo(RatInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<RatInfo> RatInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRatInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RatInfo> CreateRatInfo(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RatInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateRatInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline SpiderInfoT *SpiderInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SpiderInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpiderInfo::UnPackTo(SpiderInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<SpiderInfo> SpiderInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpiderInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpiderInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateSpiderInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline ScarabInfoT *ScarabInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ScarabInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScarabInfo::UnPackTo(ScarabInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<ScarabInfo> ScarabInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScarabInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScarabInfo> CreateScarabInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScarabInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateScarabInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline BatInfoT *BatInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BatInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatInfo::UnPackTo(BatInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = counter(); _o->counter = _e; }
}

inline flatbuffers::Offset<BatInfo> BatInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatInfo> CreateBatInfo(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _counter = _o->counter;
  return TEN::Save::CreateBatInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _counter);
}

inline RopeT *Rope::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rope::UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segments(); if (_e) { _o->segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->segments[_i] = *_e->Get(_i); } } }
  { auto _e = velocities(); if (_e) { _o->velocities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->velocities[_i] = *_e->Get(_i); } } }
  { auto _e = normalised_segments(); if (_e) { _o->normalised_segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normalised_segments[_i] = *_e->Get(_i); } } }
  { auto _e = mesh_segments(); if (_e) { _o->mesh_segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mesh_segments[_i] = *_e->Get(_i); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = coords(); if (_e) { _o->coords.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coords[_i] = *_e->Get(_i); } } }
  { auto _e = segment_length(); _o->segment_length = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = coiled(); _o->coiled = _e; }
}

inline flatbuffers::Offset<Rope> Rope::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRope(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segments = _fbb.CreateVectorOfStructs(_o->segments);
  auto _velocities = _fbb.CreateVectorOfStructs(_o->velocities);
  auto _normalised_segments = _fbb.CreateVectorOfStructs(_o->normalised_segments);
  auto _mesh_segments = _fbb.CreateVectorOfStructs(_o->mesh_segments);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _coords = _fbb.CreateVectorOfStructs(_o->coords);
  auto _segment_length = _o->segment_length;
  auto _active = _o->active;
  auto _coiled = _o->coiled;
  return TEN::Save::CreateRope(
      _fbb,
      _segments,
      _velocities,
      _normalised_segments,
      _mesh_segments,
      _position,
      _coords,
      _segment_length,
      _active,
      _coiled);
}

inline PendulumT *Pendulum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PendulumT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pendulum::UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = node(); _o->node = _e; }
}

inline flatbuffers::Offset<Pendulum> Pendulum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePendulum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PendulumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  auto _node = _o->node;
  return TEN::Save::CreatePendulum(
      _fbb,
      _position,
      _velocity,
      _node);
}

inline EventSetCallCountersT *EventSetCallCounters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<EventSetCallCountersT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EventSetCallCounters::UnPackTo(EventSetCallCountersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on_enter(); _o->on_enter = _e; }
  { auto _e = on_inside(); _o->on_inside = _e; }
  { auto _e = on_leave(); _o->on_leave = _e; }
}

inline flatbuffers::Offset<EventSetCallCounters> EventSetCallCounters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSetCallCountersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventSetCallCounters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventSetCallCounters> CreateEventSetCallCounters(flatbuffers::FlatBufferBuilder &_fbb, const EventSetCallCountersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EventSetCallCountersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on_enter = _o->on_enter;
  auto _on_inside = _o->on_inside;
  auto _on_leave = _o->on_leave;
  return TEN::Save::CreateEventSetCallCounters(
      _fbb,
      _on_enter,
      _on_inside,
      _on_leave);
}

inline VolumeStateT *VolumeState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VolumeStateT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VolumeState::UnPackTo(VolumeStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = number(); _o->number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = state(); _o->state = _e; }
  { auto _e = triggerer(); _o->triggerer = _e; }
  { auto _e = timeout(); _o->timeout = _e; }
}

inline flatbuffers::Offset<VolumeState> VolumeState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolumeState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VolumeState> CreateVolumeState(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VolumeStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _number = _o->number;
  auto _room_number = _o->room_number;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _state = _o->state;
  auto _triggerer = _o->triggerer;
  auto _timeout = _o->timeout;
  return TEN::Save::CreateVolumeState(
      _fbb,
      _number,
      _room_number,
      _position,
      _rotation,
      _scale,
      _state,
      _triggerer,
      _timeout);
}

inline ScriptTableT *ScriptTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ScriptTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScriptTable::UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keys_vals(); if (_e) { _o->keys_vals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_vals[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<ScriptTable> ScriptTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScriptTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScriptTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keys_vals = _fbb.CreateVectorOfStructs(_o->keys_vals);
  return TEN::Save::CreateScriptTable(
      _fbb,
      _keys_vals);
}

inline stringTableT *stringTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<stringTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void stringTable::UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = str(); if (_e) _o->str = _e->str(); }
}

inline flatbuffers::Offset<stringTable> stringTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatestringTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const stringTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _str = _o->str.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->str);
  return TEN::Save::CreatestringTable(
      _fbb,
      _str);
}

inline doubleTableT *doubleTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<doubleTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void doubleTable::UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<doubleTable> doubleTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatedoubleTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const doubleTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreatedoubleTable(
      _fbb,
      _scalar);
}

inline boolTableT *boolTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<boolTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void boolTable::UnPackTo(boolTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<boolTable> boolTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateboolTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<boolTable> CreateboolTable(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const boolTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateboolTable(
      _fbb,
      _scalar);
}

inline UnionTableT *UnionTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionTable::UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = u_type(); _o->u.type = _e; }
  { auto _e = u(); if (_e) _o->u.value = TEN::Save::VarUnionUnion::UnPack(_e, u_type(), _resolver); }
}

inline flatbuffers::Offset<UnionTable> UnionTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _u_type = _o->u.type;
  auto _u = _o->u.Pack(_fbb);
  return TEN::Save::CreateUnionTable(
      _fbb,
      _u_type,
      _u);
}

inline UnionVecT *UnionVec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionVecT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionVec::UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = members(); if (_e) { _o->members.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->members[_i] = std::unique_ptr<TEN::Save::UnionTableT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UnionVec> UnionVec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionVecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _members = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>> (_o->members.size(), [](size_t i, _VectorArgs *__va) { return CreateUnionTable(*__va->__fbb, __va->__o->members[i].get(), __va->__rehasher); }, &_va );
  return TEN::Save::CreateUnionVec(
      _fbb,
      _members);
}

inline SaveGameHeaderT *SaveGameHeader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameHeaderT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameHeader::UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level_name(); if (_e) _o->level_name = _e->str(); }
  { auto _e = days(); _o->days = _e; }
  { auto _e = hours(); _o->hours = _e; }
  { auto _e = minutes(); _o->minutes = _e; }
  { auto _e = seconds(); _o->seconds = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<SaveGameHeader> SaveGameHeader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameHeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level_name = _o->level_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->level_name);
  auto _days = _o->days;
  auto _hours = _o->hours;
  auto _minutes = _o->minutes;
  auto _seconds = _o->seconds;
  auto _level = _o->level;
  auto _timer = _o->timer;
  auto _count = _o->count;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      _level_name,
      _days,
      _hours,
      _minutes,
      _seconds,
      _level,
      _timer,
      _count);
}

inline SaveGameStatisticsT *SaveGameStatistics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameStatisticsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameStatistics::UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ammo_hits(); _o->ammo_hits = _e; }
  { auto _e = ammo_used(); _o->ammo_used = _e; }
  { auto _e = medipacks_used(); _o->medipacks_used = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = secrets(); _o->secrets = _e; }
  { auto _e = timer(); _o->timer = _e; }
}

inline flatbuffers::Offset<SaveGameStatistics> SaveGameStatistics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameStatistics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameStatisticsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ammo_hits = _o->ammo_hits;
  auto _ammo_used = _o->ammo_used;
  auto _medipacks_used = _o->medipacks_used;
  auto _distance = _o->distance;
  auto _kills = _o->kills;
  auto _secrets = _o->secrets;
  auto _timer = _o->timer;
  return TEN::Save::CreateSaveGameStatistics(
      _fbb,
      _ammo_hits,
      _ammo_used,
      _medipacks_used,
      _distance,
      _kills,
      _secrets,
      _timer);
}

inline SaveGameT *SaveGame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGame::UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<TEN::Save::SaveGameHeaderT>(_e->UnPack(_resolver)); }
  { auto _e = game(); if (_e) _o->game = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = level(); if (_e) _o->level = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = lara(); if (_e) _o->lara = std::unique_ptr<TEN::Save::LaraT>(_e->UnPack(_resolver)); }
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<TEN::Save::ItemT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = next_item_free(); _o->next_item_free = _e; }
  { auto _e = next_item_active(); _o->next_item_active = _e; }
  { auto _e = room_items(); if (_e) { _o->room_items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->room_items[_i] = _e->Get(_i); } } }
  { auto _e = fxinfos(); if (_e) { _o->fxinfos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fxinfos[_i] = std::unique_ptr<TEN::Save::FXInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = next_fx_free(); _o->next_fx_free = _e; }
  { auto _e = next_fx_active(); _o->next_fx_active = _e; }
  { auto _e = fixed_cameras(); if (_e) { _o->fixed_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fixed_cameras[_i] = std::unique_ptr<TEN::Save::FixedCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = sinks(); if (_e) { _o->sinks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sinks[_i] = std::unique_ptr<TEN::Save::SinkT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = static_meshes(); if (_e) { _o->static_meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->static_meshes[_i] = std::unique_ptr<TEN::Save::StaticMeshInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flyby_cameras(); if (_e) { _o->flyby_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flyby_cameras[_i] = std::unique_ptr<TEN::Save::FlyByCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = particles(); if (_e) { _o->particles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->particles[_i] = std::unique_ptr<TEN::Save::ParticleInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = rats(); if (_e) { _o->rats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rats[_i] = std::unique_ptr<TEN::Save::RatInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = spiders(); if (_e) { _o->spiders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spiders[_i] = std::unique_ptr<TEN::Save::SpiderInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = scarabs(); if (_e) { _o->scarabs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scarabs[_i] = std::unique_ptr<TEN::Save::ScarabInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = bats(); if (_e) { _o->bats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bats[_i] = std::unique_ptr<TEN::Save::BatInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flip_maps(); if (_e) { _o->flip_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_maps[_i] = _e->Get(_i); } } }
  { auto _e = flip_stats(); if (_e) { _o->flip_stats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_stats[_i] = _e->Get(_i); } } }
  { auto _e = flip_effect(); _o->flip_effect = _e; }
  { auto _e = flip_timer(); _o->flip_timer = _e; }
  { auto _e = flip_status(); _o->flip_status = _e; }
  { auto _e = ambient_track(); if (_e) _o->ambient_track = _e->str(); }
  { auto _e = ambient_position(); _o->ambient_position = _e; }
  { auto _e = oneshot_track(); if (_e) _o->oneshot_track = _e->str(); }
  { auto _e = oneshot_position(); _o->oneshot_position = _e; }
  { auto _e = cd_flags(); if (_e) { _o->cd_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cd_flags[_i] = _e->Get(_i); } } }
  { auto _e = rope(); if (_e) _o->rope = std::unique_ptr<TEN::Save::RopeT>(_e->UnPack(_resolver)); }
  { auto _e = pendulum(); if (_e) _o->pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = alternate_pendulum(); if (_e) _o->alternate_pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = volume_states(); if (_e) { _o->volume_states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->volume_states[_i] = std::unique_ptr<TEN::Save::VolumeStateT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = call_counters(); if (_e) { _o->call_counters.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->call_counters[_i] = std::unique_ptr<TEN::Save::EventSetCallCountersT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = script_vars(); if (_e) _o->script_vars = std::unique_ptr<TEN::Save::UnionVecT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<SaveGame> SaveGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _header = _o->header ? CreateSaveGameHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _game = _o->game ? CreateSaveGameStatistics(_fbb, _o->game.get(), _rehasher) : 0;
  auto _level = _o->level ? CreateSaveGameStatistics(_fbb, _o->level.get(), _rehasher) : 0;
  auto _lara = _o->lara ? CreateLara(_fbb, _o->lara.get(), _rehasher) : 0;
  auto _items = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateItem(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va );
  auto _next_item_free = _o->next_item_free;
  auto _next_item_active = _o->next_item_active;
  auto _room_items = _fbb.CreateVector(_o->room_items);
  auto _fxinfos = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FXInfo>> (_o->fxinfos.size(), [](size_t i, _VectorArgs *__va) { return CreateFXInfo(*__va->__fbb, __va->__o->fxinfos[i].get(), __va->__rehasher); }, &_va );
  auto _next_fx_free = _o->next_fx_free;
  auto _next_fx_active = _o->next_fx_active;
  auto _fixed_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>> (_o->fixed_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFixedCamera(*__va->__fbb, __va->__o->fixed_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _sinks = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>> (_o->sinks.size(), [](size_t i, _VectorArgs *__va) { return CreateSink(*__va->__fbb, __va->__o->sinks[i].get(), __va->__rehasher); }, &_va );
  auto _static_meshes = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> (_o->static_meshes.size(), [](size_t i, _VectorArgs *__va) { return CreateStaticMeshInfo(*__va->__fbb, __va->__o->static_meshes[i].get(), __va->__rehasher); }, &_va );
  auto _flyby_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>> (_o->flyby_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFlyByCamera(*__va->__fbb, __va->__o->flyby_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _particles = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ParticleInfo>> (_o->particles.size(), [](size_t i, _VectorArgs *__va) { return CreateParticleInfo(*__va->__fbb, __va->__o->particles[i].get(), __va->__rehasher); }, &_va );
  auto _rats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RatInfo>> (_o->rats.size(), [](size_t i, _VectorArgs *__va) { return CreateRatInfo(*__va->__fbb, __va->__o->rats[i].get(), __va->__rehasher); }, &_va );
  auto _spiders = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SpiderInfo>> (_o->spiders.size(), [](size_t i, _VectorArgs *__va) { return CreateSpiderInfo(*__va->__fbb, __va->__o->spiders[i].get(), __va->__rehasher); }, &_va );
  auto _scarabs = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ScarabInfo>> (_o->scarabs.size(), [](size_t i, _VectorArgs *__va) { return CreateScarabInfo(*__va->__fbb, __va->__o->scarabs[i].get(), __va->__rehasher); }, &_va );
  auto _bats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::BatInfo>> (_o->bats.size(), [](size_t i, _VectorArgs *__va) { return CreateBatInfo(*__va->__fbb, __va->__o->bats[i].get(), __va->__rehasher); }, &_va );
  auto _flip_maps = _fbb.CreateVector(_o->flip_maps);
  auto _flip_stats = _fbb.CreateVector(_o->flip_stats);
  auto _flip_effect = _o->flip_effect;
  auto _flip_timer = _o->flip_timer;
  auto _flip_status = _o->flip_status;
  auto _ambient_track = _o->ambient_track.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->ambient_track);
  auto _ambient_position = _o->ambient_position;
  auto _oneshot_track = _o->oneshot_track.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->oneshot_track);
  auto _oneshot_position = _o->oneshot_position;
  auto _cd_flags = _fbb.CreateVector(_o->cd_flags);
  auto _rope = _o->rope ? CreateRope(_fbb, _o->rope.get(), _rehasher) : 0;
  auto _pendulum = _o->pendulum ? CreatePendulum(_fbb, _o->pendulum.get(), _rehasher) : 0;
  auto _alternate_pendulum = _o->alternate_pendulum ? CreatePendulum(_fbb, _o->alternate_pendulum.get(), _rehasher) : 0;
  auto _volume_states = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::VolumeState>> (_o->volume_states.size(), [](size_t i, _VectorArgs *__va) { return CreateVolumeState(*__va->__fbb, __va->__o->volume_states[i].get(), __va->__rehasher); }, &_va );
  auto _call_counters = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSetCallCounters>> (_o->call_counters.size(), [](size_t i, _VectorArgs *__va) { return CreateEventSetCallCounters(*__va->__fbb, __va->__o->call_counters[i].get(), __va->__rehasher); }, &_va );
  auto _script_vars = _o->script_vars ? CreateUnionVec(_fbb, _o->script_vars.get(), _rehasher) : 0;
  return TEN::Save::CreateSaveGame(
      _fbb,
      _header,
      _game,
      _level,
      _lara,
      _items,
      _next_item_free,
      _next_item_active,
      _room_items,
      _fxinfos,
      _next_fx_free,
      _next_fx_active,
      _fixed_cameras,
      _sinks,
      _static_meshes,
      _flyby_cameras,
      _particles,
      _rats,
      _spiders,
      _scarabs,
      _bats,
      _flip_maps,
      _flip_stats,
      _flip_effect,
      _flip_timer,
      _flip_status,
      _ambient_track,
      _ambient_position,
      _oneshot_track,
      _oneshot_position,
      _cd_flags,
      _rope,
      _pendulum,
      _alternate_pendulum,
      _volume_states,
      _call_counters,
      _script_vars);
}

inline bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type) {
  switch (type) {
    case VarUnion::NONE: {
      return true;
    }
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVarUnion(
        verifier,  values->Get(i), types->GetEnum<VarUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *VarUnionUnion::UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTable *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> VarUnionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTableT *>(value);
      return CreatestringTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTableT *>(value);
      return CreateScriptTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTableT *>(value);
      return CreatedoubleTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTableT *>(value);
      return CreateboolTable(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline VarUnionUnion::VarUnionUnion(const VarUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case VarUnion::str: {
      value = new TEN::Save::stringTableT(*reinterpret_cast<TEN::Save::stringTableT *>(u.value));
      break;
    }
    case VarUnion::tab: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::ScriptTableT not copyable.
      break;
    }
    case VarUnion::num: {
      value = new TEN::Save::doubleTableT(*reinterpret_cast<TEN::Save::doubleTableT *>(u.value));
      break;
    }
    case VarUnion::boolean: {
      value = new TEN::Save::boolTableT(*reinterpret_cast<TEN::Save::boolTableT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void VarUnionUnion::Reset() {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<TEN::Save::stringTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<TEN::Save::ScriptTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<TEN::Save::doubleTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<TEN::Save::boolTableT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = VarUnion::NONE;
}

inline const TEN::Save::SaveGame *GetSaveGame(const void *buf) {
  return flatbuffers::GetRoot<TEN::Save::SaveGame>(buf);
}

inline const TEN::Save::SaveGame *GetSizePrefixedSaveGame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<TEN::Save::SaveGame>(buf);
}

inline bool VerifySaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TEN::Save::SaveGame>(nullptr);
}

inline bool VerifySizePrefixedSaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TEN::Save::SaveGame>(nullptr);
}

inline void FinishSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSaveGame(buf)->UnPack(res));
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSizePrefixedSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSizePrefixedSaveGame(buf)->UnPack(res));
}

}  // namespace Save
}  // namespace TEN

#endif  // FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
