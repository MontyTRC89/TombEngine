// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
#define FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_

#include "flatbuffers/flatbuffers.h"

#include "ten_itemdata_generated.h"

namespace TEN {
namespace Save {

struct RoomVector;

struct LevelData;
struct LevelDataBuilder;
struct LevelDataT;

struct Room;
struct RoomBuilder;
struct RoomT;

struct Item;
struct ItemBuilder;
struct ItemT;

struct FXInfo;
struct FXInfoBuilder;
struct FXInfoT;

struct AmmoInfo;
struct AmmoInfoBuilder;
struct AmmoInfoT;

struct HolsterInfo;
struct HolsterInfoBuilder;
struct HolsterInfoT;

struct CarriedWeaponInfo;
struct CarriedWeaponInfoBuilder;
struct CarriedWeaponInfoT;

struct WeaponInfo;
struct WeaponInfoBuilder;
struct WeaponInfoT;

struct ArmInfo;
struct ArmInfoBuilder;
struct ArmInfoT;

struct FlareData;
struct FlareDataBuilder;
struct FlareDataT;

struct TorchData;
struct TorchDataBuilder;
struct TorchDataT;

struct LaraInventoryData;
struct LaraInventoryDataBuilder;
struct LaraInventoryDataT;

struct LaraCountData;
struct LaraCountDataBuilder;
struct LaraCountDataT;

struct LookControlData;
struct LookControlDataBuilder;
struct LookControlDataT;

struct RopeControlData;
struct RopeControlDataBuilder;
struct RopeControlDataT;

struct SubsuitControlData;
struct SubsuitControlDataBuilder;
struct SubsuitControlDataT;

struct TightropeControlData;
struct TightropeControlDataBuilder;
struct TightropeControlDataT;

struct WeaponControlData;
struct WeaponControlDataBuilder;
struct WeaponControlDataT;

struct LaraControlData;
struct LaraControlDataBuilder;
struct LaraControlDataT;

struct PlayerEffectData;
struct PlayerEffectDataBuilder;
struct PlayerEffectDataT;

struct PlayerStatusData;
struct PlayerStatusDataBuilder;
struct PlayerStatusDataT;

struct PlayerContextData;
struct PlayerContextDataBuilder;
struct PlayerContextDataT;

struct CollisionInfoData;
struct CollisionInfoDataBuilder;
struct CollisionInfoDataT;

struct Lara;
struct LaraBuilder;
struct LaraT;

struct Camera;
struct CameraBuilder;
struct CameraT;

struct FixedCamera;
struct FixedCameraBuilder;
struct FixedCameraT;

struct FlyByCamera;
struct FlyByCameraBuilder;
struct FlyByCameraT;

struct Sink;
struct SinkBuilder;
struct SinkT;

struct StaticMeshInfo;
struct StaticMeshInfoBuilder;
struct StaticMeshInfoT;

struct ParticleInfo;
struct ParticleInfoBuilder;
struct ParticleInfoT;

struct Soundtrack;
struct SoundtrackBuilder;
struct SoundtrackT;

struct VideoInfo;
struct VideoInfoBuilder;
struct VideoInfoT;

struct SwarmObjectInfo;
struct SwarmObjectInfoBuilder;
struct SwarmObjectInfoT;

struct RopeSegment;
struct RopeSegmentBuilder;
struct RopeSegmentT;

struct Rope;
struct RopeBuilder;
struct RopeT;

struct Pendulum;
struct PendulumBuilder;
struct PendulumT;

struct EventSet;
struct EventSetBuilder;
struct EventSetT;

struct VolumeState;
struct VolumeStateBuilder;
struct VolumeStateT;

struct Volume;
struct VolumeBuilder;
struct VolumeT;

struct FishData;
struct FishDataBuilder;
struct FishDataT;

struct FireflyData;
struct FireflyDataBuilder;
struct FireflyDataT;

struct KeyValPair;

struct ScriptTable;
struct ScriptTableBuilder;
struct ScriptTableT;

struct stringTable;
struct stringTableBuilder;
struct stringTableT;

struct doubleTable;
struct doubleTableBuilder;
struct doubleTableT;

struct boolTable;
struct boolTableBuilder;
struct boolTableT;

struct timeTable;
struct timeTableBuilder;
struct timeTableT;

struct vec2Table;
struct vec2TableBuilder;
struct vec2TableT;

struct vec3Table;
struct vec3TableBuilder;
struct vec3TableT;

struct rotationTable;
struct rotationTableBuilder;
struct rotationTableT;

struct colorTable;
struct colorTableBuilder;
struct colorTableT;

struct funcNameTable;
struct funcNameTableBuilder;
struct funcNameTableT;

struct UnionTable;
struct UnionTableBuilder;
struct UnionTableT;

struct UnionVec;
struct UnionVecBuilder;
struct UnionVecT;

struct SaveGameHeader;
struct SaveGameHeaderBuilder;
struct SaveGameHeaderT;

struct SaveGameStatistics;
struct SaveGameStatisticsBuilder;
struct SaveGameStatisticsT;

struct SaveGame;
struct SaveGameBuilder;
struct SaveGameT;

enum class TorchState : int32_t {
  holding = 0,
  throwing = 1,
  dropping = 2,
  just_lit = 3,
  MIN = holding,
  MAX = just_lit
};

inline const TorchState (&EnumValuesTorchState())[4] {
  static const TorchState values[] = {
    TorchState::holding,
    TorchState::throwing,
    TorchState::dropping,
    TorchState::just_lit
  };
  return values;
}

inline const char * const *EnumNamesTorchState() {
  static const char * const names[5] = {
    "holding",
    "throwing",
    "dropping",
    "just_lit",
    nullptr
  };
  return names;
}

inline const char *EnumNameTorchState(TorchState e) {
  if (flatbuffers::IsOutRange(e, TorchState::holding, TorchState::just_lit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTorchState()[index];
}

enum class VarUnion : uint8_t {
  NONE = 0,
  str = 1,
  tab = 2,
  num = 3,
  boolean = 4,
  time = 5,
  vec2 = 6,
  vec3 = 7,
  rotation = 8,
  color = 9,
  funcName = 10,
  MIN = NONE,
  MAX = funcName
};

inline const VarUnion (&EnumValuesVarUnion())[11] {
  static const VarUnion values[] = {
    VarUnion::NONE,
    VarUnion::str,
    VarUnion::tab,
    VarUnion::num,
    VarUnion::boolean,
    VarUnion::time,
    VarUnion::vec2,
    VarUnion::vec3,
    VarUnion::rotation,
    VarUnion::color,
    VarUnion::funcName
  };
  return values;
}

inline const char * const *EnumNamesVarUnion() {
  static const char * const names[12] = {
    "NONE",
    "str",
    "tab",
    "num",
    "boolean",
    "time",
    "vec2",
    "vec3",
    "rotation",
    "color",
    "funcName",
    nullptr
  };
  return names;
}

inline const char *EnumNameVarUnion(VarUnion e) {
  if (flatbuffers::IsOutRange(e, VarUnion::NONE, VarUnion::funcName)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarUnion()[index];
}

template<typename T> struct VarUnionTraits {
  static const VarUnion enum_value = VarUnion::NONE;
};

template<> struct VarUnionTraits<TEN::Save::stringTable> {
  static const VarUnion enum_value = VarUnion::str;
};

template<> struct VarUnionTraits<TEN::Save::ScriptTable> {
  static const VarUnion enum_value = VarUnion::tab;
};

template<> struct VarUnionTraits<TEN::Save::doubleTable> {
  static const VarUnion enum_value = VarUnion::num;
};

template<> struct VarUnionTraits<TEN::Save::boolTable> {
  static const VarUnion enum_value = VarUnion::boolean;
};

template<> struct VarUnionTraits<TEN::Save::timeTable> {
  static const VarUnion enum_value = VarUnion::time;
};

template<> struct VarUnionTraits<TEN::Save::vec2Table> {
  static const VarUnion enum_value = VarUnion::vec2;
};

template<> struct VarUnionTraits<TEN::Save::vec3Table> {
  static const VarUnion enum_value = VarUnion::vec3;
};

template<> struct VarUnionTraits<TEN::Save::rotationTable> {
  static const VarUnion enum_value = VarUnion::rotation;
};

template<> struct VarUnionTraits<TEN::Save::colorTable> {
  static const VarUnion enum_value = VarUnion::color;
};

template<> struct VarUnionTraits<TEN::Save::funcNameTable> {
  static const VarUnion enum_value = VarUnion::funcName;
};

struct VarUnionUnion {
  VarUnion type;
  void *value;

  VarUnionUnion() : type(VarUnion::NONE), value(nullptr) {}
  VarUnionUnion(VarUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(VarUnion::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  VarUnionUnion(const VarUnionUnion &);
  VarUnionUnion &operator=(const VarUnionUnion &u)
    { VarUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  VarUnionUnion &operator=(VarUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~VarUnionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = VarUnionTraits<typename RT::TableType>::enum_value;
    if (type != VarUnion::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TEN::Save::stringTableT *Asstr() {
    return type == VarUnion::str ?
      reinterpret_cast<TEN::Save::stringTableT *>(value) : nullptr;
  }
  const TEN::Save::stringTableT *Asstr() const {
    return type == VarUnion::str ?
      reinterpret_cast<const TEN::Save::stringTableT *>(value) : nullptr;
  }
  TEN::Save::ScriptTableT *Astab() {
    return type == VarUnion::tab ?
      reinterpret_cast<TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  const TEN::Save::ScriptTableT *Astab() const {
    return type == VarUnion::tab ?
      reinterpret_cast<const TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  TEN::Save::doubleTableT *Asnum() {
    return type == VarUnion::num ?
      reinterpret_cast<TEN::Save::doubleTableT *>(value) : nullptr;
  }
  const TEN::Save::doubleTableT *Asnum() const {
    return type == VarUnion::num ?
      reinterpret_cast<const TEN::Save::doubleTableT *>(value) : nullptr;
  }
  TEN::Save::boolTableT *Asboolean() {
    return type == VarUnion::boolean ?
      reinterpret_cast<TEN::Save::boolTableT *>(value) : nullptr;
  }
  const TEN::Save::boolTableT *Asboolean() const {
    return type == VarUnion::boolean ?
      reinterpret_cast<const TEN::Save::boolTableT *>(value) : nullptr;
  }
  TEN::Save::timeTableT *Astime() {
    return type == VarUnion::time ?
      reinterpret_cast<TEN::Save::timeTableT *>(value) : nullptr;
  }
  const TEN::Save::timeTableT *Astime() const {
    return type == VarUnion::time ?
      reinterpret_cast<const TEN::Save::timeTableT *>(value) : nullptr;
  }
  TEN::Save::vec2TableT *Asvec2() {
    return type == VarUnion::vec2 ?
      reinterpret_cast<TEN::Save::vec2TableT *>(value) : nullptr;
  }
  const TEN::Save::vec2TableT *Asvec2() const {
    return type == VarUnion::vec2 ?
      reinterpret_cast<const TEN::Save::vec2TableT *>(value) : nullptr;
  }
  TEN::Save::vec3TableT *Asvec3() {
    return type == VarUnion::vec3 ?
      reinterpret_cast<TEN::Save::vec3TableT *>(value) : nullptr;
  }
  const TEN::Save::vec3TableT *Asvec3() const {
    return type == VarUnion::vec3 ?
      reinterpret_cast<const TEN::Save::vec3TableT *>(value) : nullptr;
  }
  TEN::Save::rotationTableT *Asrotation() {
    return type == VarUnion::rotation ?
      reinterpret_cast<TEN::Save::rotationTableT *>(value) : nullptr;
  }
  const TEN::Save::rotationTableT *Asrotation() const {
    return type == VarUnion::rotation ?
      reinterpret_cast<const TEN::Save::rotationTableT *>(value) : nullptr;
  }
  TEN::Save::colorTableT *Ascolor() {
    return type == VarUnion::color ?
      reinterpret_cast<TEN::Save::colorTableT *>(value) : nullptr;
  }
  const TEN::Save::colorTableT *Ascolor() const {
    return type == VarUnion::color ?
      reinterpret_cast<const TEN::Save::colorTableT *>(value) : nullptr;
  }
  TEN::Save::funcNameTableT *AsfuncName() {
    return type == VarUnion::funcName ?
      reinterpret_cast<TEN::Save::funcNameTableT *>(value) : nullptr;
  }
  const TEN::Save::funcNameTableT *AsfuncName() const {
    return type == VarUnion::funcName ?
      reinterpret_cast<const TEN::Save::funcNameTableT *>(value) : nullptr;
  }
};

bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type);
bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RoomVector FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t room_;
  uint32_t y_location_;

 public:
  struct Traits;
  RoomVector()
      : room_(0),
        y_location_(0) {
  }
  RoomVector(uint32_t _room, uint32_t _y_location)
      : room_(flatbuffers::EndianScalar(_room)),
        y_location_(flatbuffers::EndianScalar(_y_location)) {
  }
  uint32_t room() const {
    return flatbuffers::EndianScalar(room_);
  }
  uint32_t y_location() const {
    return flatbuffers::EndianScalar(y_location_);
  }
};
FLATBUFFERS_STRUCT_END(RoomVector, 8);

struct RoomVector::Traits {
  using type = RoomVector;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KeyValPair FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t key_;
  uint32_t val_;

 public:
  struct Traits;
  KeyValPair()
      : key_(0),
        val_(0) {
  }
  KeyValPair(uint32_t _key, uint32_t _val)
      : key_(flatbuffers::EndianScalar(_key)),
        val_(flatbuffers::EndianScalar(_val)) {
  }
  uint32_t key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint32_t val() const {
    return flatbuffers::EndianScalar(val_);
  }
};
FLATBUFFERS_STRUCT_END(KeyValPair, 8);

struct KeyValPair::Traits {
  using type = KeyValPair;
};

struct LevelDataT : public flatbuffers::NativeTable {
  typedef LevelData TableType;
  int32_t level_far_view = 0;
  bool storm_enabled = false;
  bool rumble_enabled = false;
  int32_t weather_type = 0;
  float weather_strength = 0.0f;
  int32_t fog_color = 0;
  float fog_min_distance = 0.0f;
  float fog_max_distance = 0.0f;
  bool sky_layer_1_enabled = false;
  int32_t sky_layer_1_color = 0;
  int32_t sky_layer_1_speed = 0;
  bool sky_layer_2_enabled = false;
  int32_t sky_layer_2_color = 0;
  int32_t sky_layer_2_speed = 0;
  bool horizon1_enabled = false;
  int32_t horizon1_object_id = 0;
  std::unique_ptr<TEN::Save::Vector3> horizon1_position{};
  std::unique_ptr<TEN::Save::EulerAngles> horizon1_orientation{};
  float horizon1_transparency = 0.0f;
  bool horizon2_enabled = false;
  int32_t horizon2_object_id = 0;
  std::unique_ptr<TEN::Save::Vector3> horizon2_position{};
  std::unique_ptr<TEN::Save::EulerAngles> horizon2_orientation{};
  float horizon2_transparency = 0.0f;
  int32_t lensflare_sprite_id = 0;
  float lensflare_pitch = 0.0f;
  float lensflare_yaw = 0.0f;
  int32_t lensflare_color = 0;
  int32_t starfield_star_count = 0;
  int32_t starfield_meteor_count = 0;
  int32_t starfield_meteor_spawn_density = 0;
  int32_t starfield_meteor_velocity = 0;
};

struct LevelData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelDataT NativeTableType;
  typedef LevelDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL_FAR_VIEW = 4,
    VT_STORM_ENABLED = 6,
    VT_RUMBLE_ENABLED = 8,
    VT_WEATHER_TYPE = 10,
    VT_WEATHER_STRENGTH = 12,
    VT_FOG_COLOR = 14,
    VT_FOG_MIN_DISTANCE = 16,
    VT_FOG_MAX_DISTANCE = 18,
    VT_SKY_LAYER_1_ENABLED = 20,
    VT_SKY_LAYER_1_COLOR = 22,
    VT_SKY_LAYER_1_SPEED = 24,
    VT_SKY_LAYER_2_ENABLED = 26,
    VT_SKY_LAYER_2_COLOR = 28,
    VT_SKY_LAYER_2_SPEED = 30,
    VT_HORIZON1_ENABLED = 32,
    VT_HORIZON1_OBJECT_ID = 34,
    VT_HORIZON1_POSITION = 36,
    VT_HORIZON1_ORIENTATION = 38,
    VT_HORIZON1_TRANSPARENCY = 40,
    VT_HORIZON2_ENABLED = 42,
    VT_HORIZON2_OBJECT_ID = 44,
    VT_HORIZON2_POSITION = 46,
    VT_HORIZON2_ORIENTATION = 48,
    VT_HORIZON2_TRANSPARENCY = 50,
    VT_LENSFLARE_SPRITE_ID = 52,
    VT_LENSFLARE_PITCH = 54,
    VT_LENSFLARE_YAW = 56,
    VT_LENSFLARE_COLOR = 58,
    VT_STARFIELD_STAR_COUNT = 60,
    VT_STARFIELD_METEOR_COUNT = 62,
    VT_STARFIELD_METEOR_SPAWN_DENSITY = 64,
    VT_STARFIELD_METEOR_VELOCITY = 66
  };
  int32_t level_far_view() const {
    return GetField<int32_t>(VT_LEVEL_FAR_VIEW, 0);
  }
  bool storm_enabled() const {
    return GetField<uint8_t>(VT_STORM_ENABLED, 0) != 0;
  }
  bool rumble_enabled() const {
    return GetField<uint8_t>(VT_RUMBLE_ENABLED, 0) != 0;
  }
  int32_t weather_type() const {
    return GetField<int32_t>(VT_WEATHER_TYPE, 0);
  }
  float weather_strength() const {
    return GetField<float>(VT_WEATHER_STRENGTH, 0.0f);
  }
  int32_t fog_color() const {
    return GetField<int32_t>(VT_FOG_COLOR, 0);
  }
  float fog_min_distance() const {
    return GetField<float>(VT_FOG_MIN_DISTANCE, 0.0f);
  }
  float fog_max_distance() const {
    return GetField<float>(VT_FOG_MAX_DISTANCE, 0.0f);
  }
  bool sky_layer_1_enabled() const {
    return GetField<uint8_t>(VT_SKY_LAYER_1_ENABLED, 0) != 0;
  }
  int32_t sky_layer_1_color() const {
    return GetField<int32_t>(VT_SKY_LAYER_1_COLOR, 0);
  }
  int32_t sky_layer_1_speed() const {
    return GetField<int32_t>(VT_SKY_LAYER_1_SPEED, 0);
  }
  bool sky_layer_2_enabled() const {
    return GetField<uint8_t>(VT_SKY_LAYER_2_ENABLED, 0) != 0;
  }
  int32_t sky_layer_2_color() const {
    return GetField<int32_t>(VT_SKY_LAYER_2_COLOR, 0);
  }
  int32_t sky_layer_2_speed() const {
    return GetField<int32_t>(VT_SKY_LAYER_2_SPEED, 0);
  }
  bool horizon1_enabled() const {
    return GetField<uint8_t>(VT_HORIZON1_ENABLED, 0) != 0;
  }
  int32_t horizon1_object_id() const {
    return GetField<int32_t>(VT_HORIZON1_OBJECT_ID, 0);
  }
  const TEN::Save::Vector3 *horizon1_position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_HORIZON1_POSITION);
  }
  const TEN::Save::EulerAngles *horizon1_orientation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_HORIZON1_ORIENTATION);
  }
  float horizon1_transparency() const {
    return GetField<float>(VT_HORIZON1_TRANSPARENCY, 0.0f);
  }
  bool horizon2_enabled() const {
    return GetField<uint8_t>(VT_HORIZON2_ENABLED, 0) != 0;
  }
  int32_t horizon2_object_id() const {
    return GetField<int32_t>(VT_HORIZON2_OBJECT_ID, 0);
  }
  const TEN::Save::Vector3 *horizon2_position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_HORIZON2_POSITION);
  }
  const TEN::Save::EulerAngles *horizon2_orientation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_HORIZON2_ORIENTATION);
  }
  float horizon2_transparency() const {
    return GetField<float>(VT_HORIZON2_TRANSPARENCY, 0.0f);
  }
  int32_t lensflare_sprite_id() const {
    return GetField<int32_t>(VT_LENSFLARE_SPRITE_ID, 0);
  }
  float lensflare_pitch() const {
    return GetField<float>(VT_LENSFLARE_PITCH, 0.0f);
  }
  float lensflare_yaw() const {
    return GetField<float>(VT_LENSFLARE_YAW, 0.0f);
  }
  int32_t lensflare_color() const {
    return GetField<int32_t>(VT_LENSFLARE_COLOR, 0);
  }
  int32_t starfield_star_count() const {
    return GetField<int32_t>(VT_STARFIELD_STAR_COUNT, 0);
  }
  int32_t starfield_meteor_count() const {
    return GetField<int32_t>(VT_STARFIELD_METEOR_COUNT, 0);
  }
  int32_t starfield_meteor_spawn_density() const {
    return GetField<int32_t>(VT_STARFIELD_METEOR_SPAWN_DENSITY, 0);
  }
  int32_t starfield_meteor_velocity() const {
    return GetField<int32_t>(VT_STARFIELD_METEOR_VELOCITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEVEL_FAR_VIEW) &&
           VerifyField<uint8_t>(verifier, VT_STORM_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_RUMBLE_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_WEATHER_TYPE) &&
           VerifyField<float>(verifier, VT_WEATHER_STRENGTH) &&
           VerifyField<int32_t>(verifier, VT_FOG_COLOR) &&
           VerifyField<float>(verifier, VT_FOG_MIN_DISTANCE) &&
           VerifyField<float>(verifier, VT_FOG_MAX_DISTANCE) &&
           VerifyField<uint8_t>(verifier, VT_SKY_LAYER_1_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_SKY_LAYER_1_COLOR) &&
           VerifyField<int32_t>(verifier, VT_SKY_LAYER_1_SPEED) &&
           VerifyField<uint8_t>(verifier, VT_SKY_LAYER_2_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_SKY_LAYER_2_COLOR) &&
           VerifyField<int32_t>(verifier, VT_SKY_LAYER_2_SPEED) &&
           VerifyField<uint8_t>(verifier, VT_HORIZON1_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_HORIZON1_OBJECT_ID) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_HORIZON1_POSITION) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_HORIZON1_ORIENTATION) &&
           VerifyField<float>(verifier, VT_HORIZON1_TRANSPARENCY) &&
           VerifyField<uint8_t>(verifier, VT_HORIZON2_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_HORIZON2_OBJECT_ID) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_HORIZON2_POSITION) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_HORIZON2_ORIENTATION) &&
           VerifyField<float>(verifier, VT_HORIZON2_TRANSPARENCY) &&
           VerifyField<int32_t>(verifier, VT_LENSFLARE_SPRITE_ID) &&
           VerifyField<float>(verifier, VT_LENSFLARE_PITCH) &&
           VerifyField<float>(verifier, VT_LENSFLARE_YAW) &&
           VerifyField<int32_t>(verifier, VT_LENSFLARE_COLOR) &&
           VerifyField<int32_t>(verifier, VT_STARFIELD_STAR_COUNT) &&
           VerifyField<int32_t>(verifier, VT_STARFIELD_METEOR_COUNT) &&
           VerifyField<int32_t>(verifier, VT_STARFIELD_METEOR_SPAWN_DENSITY) &&
           VerifyField<int32_t>(verifier, VT_STARFIELD_METEOR_VELOCITY) &&
           verifier.EndTable();
  }
  LevelDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LevelDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LevelData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LevelDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LevelDataBuilder {
  typedef LevelData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level_far_view(int32_t level_far_view) {
    fbb_.AddElement<int32_t>(LevelData::VT_LEVEL_FAR_VIEW, level_far_view, 0);
  }
  void add_storm_enabled(bool storm_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_STORM_ENABLED, static_cast<uint8_t>(storm_enabled), 0);
  }
  void add_rumble_enabled(bool rumble_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_RUMBLE_ENABLED, static_cast<uint8_t>(rumble_enabled), 0);
  }
  void add_weather_type(int32_t weather_type) {
    fbb_.AddElement<int32_t>(LevelData::VT_WEATHER_TYPE, weather_type, 0);
  }
  void add_weather_strength(float weather_strength) {
    fbb_.AddElement<float>(LevelData::VT_WEATHER_STRENGTH, weather_strength, 0.0f);
  }
  void add_fog_color(int32_t fog_color) {
    fbb_.AddElement<int32_t>(LevelData::VT_FOG_COLOR, fog_color, 0);
  }
  void add_fog_min_distance(float fog_min_distance) {
    fbb_.AddElement<float>(LevelData::VT_FOG_MIN_DISTANCE, fog_min_distance, 0.0f);
  }
  void add_fog_max_distance(float fog_max_distance) {
    fbb_.AddElement<float>(LevelData::VT_FOG_MAX_DISTANCE, fog_max_distance, 0.0f);
  }
  void add_sky_layer_1_enabled(bool sky_layer_1_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_SKY_LAYER_1_ENABLED, static_cast<uint8_t>(sky_layer_1_enabled), 0);
  }
  void add_sky_layer_1_color(int32_t sky_layer_1_color) {
    fbb_.AddElement<int32_t>(LevelData::VT_SKY_LAYER_1_COLOR, sky_layer_1_color, 0);
  }
  void add_sky_layer_1_speed(int32_t sky_layer_1_speed) {
    fbb_.AddElement<int32_t>(LevelData::VT_SKY_LAYER_1_SPEED, sky_layer_1_speed, 0);
  }
  void add_sky_layer_2_enabled(bool sky_layer_2_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_SKY_LAYER_2_ENABLED, static_cast<uint8_t>(sky_layer_2_enabled), 0);
  }
  void add_sky_layer_2_color(int32_t sky_layer_2_color) {
    fbb_.AddElement<int32_t>(LevelData::VT_SKY_LAYER_2_COLOR, sky_layer_2_color, 0);
  }
  void add_sky_layer_2_speed(int32_t sky_layer_2_speed) {
    fbb_.AddElement<int32_t>(LevelData::VT_SKY_LAYER_2_SPEED, sky_layer_2_speed, 0);
  }
  void add_horizon1_enabled(bool horizon1_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_HORIZON1_ENABLED, static_cast<uint8_t>(horizon1_enabled), 0);
  }
  void add_horizon1_object_id(int32_t horizon1_object_id) {
    fbb_.AddElement<int32_t>(LevelData::VT_HORIZON1_OBJECT_ID, horizon1_object_id, 0);
  }
  void add_horizon1_position(const TEN::Save::Vector3 *horizon1_position) {
    fbb_.AddStruct(LevelData::VT_HORIZON1_POSITION, horizon1_position);
  }
  void add_horizon1_orientation(const TEN::Save::EulerAngles *horizon1_orientation) {
    fbb_.AddStruct(LevelData::VT_HORIZON1_ORIENTATION, horizon1_orientation);
  }
  void add_horizon1_transparency(float horizon1_transparency) {
    fbb_.AddElement<float>(LevelData::VT_HORIZON1_TRANSPARENCY, horizon1_transparency, 0.0f);
  }
  void add_horizon2_enabled(bool horizon2_enabled) {
    fbb_.AddElement<uint8_t>(LevelData::VT_HORIZON2_ENABLED, static_cast<uint8_t>(horizon2_enabled), 0);
  }
  void add_horizon2_object_id(int32_t horizon2_object_id) {
    fbb_.AddElement<int32_t>(LevelData::VT_HORIZON2_OBJECT_ID, horizon2_object_id, 0);
  }
  void add_horizon2_position(const TEN::Save::Vector3 *horizon2_position) {
    fbb_.AddStruct(LevelData::VT_HORIZON2_POSITION, horizon2_position);
  }
  void add_horizon2_orientation(const TEN::Save::EulerAngles *horizon2_orientation) {
    fbb_.AddStruct(LevelData::VT_HORIZON2_ORIENTATION, horizon2_orientation);
  }
  void add_horizon2_transparency(float horizon2_transparency) {
    fbb_.AddElement<float>(LevelData::VT_HORIZON2_TRANSPARENCY, horizon2_transparency, 0.0f);
  }
  void add_lensflare_sprite_id(int32_t lensflare_sprite_id) {
    fbb_.AddElement<int32_t>(LevelData::VT_LENSFLARE_SPRITE_ID, lensflare_sprite_id, 0);
  }
  void add_lensflare_pitch(float lensflare_pitch) {
    fbb_.AddElement<float>(LevelData::VT_LENSFLARE_PITCH, lensflare_pitch, 0.0f);
  }
  void add_lensflare_yaw(float lensflare_yaw) {
    fbb_.AddElement<float>(LevelData::VT_LENSFLARE_YAW, lensflare_yaw, 0.0f);
  }
  void add_lensflare_color(int32_t lensflare_color) {
    fbb_.AddElement<int32_t>(LevelData::VT_LENSFLARE_COLOR, lensflare_color, 0);
  }
  void add_starfield_star_count(int32_t starfield_star_count) {
    fbb_.AddElement<int32_t>(LevelData::VT_STARFIELD_STAR_COUNT, starfield_star_count, 0);
  }
  void add_starfield_meteor_count(int32_t starfield_meteor_count) {
    fbb_.AddElement<int32_t>(LevelData::VT_STARFIELD_METEOR_COUNT, starfield_meteor_count, 0);
  }
  void add_starfield_meteor_spawn_density(int32_t starfield_meteor_spawn_density) {
    fbb_.AddElement<int32_t>(LevelData::VT_STARFIELD_METEOR_SPAWN_DENSITY, starfield_meteor_spawn_density, 0);
  }
  void add_starfield_meteor_velocity(int32_t starfield_meteor_velocity) {
    fbb_.AddElement<int32_t>(LevelData::VT_STARFIELD_METEOR_VELOCITY, starfield_meteor_velocity, 0);
  }
  explicit LevelDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LevelData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LevelData> CreateLevelData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level_far_view = 0,
    bool storm_enabled = false,
    bool rumble_enabled = false,
    int32_t weather_type = 0,
    float weather_strength = 0.0f,
    int32_t fog_color = 0,
    float fog_min_distance = 0.0f,
    float fog_max_distance = 0.0f,
    bool sky_layer_1_enabled = false,
    int32_t sky_layer_1_color = 0,
    int32_t sky_layer_1_speed = 0,
    bool sky_layer_2_enabled = false,
    int32_t sky_layer_2_color = 0,
    int32_t sky_layer_2_speed = 0,
    bool horizon1_enabled = false,
    int32_t horizon1_object_id = 0,
    const TEN::Save::Vector3 *horizon1_position = 0,
    const TEN::Save::EulerAngles *horizon1_orientation = 0,
    float horizon1_transparency = 0.0f,
    bool horizon2_enabled = false,
    int32_t horizon2_object_id = 0,
    const TEN::Save::Vector3 *horizon2_position = 0,
    const TEN::Save::EulerAngles *horizon2_orientation = 0,
    float horizon2_transparency = 0.0f,
    int32_t lensflare_sprite_id = 0,
    float lensflare_pitch = 0.0f,
    float lensflare_yaw = 0.0f,
    int32_t lensflare_color = 0,
    int32_t starfield_star_count = 0,
    int32_t starfield_meteor_count = 0,
    int32_t starfield_meteor_spawn_density = 0,
    int32_t starfield_meteor_velocity = 0) {
  LevelDataBuilder builder_(_fbb);
  builder_.add_starfield_meteor_velocity(starfield_meteor_velocity);
  builder_.add_starfield_meteor_spawn_density(starfield_meteor_spawn_density);
  builder_.add_starfield_meteor_count(starfield_meteor_count);
  builder_.add_starfield_star_count(starfield_star_count);
  builder_.add_lensflare_color(lensflare_color);
  builder_.add_lensflare_yaw(lensflare_yaw);
  builder_.add_lensflare_pitch(lensflare_pitch);
  builder_.add_lensflare_sprite_id(lensflare_sprite_id);
  builder_.add_horizon2_transparency(horizon2_transparency);
  builder_.add_horizon2_orientation(horizon2_orientation);
  builder_.add_horizon2_position(horizon2_position);
  builder_.add_horizon2_object_id(horizon2_object_id);
  builder_.add_horizon1_transparency(horizon1_transparency);
  builder_.add_horizon1_orientation(horizon1_orientation);
  builder_.add_horizon1_position(horizon1_position);
  builder_.add_horizon1_object_id(horizon1_object_id);
  builder_.add_sky_layer_2_speed(sky_layer_2_speed);
  builder_.add_sky_layer_2_color(sky_layer_2_color);
  builder_.add_sky_layer_1_speed(sky_layer_1_speed);
  builder_.add_sky_layer_1_color(sky_layer_1_color);
  builder_.add_fog_max_distance(fog_max_distance);
  builder_.add_fog_min_distance(fog_min_distance);
  builder_.add_fog_color(fog_color);
  builder_.add_weather_strength(weather_strength);
  builder_.add_weather_type(weather_type);
  builder_.add_level_far_view(level_far_view);
  builder_.add_horizon2_enabled(horizon2_enabled);
  builder_.add_horizon1_enabled(horizon1_enabled);
  builder_.add_sky_layer_2_enabled(sky_layer_2_enabled);
  builder_.add_sky_layer_1_enabled(sky_layer_1_enabled);
  builder_.add_rumble_enabled(rumble_enabled);
  builder_.add_storm_enabled(storm_enabled);
  return builder_.Finish();
}

struct LevelData::Traits {
  using type = LevelData;
  static auto constexpr Create = CreateLevelData;
};

flatbuffers::Offset<LevelData> CreateLevelData(flatbuffers::FlatBufferBuilder &_fbb, const LevelDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoomT : public flatbuffers::NativeTable {
  typedef Room TableType;
  int32_t index = 0;
  std::string name{};
  int32_t flags = 0;
  int32_t reverb_type = 0;
};

struct Room FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoomT NativeTableType;
  typedef RoomBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_NAME = 6,
    VT_FLAGS = 8,
    VT_REVERB_TYPE = 10
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t reverb_type() const {
    return GetField<int32_t>(VT_REVERB_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_REVERB_TYPE) &&
           verifier.EndTable();
  }
  RoomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Room> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoomBuilder {
  typedef Room Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(Room::VT_INDEX, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Room::VT_NAME, name);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Room::VT_FLAGS, flags, 0);
  }
  void add_reverb_type(int32_t reverb_type) {
    fbb_.AddElement<int32_t>(Room::VT_REVERB_TYPE, reverb_type, 0);
  }
  explicit RoomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Room> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Room>(end);
    return o;
  }
};

inline flatbuffers::Offset<Room> CreateRoom(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t flags = 0,
    int32_t reverb_type = 0) {
  RoomBuilder builder_(_fbb);
  builder_.add_reverb_type(reverb_type);
  builder_.add_flags(flags);
  builder_.add_name(name);
  builder_.add_index(index);
  return builder_.Finish();
}

struct Room::Traits {
  using type = Room;
  static auto constexpr Create = CreateRoom;
};

inline flatbuffers::Offset<Room> CreateRoomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    const char *name = nullptr,
    int32_t flags = 0,
    int32_t reverb_type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return TEN::Save::CreateRoom(
      _fbb,
      index,
      name__,
      flags,
      reverb_type);
}

flatbuffers::Offset<Room> CreateRoom(flatbuffers::FlatBufferBuilder &_fbb, const RoomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemT : public flatbuffers::NativeTable {
  typedef Item TableType;
  int32_t anim_object_id = 0;
  int32_t active_state = 0;
  int32_t anim_number = 0;
  int32_t frame_number = 0;
  bool is_airborne = false;
  int32_t required_state = 0;
  int32_t target_state = 0;
  std::unique_ptr<TEN::Save::Vector3> velocity{};
  int32_t floor = 0;
  int32_t touch_bits = 0;
  int32_t mesh_bits = 0;
  int32_t object_id = 0;
  int32_t room_number = 0;
  int32_t hit_points = 0;
  int32_t box_number = 0;
  int32_t timer = 0;
  std::unique_ptr<TEN::Save::Vector4> color{};
  int32_t flags = 0;
  int32_t trigger_flags = 0;
  int32_t carried_item = 0;
  int32_t after_death = 0;
  std::vector<int32_t> item_flags{};
  std::unique_ptr<TEN::Save::Pose> pose{};
  int32_t next_item = 0;
  int32_t next_item_active = 0;
  bool active = false;
  int32_t status = 0;
  bool hit_stauts = false;
  bool collidable = false;
  bool looked_at = false;
  int32_t ai_bits = 0;
  TEN::Save::ItemDataUnion data{};
  int32_t base_mesh = 0;
  std::vector<int32_t> mesh_pointers{};
  int32_t effect_type = 0;
  std::unique_ptr<TEN::Save::Vector3> effect_light_colour{};
  std::unique_ptr<TEN::Save::Vector3> effect_primary_colour{};
  std::unique_ptr<TEN::Save::Vector3> effect_secondary_colour{};
  int32_t effect_count = 0;
  std::string lua_name{};
  std::string lua_on_killed_name{};
  std::string lua_on_hit_name{};
  std::string lua_on_collided_with_object_name{};
  std::string lua_on_collided_with_room_name{};
};

struct Item FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIM_OBJECT_ID = 4,
    VT_ACTIVE_STATE = 6,
    VT_ANIM_NUMBER = 8,
    VT_FRAME_NUMBER = 10,
    VT_IS_AIRBORNE = 12,
    VT_REQUIRED_STATE = 14,
    VT_TARGET_STATE = 16,
    VT_VELOCITY = 18,
    VT_FLOOR = 20,
    VT_TOUCH_BITS = 22,
    VT_MESH_BITS = 24,
    VT_OBJECT_ID = 26,
    VT_ROOM_NUMBER = 28,
    VT_HIT_POINTS = 30,
    VT_BOX_NUMBER = 32,
    VT_TIMER = 34,
    VT_COLOR = 36,
    VT_FLAGS = 38,
    VT_TRIGGER_FLAGS = 40,
    VT_CARRIED_ITEM = 42,
    VT_AFTER_DEATH = 44,
    VT_ITEM_FLAGS = 46,
    VT_POSE = 48,
    VT_NEXT_ITEM = 50,
    VT_NEXT_ITEM_ACTIVE = 52,
    VT_ACTIVE = 54,
    VT_STATUS = 56,
    VT_HIT_STAUTS = 58,
    VT_COLLIDABLE = 60,
    VT_LOOKED_AT = 62,
    VT_AI_BITS = 64,
    VT_DATA_TYPE = 66,
    VT_DATA = 68,
    VT_BASE_MESH = 70,
    VT_MESH_POINTERS = 72,
    VT_EFFECT_TYPE = 74,
    VT_EFFECT_LIGHT_COLOUR = 76,
    VT_EFFECT_PRIMARY_COLOUR = 78,
    VT_EFFECT_SECONDARY_COLOUR = 80,
    VT_EFFECT_COUNT = 82,
    VT_LUA_NAME = 84,
    VT_LUA_ON_KILLED_NAME = 86,
    VT_LUA_ON_HIT_NAME = 88,
    VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME = 90,
    VT_LUA_ON_COLLIDED_WITH_ROOM_NAME = 92
  };
  int32_t anim_object_id() const {
    return GetField<int32_t>(VT_ANIM_OBJECT_ID, 0);
  }
  int32_t active_state() const {
    return GetField<int32_t>(VT_ACTIVE_STATE, 0);
  }
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  bool is_airborne() const {
    return GetField<uint8_t>(VT_IS_AIRBORNE, 0) != 0;
  }
  int32_t required_state() const {
    return GetField<int32_t>(VT_REQUIRED_STATE, 0);
  }
  int32_t target_state() const {
    return GetField<int32_t>(VT_TARGET_STATE, 0);
  }
  const TEN::Save::Vector3 *velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VELOCITY);
  }
  int32_t floor() const {
    return GetField<int32_t>(VT_FLOOR, 0);
  }
  int32_t touch_bits() const {
    return GetField<int32_t>(VT_TOUCH_BITS, 0);
  }
  int32_t mesh_bits() const {
    return GetField<int32_t>(VT_MESH_BITS, 0);
  }
  int32_t object_id() const {
    return GetField<int32_t>(VT_OBJECT_ID, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t box_number() const {
    return GetField<int32_t>(VT_BOX_NUMBER, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  const TEN::Save::Vector4 *color() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_COLOR);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t trigger_flags() const {
    return GetField<int32_t>(VT_TRIGGER_FLAGS, 0);
  }
  int32_t carried_item() const {
    return GetField<int32_t>(VT_CARRIED_ITEM, 0);
  }
  int32_t after_death() const {
    return GetField<int32_t>(VT_AFTER_DEATH, 0);
  }
  const flatbuffers::Vector<int32_t> *item_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ITEM_FLAGS);
  }
  const TEN::Save::Pose *pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_POSE);
  }
  int32_t next_item() const {
    return GetField<int32_t>(VT_NEXT_ITEM, 0);
  }
  int32_t next_item_active() const {
    return GetField<int32_t>(VT_NEXT_ITEM_ACTIVE, 0);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool hit_stauts() const {
    return GetField<uint8_t>(VT_HIT_STAUTS, 0) != 0;
  }
  bool collidable() const {
    return GetField<uint8_t>(VT_COLLIDABLE, 0) != 0;
  }
  bool looked_at() const {
    return GetField<uint8_t>(VT_LOOKED_AT, 0) != 0;
  }
  int32_t ai_bits() const {
    return GetField<int32_t>(VT_AI_BITS, 0);
  }
  TEN::Save::ItemData data_type() const {
    return static_cast<TEN::Save::ItemData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const TEN::Save::Int *data_as_Int() const {
    return data_type() == TEN::Save::ItemData::Int ? static_cast<const TEN::Save::Int *>(data()) : nullptr;
  }
  const TEN::Save::Short *data_as_Short() const {
    return data_type() == TEN::Save::ItemData::Short ? static_cast<const TEN::Save::Short *>(data()) : nullptr;
  }
  const TEN::Save::Float *data_as_Float() const {
    return data_type() == TEN::Save::ItemData::Float ? static_cast<const TEN::Save::Float *>(data()) : nullptr;
  }
  const TEN::Save::ShortArray *data_as_ShortArray() const {
    return data_type() == TEN::Save::ItemData::ShortArray ? static_cast<const TEN::Save::ShortArray *>(data()) : nullptr;
  }
  const TEN::Save::ItemNumber *data_as_ItemNumber() const {
    return data_type() == TEN::Save::ItemData::ItemNumber ? static_cast<const TEN::Save::ItemNumber *>(data()) : nullptr;
  }
  const TEN::Save::Creature *data_as_Creature() const {
    return data_type() == TEN::Save::ItemData::Creature ? static_cast<const TEN::Save::Creature *>(data()) : nullptr;
  }
  const TEN::Save::LaserHead *data_as_LaserHead() const {
    return data_type() == TEN::Save::ItemData::LaserHead ? static_cast<const TEN::Save::LaserHead *>(data()) : nullptr;
  }
  const TEN::Save::QuadBike *data_as_QuadBike() const {
    return data_type() == TEN::Save::ItemData::QuadBike ? static_cast<const TEN::Save::QuadBike *>(data()) : nullptr;
  }
  const TEN::Save::BigGun *data_as_BigGun() const {
    return data_type() == TEN::Save::ItemData::BigGun ? static_cast<const TEN::Save::BigGun *>(data()) : nullptr;
  }
  const TEN::Save::Motorbike *data_as_Motorbike() const {
    return data_type() == TEN::Save::ItemData::Motorbike ? static_cast<const TEN::Save::Motorbike *>(data()) : nullptr;
  }
  const TEN::Save::Jeep *data_as_Jeep() const {
    return data_type() == TEN::Save::ItemData::Jeep ? static_cast<const TEN::Save::Jeep *>(data()) : nullptr;
  }
  const TEN::Save::LaraInfo *data_as_LaraInfo() const {
    return data_type() == TEN::Save::ItemData::LaraInfo ? static_cast<const TEN::Save::LaraInfo *>(data()) : nullptr;
  }
  const TEN::Save::Kayak *data_as_Kayak() const {
    return data_type() == TEN::Save::ItemData::Kayak ? static_cast<const TEN::Save::Kayak *>(data()) : nullptr;
  }
  const TEN::Save::Door *data_as_Door() const {
    return data_type() == TEN::Save::ItemData::Door ? static_cast<const TEN::Save::Door *>(data()) : nullptr;
  }
  const TEN::Save::Skidoo *data_as_Skidoo() const {
    return data_type() == TEN::Save::ItemData::Skidoo ? static_cast<const TEN::Save::Skidoo *>(data()) : nullptr;
  }
  const TEN::Save::UPV *data_as_UPV() const {
    return data_type() == TEN::Save::ItemData::UPV ? static_cast<const TEN::Save::UPV *>(data()) : nullptr;
  }
  const TEN::Save::Motorboat *data_as_Motorboat() const {
    return data_type() == TEN::Save::ItemData::Motorboat ? static_cast<const TEN::Save::Motorboat *>(data()) : nullptr;
  }
  const TEN::Save::Wraith *data_as_Wraith() const {
    return data_type() == TEN::Save::ItemData::Wraith ? static_cast<const TEN::Save::Wraith *>(data()) : nullptr;
  }
  const TEN::Save::Rubberboat *data_as_Rubberboat() const {
    return data_type() == TEN::Save::ItemData::Rubberboat ? static_cast<const TEN::Save::Rubberboat *>(data()) : nullptr;
  }
  const TEN::Save::Pushable *data_as_Pushable() const {
    return data_type() == TEN::Save::ItemData::Pushable ? static_cast<const TEN::Save::Pushable *>(data()) : nullptr;
  }
  const TEN::Save::Minecart *data_as_Minecart() const {
    return data_type() == TEN::Save::ItemData::Minecart ? static_cast<const TEN::Save::Minecart *>(data()) : nullptr;
  }
  int32_t base_mesh() const {
    return GetField<int32_t>(VT_BASE_MESH, 0);
  }
  const flatbuffers::Vector<int32_t> *mesh_pointers() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MESH_POINTERS);
  }
  int32_t effect_type() const {
    return GetField<int32_t>(VT_EFFECT_TYPE, 0);
  }
  const TEN::Save::Vector3 *effect_light_colour() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EFFECT_LIGHT_COLOUR);
  }
  const TEN::Save::Vector3 *effect_primary_colour() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EFFECT_PRIMARY_COLOUR);
  }
  const TEN::Save::Vector3 *effect_secondary_colour() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_EFFECT_SECONDARY_COLOUR);
  }
  int32_t effect_count() const {
    return GetField<int32_t>(VT_EFFECT_COUNT, 0);
  }
  const flatbuffers::String *lua_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_NAME);
  }
  const flatbuffers::String *lua_on_killed_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_KILLED_NAME);
  }
  const flatbuffers::String *lua_on_hit_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_HIT_NAME);
  }
  const flatbuffers::String *lua_on_collided_with_object_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME);
  }
  const flatbuffers::String *lua_on_collided_with_room_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LUA_ON_COLLIDED_WITH_ROOM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ANIM_OBJECT_ID) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_STATE) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_IS_AIRBORNE) &&
           VerifyField<int32_t>(verifier, VT_REQUIRED_STATE) &&
           VerifyField<int32_t>(verifier, VT_TARGET_STATE) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_FLOOR) &&
           VerifyField<int32_t>(verifier, VT_TOUCH_BITS) &&
           VerifyField<int32_t>(verifier, VT_MESH_BITS) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_ID) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_BOX_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TRIGGER_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_CARRIED_ITEM) &&
           VerifyField<int32_t>(verifier, VT_AFTER_DEATH) &&
           VerifyOffset(verifier, VT_ITEM_FLAGS) &&
           verifier.VerifyVector(item_flags()) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_POSE) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_HIT_STAUTS) &&
           VerifyField<uint8_t>(verifier, VT_COLLIDABLE) &&
           VerifyField<uint8_t>(verifier, VT_LOOKED_AT) &&
           VerifyField<int32_t>(verifier, VT_AI_BITS) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyItemData(verifier, data(), data_type()) &&
           VerifyField<int32_t>(verifier, VT_BASE_MESH) &&
           VerifyOffset(verifier, VT_MESH_POINTERS) &&
           verifier.VerifyVector(mesh_pointers()) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_TYPE) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EFFECT_LIGHT_COLOUR) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EFFECT_PRIMARY_COLOUR) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_EFFECT_SECONDARY_COLOUR) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_COUNT) &&
           VerifyOffset(verifier, VT_LUA_NAME) &&
           verifier.VerifyString(lua_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_KILLED_NAME) &&
           verifier.VerifyString(lua_on_killed_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_HIT_NAME) &&
           verifier.VerifyString(lua_on_hit_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME) &&
           verifier.VerifyString(lua_on_collided_with_object_name()) &&
           VerifyOffset(verifier, VT_LUA_ON_COLLIDED_WITH_ROOM_NAME) &&
           verifier.VerifyString(lua_on_collided_with_room_name()) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Item> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::Int *Item::data_as<TEN::Save::Int>() const {
  return data_as_Int();
}

template<> inline const TEN::Save::Short *Item::data_as<TEN::Save::Short>() const {
  return data_as_Short();
}

template<> inline const TEN::Save::Float *Item::data_as<TEN::Save::Float>() const {
  return data_as_Float();
}

template<> inline const TEN::Save::ShortArray *Item::data_as<TEN::Save::ShortArray>() const {
  return data_as_ShortArray();
}

template<> inline const TEN::Save::ItemNumber *Item::data_as<TEN::Save::ItemNumber>() const {
  return data_as_ItemNumber();
}

template<> inline const TEN::Save::Creature *Item::data_as<TEN::Save::Creature>() const {
  return data_as_Creature();
}

template<> inline const TEN::Save::LaserHead *Item::data_as<TEN::Save::LaserHead>() const {
  return data_as_LaserHead();
}

template<> inline const TEN::Save::QuadBike *Item::data_as<TEN::Save::QuadBike>() const {
  return data_as_QuadBike();
}

template<> inline const TEN::Save::BigGun *Item::data_as<TEN::Save::BigGun>() const {
  return data_as_BigGun();
}

template<> inline const TEN::Save::Motorbike *Item::data_as<TEN::Save::Motorbike>() const {
  return data_as_Motorbike();
}

template<> inline const TEN::Save::Jeep *Item::data_as<TEN::Save::Jeep>() const {
  return data_as_Jeep();
}

template<> inline const TEN::Save::LaraInfo *Item::data_as<TEN::Save::LaraInfo>() const {
  return data_as_LaraInfo();
}

template<> inline const TEN::Save::Kayak *Item::data_as<TEN::Save::Kayak>() const {
  return data_as_Kayak();
}

template<> inline const TEN::Save::Door *Item::data_as<TEN::Save::Door>() const {
  return data_as_Door();
}

template<> inline const TEN::Save::Skidoo *Item::data_as<TEN::Save::Skidoo>() const {
  return data_as_Skidoo();
}

template<> inline const TEN::Save::UPV *Item::data_as<TEN::Save::UPV>() const {
  return data_as_UPV();
}

template<> inline const TEN::Save::Motorboat *Item::data_as<TEN::Save::Motorboat>() const {
  return data_as_Motorboat();
}

template<> inline const TEN::Save::Wraith *Item::data_as<TEN::Save::Wraith>() const {
  return data_as_Wraith();
}

template<> inline const TEN::Save::Rubberboat *Item::data_as<TEN::Save::Rubberboat>() const {
  return data_as_Rubberboat();
}

template<> inline const TEN::Save::Pushable *Item::data_as<TEN::Save::Pushable>() const {
  return data_as_Pushable();
}

template<> inline const TEN::Save::Minecart *Item::data_as<TEN::Save::Minecart>() const {
  return data_as_Minecart();
}

struct ItemBuilder {
  typedef Item Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_anim_object_id(int32_t anim_object_id) {
    fbb_.AddElement<int32_t>(Item::VT_ANIM_OBJECT_ID, anim_object_id, 0);
  }
  void add_active_state(int32_t active_state) {
    fbb_.AddElement<int32_t>(Item::VT_ACTIVE_STATE, active_state, 0);
  }
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(Item::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(Item::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_is_airborne(bool is_airborne) {
    fbb_.AddElement<uint8_t>(Item::VT_IS_AIRBORNE, static_cast<uint8_t>(is_airborne), 0);
  }
  void add_required_state(int32_t required_state) {
    fbb_.AddElement<int32_t>(Item::VT_REQUIRED_STATE, required_state, 0);
  }
  void add_target_state(int32_t target_state) {
    fbb_.AddElement<int32_t>(Item::VT_TARGET_STATE, target_state, 0);
  }
  void add_velocity(const TEN::Save::Vector3 *velocity) {
    fbb_.AddStruct(Item::VT_VELOCITY, velocity);
  }
  void add_floor(int32_t floor) {
    fbb_.AddElement<int32_t>(Item::VT_FLOOR, floor, 0);
  }
  void add_touch_bits(int32_t touch_bits) {
    fbb_.AddElement<int32_t>(Item::VT_TOUCH_BITS, touch_bits, 0);
  }
  void add_mesh_bits(int32_t mesh_bits) {
    fbb_.AddElement<int32_t>(Item::VT_MESH_BITS, mesh_bits, 0);
  }
  void add_object_id(int32_t object_id) {
    fbb_.AddElement<int32_t>(Item::VT_OBJECT_ID, object_id, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(Item::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(Item::VT_HIT_POINTS, hit_points, 0);
  }
  void add_box_number(int32_t box_number) {
    fbb_.AddElement<int32_t>(Item::VT_BOX_NUMBER, box_number, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(Item::VT_TIMER, timer, 0);
  }
  void add_color(const TEN::Save::Vector4 *color) {
    fbb_.AddStruct(Item::VT_COLOR, color);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Item::VT_FLAGS, flags, 0);
  }
  void add_trigger_flags(int32_t trigger_flags) {
    fbb_.AddElement<int32_t>(Item::VT_TRIGGER_FLAGS, trigger_flags, 0);
  }
  void add_carried_item(int32_t carried_item) {
    fbb_.AddElement<int32_t>(Item::VT_CARRIED_ITEM, carried_item, 0);
  }
  void add_after_death(int32_t after_death) {
    fbb_.AddElement<int32_t>(Item::VT_AFTER_DEATH, after_death, 0);
  }
  void add_item_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags) {
    fbb_.AddOffset(Item::VT_ITEM_FLAGS, item_flags);
  }
  void add_pose(const TEN::Save::Pose *pose) {
    fbb_.AddStruct(Item::VT_POSE, pose);
  }
  void add_next_item(int32_t next_item) {
    fbb_.AddElement<int32_t>(Item::VT_NEXT_ITEM, next_item, 0);
  }
  void add_next_item_active(int32_t next_item_active) {
    fbb_.AddElement<int32_t>(Item::VT_NEXT_ITEM_ACTIVE, next_item_active, 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Item::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(Item::VT_STATUS, status, 0);
  }
  void add_hit_stauts(bool hit_stauts) {
    fbb_.AddElement<uint8_t>(Item::VT_HIT_STAUTS, static_cast<uint8_t>(hit_stauts), 0);
  }
  void add_collidable(bool collidable) {
    fbb_.AddElement<uint8_t>(Item::VT_COLLIDABLE, static_cast<uint8_t>(collidable), 0);
  }
  void add_looked_at(bool looked_at) {
    fbb_.AddElement<uint8_t>(Item::VT_LOOKED_AT, static_cast<uint8_t>(looked_at), 0);
  }
  void add_ai_bits(int32_t ai_bits) {
    fbb_.AddElement<int32_t>(Item::VT_AI_BITS, ai_bits, 0);
  }
  void add_data_type(TEN::Save::ItemData data_type) {
    fbb_.AddElement<uint8_t>(Item::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Item::VT_DATA, data);
  }
  void add_base_mesh(int32_t base_mesh) {
    fbb_.AddElement<int32_t>(Item::VT_BASE_MESH, base_mesh, 0);
  }
  void add_mesh_pointers(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_pointers) {
    fbb_.AddOffset(Item::VT_MESH_POINTERS, mesh_pointers);
  }
  void add_effect_type(int32_t effect_type) {
    fbb_.AddElement<int32_t>(Item::VT_EFFECT_TYPE, effect_type, 0);
  }
  void add_effect_light_colour(const TEN::Save::Vector3 *effect_light_colour) {
    fbb_.AddStruct(Item::VT_EFFECT_LIGHT_COLOUR, effect_light_colour);
  }
  void add_effect_primary_colour(const TEN::Save::Vector3 *effect_primary_colour) {
    fbb_.AddStruct(Item::VT_EFFECT_PRIMARY_COLOUR, effect_primary_colour);
  }
  void add_effect_secondary_colour(const TEN::Save::Vector3 *effect_secondary_colour) {
    fbb_.AddStruct(Item::VT_EFFECT_SECONDARY_COLOUR, effect_secondary_colour);
  }
  void add_effect_count(int32_t effect_count) {
    fbb_.AddElement<int32_t>(Item::VT_EFFECT_COUNT, effect_count, 0);
  }
  void add_lua_name(flatbuffers::Offset<flatbuffers::String> lua_name) {
    fbb_.AddOffset(Item::VT_LUA_NAME, lua_name);
  }
  void add_lua_on_killed_name(flatbuffers::Offset<flatbuffers::String> lua_on_killed_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_KILLED_NAME, lua_on_killed_name);
  }
  void add_lua_on_hit_name(flatbuffers::Offset<flatbuffers::String> lua_on_hit_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_HIT_NAME, lua_on_hit_name);
  }
  void add_lua_on_collided_with_object_name(flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_object_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_COLLIDED_WITH_OBJECT_NAME, lua_on_collided_with_object_name);
  }
  void add_lua_on_collided_with_room_name(flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_room_name) {
    fbb_.AddOffset(Item::VT_LUA_ON_COLLIDED_WITH_ROOM_NAME, lua_on_collided_with_room_name);
  }
  explicit ItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline flatbuffers::Offset<Item> CreateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t anim_object_id = 0,
    int32_t active_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    bool is_airborne = false,
    int32_t required_state = 0,
    int32_t target_state = 0,
    const TEN::Save::Vector3 *velocity = 0,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t room_number = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags = 0,
    const TEN::Save::Pose *pose = 0,
    int32_t next_item = 0,
    int32_t next_item_active = 0,
    bool active = false,
    int32_t status = 0,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    int32_t ai_bits = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0,
    int32_t base_mesh = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_pointers = 0,
    int32_t effect_type = 0,
    const TEN::Save::Vector3 *effect_light_colour = 0,
    const TEN::Save::Vector3 *effect_primary_colour = 0,
    const TEN::Save::Vector3 *effect_secondary_colour = 0,
    int32_t effect_count = 0,
    flatbuffers::Offset<flatbuffers::String> lua_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_killed_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_hit_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_object_name = 0,
    flatbuffers::Offset<flatbuffers::String> lua_on_collided_with_room_name = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_lua_on_collided_with_room_name(lua_on_collided_with_room_name);
  builder_.add_lua_on_collided_with_object_name(lua_on_collided_with_object_name);
  builder_.add_lua_on_hit_name(lua_on_hit_name);
  builder_.add_lua_on_killed_name(lua_on_killed_name);
  builder_.add_lua_name(lua_name);
  builder_.add_effect_count(effect_count);
  builder_.add_effect_secondary_colour(effect_secondary_colour);
  builder_.add_effect_primary_colour(effect_primary_colour);
  builder_.add_effect_light_colour(effect_light_colour);
  builder_.add_effect_type(effect_type);
  builder_.add_mesh_pointers(mesh_pointers);
  builder_.add_base_mesh(base_mesh);
  builder_.add_data(data);
  builder_.add_ai_bits(ai_bits);
  builder_.add_status(status);
  builder_.add_next_item_active(next_item_active);
  builder_.add_next_item(next_item);
  builder_.add_pose(pose);
  builder_.add_item_flags(item_flags);
  builder_.add_after_death(after_death);
  builder_.add_carried_item(carried_item);
  builder_.add_trigger_flags(trigger_flags);
  builder_.add_flags(flags);
  builder_.add_color(color);
  builder_.add_timer(timer);
  builder_.add_box_number(box_number);
  builder_.add_hit_points(hit_points);
  builder_.add_room_number(room_number);
  builder_.add_object_id(object_id);
  builder_.add_mesh_bits(mesh_bits);
  builder_.add_touch_bits(touch_bits);
  builder_.add_floor(floor);
  builder_.add_velocity(velocity);
  builder_.add_target_state(target_state);
  builder_.add_required_state(required_state);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_active_state(active_state);
  builder_.add_anim_object_id(anim_object_id);
  builder_.add_data_type(data_type);
  builder_.add_looked_at(looked_at);
  builder_.add_collidable(collidable);
  builder_.add_hit_stauts(hit_stauts);
  builder_.add_active(active);
  builder_.add_is_airborne(is_airborne);
  return builder_.Finish();
}

struct Item::Traits {
  using type = Item;
  static auto constexpr Create = CreateItem;
};

inline flatbuffers::Offset<Item> CreateItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t anim_object_id = 0,
    int32_t active_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    bool is_airborne = false,
    int32_t required_state = 0,
    int32_t target_state = 0,
    const TEN::Save::Vector3 *velocity = 0,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t room_number = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    const std::vector<int32_t> *item_flags = nullptr,
    const TEN::Save::Pose *pose = 0,
    int32_t next_item = 0,
    int32_t next_item_active = 0,
    bool active = false,
    int32_t status = 0,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    int32_t ai_bits = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0,
    int32_t base_mesh = 0,
    const std::vector<int32_t> *mesh_pointers = nullptr,
    int32_t effect_type = 0,
    const TEN::Save::Vector3 *effect_light_colour = 0,
    const TEN::Save::Vector3 *effect_primary_colour = 0,
    const TEN::Save::Vector3 *effect_secondary_colour = 0,
    int32_t effect_count = 0,
    const char *lua_name = nullptr,
    const char *lua_on_killed_name = nullptr,
    const char *lua_on_hit_name = nullptr,
    const char *lua_on_collided_with_object_name = nullptr,
    const char *lua_on_collided_with_room_name = nullptr) {
  auto item_flags__ = item_flags ? _fbb.CreateVector<int32_t>(*item_flags) : 0;
  auto mesh_pointers__ = mesh_pointers ? _fbb.CreateVector<int32_t>(*mesh_pointers) : 0;
  auto lua_name__ = lua_name ? _fbb.CreateString(lua_name) : 0;
  auto lua_on_killed_name__ = lua_on_killed_name ? _fbb.CreateString(lua_on_killed_name) : 0;
  auto lua_on_hit_name__ = lua_on_hit_name ? _fbb.CreateString(lua_on_hit_name) : 0;
  auto lua_on_collided_with_object_name__ = lua_on_collided_with_object_name ? _fbb.CreateString(lua_on_collided_with_object_name) : 0;
  auto lua_on_collided_with_room_name__ = lua_on_collided_with_room_name ? _fbb.CreateString(lua_on_collided_with_room_name) : 0;
  return TEN::Save::CreateItem(
      _fbb,
      anim_object_id,
      active_state,
      anim_number,
      frame_number,
      is_airborne,
      required_state,
      target_state,
      velocity,
      floor,
      touch_bits,
      mesh_bits,
      object_id,
      room_number,
      hit_points,
      box_number,
      timer,
      color,
      flags,
      trigger_flags,
      carried_item,
      after_death,
      item_flags__,
      pose,
      next_item,
      next_item_active,
      active,
      status,
      hit_stauts,
      collidable,
      looked_at,
      ai_bits,
      data_type,
      data,
      base_mesh,
      mesh_pointers__,
      effect_type,
      effect_light_colour,
      effect_primary_colour,
      effect_secondary_colour,
      effect_count,
      lua_name__,
      lua_on_killed_name__,
      lua_on_hit_name__,
      lua_on_collided_with_object_name__,
      lua_on_collided_with_room_name__);
}

flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FXInfoT : public flatbuffers::NativeTable {
  typedef FXInfo TableType;
  std::unique_ptr<TEN::Save::Pose> pose{};
  int32_t room_number = 0;
  int32_t object_number = 0;
  int32_t next_fx = 0;
  int32_t next_active = 0;
  int32_t speed = 0;
  int32_t fall_speed = 0;
  int32_t frame_number = 0;
  int32_t counter = 0;
  std::unique_ptr<TEN::Save::Vector4> color{};
  int32_t flag1 = 0;
  int32_t flag2 = 0;
};

struct FXInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FXInfoT NativeTableType;
  typedef FXInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSE = 4,
    VT_ROOM_NUMBER = 6,
    VT_OBJECT_NUMBER = 8,
    VT_NEXT_FX = 10,
    VT_NEXT_ACTIVE = 12,
    VT_SPEED = 14,
    VT_FALL_SPEED = 16,
    VT_FRAME_NUMBER = 18,
    VT_COUNTER = 20,
    VT_COLOR = 22,
    VT_FLAG1 = 24,
    VT_FLAG2 = 26
  };
  const TEN::Save::Pose *pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_POSE);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t object_number() const {
    return GetField<int32_t>(VT_OBJECT_NUMBER, 0);
  }
  int32_t next_fx() const {
    return GetField<int32_t>(VT_NEXT_FX, 0);
  }
  int32_t next_active() const {
    return GetField<int32_t>(VT_NEXT_ACTIVE, 0);
  }
  int32_t speed() const {
    return GetField<int32_t>(VT_SPEED, 0);
  }
  int32_t fall_speed() const {
    return GetField<int32_t>(VT_FALL_SPEED, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t counter() const {
    return GetField<int32_t>(VT_COUNTER, 0);
  }
  const TEN::Save::Vector4 *color() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_COLOR);
  }
  int32_t flag1() const {
    return GetField<int32_t>(VT_FLAG1, 0);
  }
  int32_t flag2() const {
    return GetField<int32_t>(VT_FLAG2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_POSE) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FALL_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_COUNTER) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_FLAG1) &&
           VerifyField<int32_t>(verifier, VT_FLAG2) &&
           verifier.EndTable();
  }
  FXInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FXInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FXInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FXInfoBuilder {
  typedef FXInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pose(const TEN::Save::Pose *pose) {
    fbb_.AddStruct(FXInfo::VT_POSE, pose);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_object_number(int32_t object_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_next_fx(int32_t next_fx) {
    fbb_.AddElement<int32_t>(FXInfo::VT_NEXT_FX, next_fx, 0);
  }
  void add_next_active(int32_t next_active) {
    fbb_.AddElement<int32_t>(FXInfo::VT_NEXT_ACTIVE, next_active, 0);
  }
  void add_speed(int32_t speed) {
    fbb_.AddElement<int32_t>(FXInfo::VT_SPEED, speed, 0);
  }
  void add_fall_speed(int32_t fall_speed) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FALL_SPEED, fall_speed, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_counter(int32_t counter) {
    fbb_.AddElement<int32_t>(FXInfo::VT_COUNTER, counter, 0);
  }
  void add_color(const TEN::Save::Vector4 *color) {
    fbb_.AddStruct(FXInfo::VT_COLOR, color);
  }
  void add_flag1(int32_t flag1) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FLAG1, flag1, 0);
  }
  void add_flag2(int32_t flag2) {
    fbb_.AddElement<int32_t>(FXInfo::VT_FLAG2, flag2, 0);
  }
  explicit FXInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FXInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FXInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FXInfo> CreateFXInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Pose *pose = 0,
    int32_t room_number = 0,
    int32_t object_number = 0,
    int32_t next_fx = 0,
    int32_t next_active = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t frame_number = 0,
    int32_t counter = 0,
    const TEN::Save::Vector4 *color = 0,
    int32_t flag1 = 0,
    int32_t flag2 = 0) {
  FXInfoBuilder builder_(_fbb);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  builder_.add_color(color);
  builder_.add_counter(counter);
  builder_.add_frame_number(frame_number);
  builder_.add_fall_speed(fall_speed);
  builder_.add_speed(speed);
  builder_.add_next_active(next_active);
  builder_.add_next_fx(next_fx);
  builder_.add_object_number(object_number);
  builder_.add_room_number(room_number);
  builder_.add_pose(pose);
  return builder_.Finish();
}

struct FXInfo::Traits {
  using type = FXInfo;
  static auto constexpr Create = CreateFXInfo;
};

flatbuffers::Offset<FXInfo> CreateFXInfo(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AmmoInfoT : public flatbuffers::NativeTable {
  typedef AmmoInfo TableType;
  int32_t count = 0;
  bool is_infinite = false;
};

struct AmmoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AmmoInfoT NativeTableType;
  typedef AmmoInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_IS_INFINITE = 6
  };
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool is_infinite() const {
    return GetField<uint8_t>(VT_IS_INFINITE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_IS_INFINITE) &&
           verifier.EndTable();
  }
  AmmoInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AmmoInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AmmoInfoBuilder {
  typedef AmmoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(AmmoInfo::VT_COUNT, count, 0);
  }
  void add_is_infinite(bool is_infinite) {
    fbb_.AddElement<uint8_t>(AmmoInfo::VT_IS_INFINITE, static_cast<uint8_t>(is_infinite), 0);
  }
  explicit AmmoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AmmoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AmmoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count = 0,
    bool is_infinite = false) {
  AmmoInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_is_infinite(is_infinite);
  return builder_.Finish();
}

struct AmmoInfo::Traits {
  using type = AmmoInfo;
  static auto constexpr Create = CreateAmmoInfo;
};

flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HolsterInfoT : public flatbuffers::NativeTable {
  typedef HolsterInfo TableType;
  int32_t left_holster = 0;
  int32_t right_holster = 0;
  int32_t back_holster = 0;
};

struct HolsterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HolsterInfoT NativeTableType;
  typedef HolsterInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_HOLSTER = 4,
    VT_RIGHT_HOLSTER = 6,
    VT_BACK_HOLSTER = 8
  };
  int32_t left_holster() const {
    return GetField<int32_t>(VT_LEFT_HOLSTER, 0);
  }
  int32_t right_holster() const {
    return GetField<int32_t>(VT_RIGHT_HOLSTER, 0);
  }
  int32_t back_holster() const {
    return GetField<int32_t>(VT_BACK_HOLSTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_BACK_HOLSTER) &&
           verifier.EndTable();
  }
  HolsterInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HolsterInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HolsterInfoBuilder {
  typedef HolsterInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_holster(int32_t left_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_LEFT_HOLSTER, left_holster, 0);
  }
  void add_right_holster(int32_t right_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_RIGHT_HOLSTER, right_holster, 0);
  }
  void add_back_holster(int32_t back_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_BACK_HOLSTER, back_holster, 0);
  }
  explicit HolsterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HolsterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HolsterInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_holster = 0,
    int32_t right_holster = 0,
    int32_t back_holster = 0) {
  HolsterInfoBuilder builder_(_fbb);
  builder_.add_back_holster(back_holster);
  builder_.add_right_holster(right_holster);
  builder_.add_left_holster(left_holster);
  return builder_.Finish();
}

struct HolsterInfo::Traits {
  using type = HolsterInfo;
  static auto constexpr Create = CreateHolsterInfo;
};

flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CarriedWeaponInfoT : public flatbuffers::NativeTable {
  typedef CarriedWeaponInfo TableType;
  bool present = false;
  bool has_lasersight = false;
  bool has_silencer = false;
  std::vector<std::unique_ptr<TEN::Save::AmmoInfoT>> ammo{};
  int32_t selected_ammo = 0;
  int32_t weapon_mode = 0;
};

struct CarriedWeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CarriedWeaponInfoT NativeTableType;
  typedef CarriedWeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESENT = 4,
    VT_HAS_LASERSIGHT = 6,
    VT_HAS_SILENCER = 8,
    VT_AMMO = 10,
    VT_SELECTED_AMMO = 12,
    VT_WEAPON_MODE = 14
  };
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  bool has_lasersight() const {
    return GetField<uint8_t>(VT_HAS_LASERSIGHT, 0) != 0;
  }
  bool has_silencer() const {
    return GetField<uint8_t>(VT_HAS_SILENCER, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *>(VT_AMMO);
  }
  int32_t selected_ammo() const {
    return GetField<int32_t>(VT_SELECTED_AMMO, 0);
  }
  int32_t weapon_mode() const {
    return GetField<int32_t>(VT_WEAPON_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SILENCER) &&
           VerifyOffset(verifier, VT_AMMO) &&
           verifier.VerifyVector(ammo()) &&
           verifier.VerifyVectorOfTables(ammo()) &&
           VerifyField<int32_t>(verifier, VT_SELECTED_AMMO) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_MODE) &&
           verifier.EndTable();
  }
  CarriedWeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CarriedWeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CarriedWeaponInfoBuilder {
  typedef CarriedWeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  void add_has_lasersight(bool has_lasersight) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_LASERSIGHT, static_cast<uint8_t>(has_lasersight), 0);
  }
  void add_has_silencer(bool has_silencer) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_SILENCER, static_cast<uint8_t>(has_silencer), 0);
  }
  void add_ammo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo) {
    fbb_.AddOffset(CarriedWeaponInfo::VT_AMMO, ammo);
  }
  void add_selected_ammo(int32_t selected_ammo) {
    fbb_.AddElement<int32_t>(CarriedWeaponInfo::VT_SELECTED_AMMO, selected_ammo, 0);
  }
  void add_weapon_mode(int32_t weapon_mode) {
    fbb_.AddElement<int32_t>(CarriedWeaponInfo::VT_WEAPON_MODE, weapon_mode, 0);
  }
  explicit CarriedWeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CarriedWeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CarriedWeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo = 0,
    int32_t selected_ammo = 0,
    int32_t weapon_mode = 0) {
  CarriedWeaponInfoBuilder builder_(_fbb);
  builder_.add_weapon_mode(weapon_mode);
  builder_.add_selected_ammo(selected_ammo);
  builder_.add_ammo(ammo);
  builder_.add_has_silencer(has_silencer);
  builder_.add_has_lasersight(has_lasersight);
  builder_.add_present(present);
  return builder_.Finish();
}

struct CarriedWeaponInfo::Traits {
  using type = CarriedWeaponInfo;
  static auto constexpr Create = CreateCarriedWeaponInfo;
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    const std::vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo = nullptr,
    int32_t selected_ammo = 0,
    int32_t weapon_mode = 0) {
  auto ammo__ = ammo ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>>(*ammo) : 0;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      present,
      has_lasersight,
      has_silencer,
      ammo__,
      selected_ammo,
      weapon_mode);
}

flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponInfoT : public flatbuffers::NativeTable {
  typedef WeaponInfo TableType;
  uint32_t object_number = 0;
  uint32_t anim_number = 0;
  uint32_t frame_number = 0;
  uint32_t active_state = 0;
  uint32_t target_state = 0;
};

struct WeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponInfoT NativeTableType;
  typedef WeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NUMBER = 4,
    VT_ANIM_NUMBER = 6,
    VT_FRAME_NUMBER = 8,
    VT_ACTIVE_STATE = 10,
    VT_TARGET_STATE = 12
  };
  uint32_t object_number() const {
    return GetField<uint32_t>(VT_OBJECT_NUMBER, 0);
  }
  uint32_t anim_number() const {
    return GetField<uint32_t>(VT_ANIM_NUMBER, 0);
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  uint32_t active_state() const {
    return GetField<uint32_t>(VT_ACTIVE_STATE, 0);
  }
  uint32_t target_state() const {
    return GetField<uint32_t>(VT_TARGET_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_ACTIVE_STATE) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_STATE) &&
           verifier.EndTable();
  }
  WeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponInfoBuilder {
  typedef WeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_number(uint32_t object_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_anim_number(uint32_t anim_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_active_state(uint32_t active_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_ACTIVE_STATE, active_state, 0);
  }
  void add_target_state(uint32_t target_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_TARGET_STATE, target_state, 0);
  }
  explicit WeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_number = 0,
    uint32_t anim_number = 0,
    uint32_t frame_number = 0,
    uint32_t active_state = 0,
    uint32_t target_state = 0) {
  WeaponInfoBuilder builder_(_fbb);
  builder_.add_target_state(target_state);
  builder_.add_active_state(active_state);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_object_number(object_number);
  return builder_.Finish();
}

struct WeaponInfo::Traits {
  using type = WeaponInfo;
  static auto constexpr Create = CreateWeaponInfo;
};

flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArmInfoT : public flatbuffers::NativeTable {
  typedef ArmInfo TableType;
  int32_t anim_number = 0;
  int32_t frame_number = 0;
  int32_t frame_base = 0;
  bool locked = false;
  std::unique_ptr<TEN::Save::EulerAngles> rotation{};
  int32_t gun_flash = 0;
  int32_t gun_smoke = 0;
};

struct ArmInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArmInfoT NativeTableType;
  typedef ArmInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIM_NUMBER = 4,
    VT_FRAME_NUMBER = 6,
    VT_FRAME_BASE = 8,
    VT_LOCKED = 10,
    VT_ROTATION = 12,
    VT_GUN_FLASH = 14,
    VT_GUN_SMOKE = 16
  };
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t frame_base() const {
    return GetField<int32_t>(VT_FRAME_BASE, 0);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  const TEN::Save::EulerAngles *rotation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_ROTATION);
  }
  int32_t gun_flash() const {
    return GetField<int32_t>(VT_GUN_FLASH, 0);
  }
  int32_t gun_smoke() const {
    return GetField<int32_t>(VT_GUN_SMOKE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_BASE) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_ROTATION) &&
           VerifyField<int32_t>(verifier, VT_GUN_FLASH) &&
           VerifyField<int32_t>(verifier, VT_GUN_SMOKE) &&
           verifier.EndTable();
  }
  ArmInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArmInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArmInfoBuilder {
  typedef ArmInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_frame_base(int32_t frame_base) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_FRAME_BASE, frame_base, 0);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(ArmInfo::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  void add_rotation(const TEN::Save::EulerAngles *rotation) {
    fbb_.AddStruct(ArmInfo::VT_ROTATION, rotation);
  }
  void add_gun_flash(int32_t gun_flash) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_GUN_FLASH, gun_flash, 0);
  }
  void add_gun_smoke(int32_t gun_smoke) {
    fbb_.AddElement<int32_t>(ArmInfo::VT_GUN_SMOKE, gun_smoke, 0);
  }
  explicit ArmInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArmInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArmInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArmInfo> CreateArmInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t frame_base = 0,
    bool locked = false,
    const TEN::Save::EulerAngles *rotation = 0,
    int32_t gun_flash = 0,
    int32_t gun_smoke = 0) {
  ArmInfoBuilder builder_(_fbb);
  builder_.add_gun_smoke(gun_smoke);
  builder_.add_gun_flash(gun_flash);
  builder_.add_rotation(rotation);
  builder_.add_frame_base(frame_base);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_locked(locked);
  return builder_.Finish();
}

struct ArmInfo::Traits {
  using type = ArmInfo;
  static auto constexpr Create = CreateArmInfo;
};

flatbuffers::Offset<ArmInfo> CreateArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlareDataT : public flatbuffers::NativeTable {
  typedef FlareData TableType;
  uint32_t life = 0;
  int32_t frame = 0;
  bool control_left = false;
};

struct FlareData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlareDataT NativeTableType;
  typedef FlareDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIFE = 4,
    VT_FRAME = 6,
    VT_CONTROL_LEFT = 8
  };
  uint32_t life() const {
    return GetField<uint32_t>(VT_LIFE, 0);
  }
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  bool control_left() const {
    return GetField<uint8_t>(VT_CONTROL_LEFT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_CONTROL_LEFT) &&
           verifier.EndTable();
  }
  FlareDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlareDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlareData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlareDataBuilder {
  typedef FlareData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_life(uint32_t life) {
    fbb_.AddElement<uint32_t>(FlareData::VT_LIFE, life, 0);
  }
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(FlareData::VT_FRAME, frame, 0);
  }
  void add_control_left(bool control_left) {
    fbb_.AddElement<uint8_t>(FlareData::VT_CONTROL_LEFT, static_cast<uint8_t>(control_left), 0);
  }
  explicit FlareDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlareData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlareData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlareData> CreateFlareData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t life = 0,
    int32_t frame = 0,
    bool control_left = false) {
  FlareDataBuilder builder_(_fbb);
  builder_.add_frame(frame);
  builder_.add_life(life);
  builder_.add_control_left(control_left);
  return builder_.Finish();
}

struct FlareData::Traits {
  using type = FlareData;
  static auto constexpr Create = CreateFlareData;
};

flatbuffers::Offset<FlareData> CreateFlareData(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TorchDataT : public flatbuffers::NativeTable {
  typedef TorchData TableType;
  TEN::Save::TorchState state = TEN::Save::TorchState::holding;
  bool is_lit = false;
};

struct TorchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TorchDataT NativeTableType;
  typedef TorchDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_IS_LIT = 6
  };
  TEN::Save::TorchState state() const {
    return static_cast<TEN::Save::TorchState>(GetField<int32_t>(VT_STATE, 0));
  }
  bool is_lit() const {
    return GetField<uint8_t>(VT_IS_LIT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<uint8_t>(verifier, VT_IS_LIT) &&
           verifier.EndTable();
  }
  TorchDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TorchDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TorchData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TorchDataBuilder {
  typedef TorchData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(TEN::Save::TorchState state) {
    fbb_.AddElement<int32_t>(TorchData::VT_STATE, static_cast<int32_t>(state), 0);
  }
  void add_is_lit(bool is_lit) {
    fbb_.AddElement<uint8_t>(TorchData::VT_IS_LIT, static_cast<uint8_t>(is_lit), 0);
  }
  explicit TorchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TorchData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TorchData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TorchData> CreateTorchData(
    flatbuffers::FlatBufferBuilder &_fbb,
    TEN::Save::TorchState state = TEN::Save::TorchState::holding,
    bool is_lit = false) {
  TorchDataBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_is_lit(is_lit);
  return builder_.Finish();
}

struct TorchData::Traits {
  using type = TorchData;
  static auto constexpr Create = CreateTorchData;
};

flatbuffers::Offset<TorchData> CreateTorchData(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraInventoryDataT : public flatbuffers::NativeTable {
  typedef LaraInventoryData TableType;
  bool is_busy = false;
  bool old_busy = false;
  int32_t beetle_life = 0;
  int32_t beetle_components = 0;
  int32_t small_waterskin = 0;
  int32_t big_waterskin = 0;
  bool has_binoculars = false;
  bool has_compass = false;
  bool has_stopwatch = false;
  bool has_diary = false;
  bool has_load = false;
  bool has_save = false;
  bool has_crowbar = false;
  bool has_torch = false;
  bool has_lasersight = false;
  bool has_silencer = false;
  int32_t total_small_medipacks = 0;
  int32_t total_large_medipacks = 0;
  int32_t total_flares = 0;
  uint32_t total_secrets = 0;
  std::vector<int32_t> puzzles{};
  std::vector<int32_t> keys{};
  std::vector<int32_t> pickups{};
  std::vector<int32_t> examines{};
  std::vector<int32_t> puzzles_combo{};
  std::vector<int32_t> keys_combo{};
  std::vector<int32_t> pickups_combo{};
  std::vector<int32_t> examines_combo{};
};

struct LaraInventoryData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraInventoryDataT NativeTableType;
  typedef LaraInventoryDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_BUSY = 4,
    VT_OLD_BUSY = 6,
    VT_BEETLE_LIFE = 8,
    VT_BEETLE_COMPONENTS = 10,
    VT_SMALL_WATERSKIN = 12,
    VT_BIG_WATERSKIN = 14,
    VT_HAS_BINOCULARS = 16,
    VT_HAS_COMPASS = 18,
    VT_HAS_STOPWATCH = 20,
    VT_HAS_DIARY = 22,
    VT_HAS_LOAD = 24,
    VT_HAS_SAVE = 26,
    VT_HAS_CROWBAR = 28,
    VT_HAS_TORCH = 30,
    VT_HAS_LASERSIGHT = 32,
    VT_HAS_SILENCER = 34,
    VT_TOTAL_SMALL_MEDIPACKS = 36,
    VT_TOTAL_LARGE_MEDIPACKS = 38,
    VT_TOTAL_FLARES = 40,
    VT_TOTAL_SECRETS = 42,
    VT_PUZZLES = 44,
    VT_KEYS = 46,
    VT_PICKUPS = 48,
    VT_EXAMINES = 50,
    VT_PUZZLES_COMBO = 52,
    VT_KEYS_COMBO = 54,
    VT_PICKUPS_COMBO = 56,
    VT_EXAMINES_COMBO = 58
  };
  bool is_busy() const {
    return GetField<uint8_t>(VT_IS_BUSY, 0) != 0;
  }
  bool old_busy() const {
    return GetField<uint8_t>(VT_OLD_BUSY, 0) != 0;
  }
  int32_t beetle_life() const {
    return GetField<int32_t>(VT_BEETLE_LIFE, 0);
  }
  int32_t beetle_components() const {
    return GetField<int32_t>(VT_BEETLE_COMPONENTS, 0);
  }
  int32_t small_waterskin() const {
    return GetField<int32_t>(VT_SMALL_WATERSKIN, 0);
  }
  int32_t big_waterskin() const {
    return GetField<int32_t>(VT_BIG_WATERSKIN, 0);
  }
  bool has_binoculars() const {
    return GetField<uint8_t>(VT_HAS_BINOCULARS, 0) != 0;
  }
  bool has_compass() const {
    return GetField<uint8_t>(VT_HAS_COMPASS, 0) != 0;
  }
  bool has_stopwatch() const {
    return GetField<uint8_t>(VT_HAS_STOPWATCH, 0) != 0;
  }
  bool has_diary() const {
    return GetField<uint8_t>(VT_HAS_DIARY, 0) != 0;
  }
  bool has_load() const {
    return GetField<uint8_t>(VT_HAS_LOAD, 0) != 0;
  }
  bool has_save() const {
    return GetField<uint8_t>(VT_HAS_SAVE, 0) != 0;
  }
  bool has_crowbar() const {
    return GetField<uint8_t>(VT_HAS_CROWBAR, 0) != 0;
  }
  bool has_torch() const {
    return GetField<uint8_t>(VT_HAS_TORCH, 0) != 0;
  }
  bool has_lasersight() const {
    return GetField<uint8_t>(VT_HAS_LASERSIGHT, 0) != 0;
  }
  bool has_silencer() const {
    return GetField<uint8_t>(VT_HAS_SILENCER, 0) != 0;
  }
  int32_t total_small_medipacks() const {
    return GetField<int32_t>(VT_TOTAL_SMALL_MEDIPACKS, 0);
  }
  int32_t total_large_medipacks() const {
    return GetField<int32_t>(VT_TOTAL_LARGE_MEDIPACKS, 0);
  }
  int32_t total_flares() const {
    return GetField<int32_t>(VT_TOTAL_FLARES, 0);
  }
  uint32_t total_secrets() const {
    return GetField<uint32_t>(VT_TOTAL_SECRETS, 0);
  }
  const flatbuffers::Vector<int32_t> *puzzles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES);
  }
  const flatbuffers::Vector<int32_t> *keys() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS);
  }
  const flatbuffers::Vector<int32_t> *pickups() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS);
  }
  const flatbuffers::Vector<int32_t> *examines() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES);
  }
  const flatbuffers::Vector<int32_t> *puzzles_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES_COMBO);
  }
  const flatbuffers::Vector<int32_t> *keys_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *pickups_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *examines_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES_COMBO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_BUSY) &&
           VerifyField<uint8_t>(verifier, VT_OLD_BUSY) &&
           VerifyField<int32_t>(verifier, VT_BEETLE_LIFE) &&
           VerifyField<int32_t>(verifier, VT_BEETLE_COMPONENTS) &&
           VerifyField<int32_t>(verifier, VT_SMALL_WATERSKIN) &&
           VerifyField<int32_t>(verifier, VT_BIG_WATERSKIN) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BINOCULARS) &&
           VerifyField<uint8_t>(verifier, VT_HAS_COMPASS) &&
           VerifyField<uint8_t>(verifier, VT_HAS_STOPWATCH) &&
           VerifyField<uint8_t>(verifier, VT_HAS_DIARY) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LOAD) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SAVE) &&
           VerifyField<uint8_t>(verifier, VT_HAS_CROWBAR) &&
           VerifyField<uint8_t>(verifier, VT_HAS_TORCH) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SILENCER) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_SMALL_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_LARGE_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_FLARES) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SECRETS) &&
           VerifyOffset(verifier, VT_PUZZLES) &&
           verifier.VerifyVector(puzzles()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_PICKUPS) &&
           verifier.VerifyVector(pickups()) &&
           VerifyOffset(verifier, VT_EXAMINES) &&
           verifier.VerifyVector(examines()) &&
           VerifyOffset(verifier, VT_PUZZLES_COMBO) &&
           verifier.VerifyVector(puzzles_combo()) &&
           VerifyOffset(verifier, VT_KEYS_COMBO) &&
           verifier.VerifyVector(keys_combo()) &&
           VerifyOffset(verifier, VT_PICKUPS_COMBO) &&
           verifier.VerifyVector(pickups_combo()) &&
           VerifyOffset(verifier, VT_EXAMINES_COMBO) &&
           verifier.VerifyVector(examines_combo()) &&
           verifier.EndTable();
  }
  LaraInventoryDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraInventoryDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraInventoryData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraInventoryDataBuilder {
  typedef LaraInventoryData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_busy(bool is_busy) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_IS_BUSY, static_cast<uint8_t>(is_busy), 0);
  }
  void add_old_busy(bool old_busy) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_OLD_BUSY, static_cast<uint8_t>(old_busy), 0);
  }
  void add_beetle_life(int32_t beetle_life) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BEETLE_LIFE, beetle_life, 0);
  }
  void add_beetle_components(int32_t beetle_components) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BEETLE_COMPONENTS, beetle_components, 0);
  }
  void add_small_waterskin(int32_t small_waterskin) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_SMALL_WATERSKIN, small_waterskin, 0);
  }
  void add_big_waterskin(int32_t big_waterskin) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_BIG_WATERSKIN, big_waterskin, 0);
  }
  void add_has_binoculars(bool has_binoculars) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_BINOCULARS, static_cast<uint8_t>(has_binoculars), 0);
  }
  void add_has_compass(bool has_compass) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_COMPASS, static_cast<uint8_t>(has_compass), 0);
  }
  void add_has_stopwatch(bool has_stopwatch) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_STOPWATCH, static_cast<uint8_t>(has_stopwatch), 0);
  }
  void add_has_diary(bool has_diary) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_DIARY, static_cast<uint8_t>(has_diary), 0);
  }
  void add_has_load(bool has_load) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_LOAD, static_cast<uint8_t>(has_load), 0);
  }
  void add_has_save(bool has_save) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_SAVE, static_cast<uint8_t>(has_save), 0);
  }
  void add_has_crowbar(bool has_crowbar) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_CROWBAR, static_cast<uint8_t>(has_crowbar), 0);
  }
  void add_has_torch(bool has_torch) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_TORCH, static_cast<uint8_t>(has_torch), 0);
  }
  void add_has_lasersight(bool has_lasersight) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_LASERSIGHT, static_cast<uint8_t>(has_lasersight), 0);
  }
  void add_has_silencer(bool has_silencer) {
    fbb_.AddElement<uint8_t>(LaraInventoryData::VT_HAS_SILENCER, static_cast<uint8_t>(has_silencer), 0);
  }
  void add_total_small_medipacks(int32_t total_small_medipacks) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_SMALL_MEDIPACKS, total_small_medipacks, 0);
  }
  void add_total_large_medipacks(int32_t total_large_medipacks) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_LARGE_MEDIPACKS, total_large_medipacks, 0);
  }
  void add_total_flares(int32_t total_flares) {
    fbb_.AddElement<int32_t>(LaraInventoryData::VT_TOTAL_FLARES, total_flares, 0);
  }
  void add_total_secrets(uint32_t total_secrets) {
    fbb_.AddElement<uint32_t>(LaraInventoryData::VT_TOTAL_SECRETS, total_secrets, 0);
  }
  void add_puzzles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles) {
    fbb_.AddOffset(LaraInventoryData::VT_PUZZLES, puzzles);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys) {
    fbb_.AddOffset(LaraInventoryData::VT_KEYS, keys);
  }
  void add_pickups(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups) {
    fbb_.AddOffset(LaraInventoryData::VT_PICKUPS, pickups);
  }
  void add_examines(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines) {
    fbb_.AddOffset(LaraInventoryData::VT_EXAMINES, examines);
  }
  void add_puzzles_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_PUZZLES_COMBO, puzzles_combo);
  }
  void add_keys_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_KEYS_COMBO, keys_combo);
  }
  void add_pickups_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_PICKUPS_COMBO, pickups_combo);
  }
  void add_examines_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo) {
    fbb_.AddOffset(LaraInventoryData::VT_EXAMINES_COMBO, examines_combo);
  }
  explicit LaraInventoryDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraInventoryData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraInventoryData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_busy = false,
    bool old_busy = false,
    int32_t beetle_life = 0,
    int32_t beetle_components = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    bool has_binoculars = false,
    bool has_compass = false,
    bool has_stopwatch = false,
    bool has_diary = false,
    bool has_load = false,
    bool has_save = false,
    bool has_crowbar = false,
    bool has_torch = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    int32_t total_small_medipacks = 0,
    int32_t total_large_medipacks = 0,
    int32_t total_flares = 0,
    uint32_t total_secrets = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo = 0) {
  LaraInventoryDataBuilder builder_(_fbb);
  builder_.add_examines_combo(examines_combo);
  builder_.add_pickups_combo(pickups_combo);
  builder_.add_keys_combo(keys_combo);
  builder_.add_puzzles_combo(puzzles_combo);
  builder_.add_examines(examines);
  builder_.add_pickups(pickups);
  builder_.add_keys(keys);
  builder_.add_puzzles(puzzles);
  builder_.add_total_secrets(total_secrets);
  builder_.add_total_flares(total_flares);
  builder_.add_total_large_medipacks(total_large_medipacks);
  builder_.add_total_small_medipacks(total_small_medipacks);
  builder_.add_big_waterskin(big_waterskin);
  builder_.add_small_waterskin(small_waterskin);
  builder_.add_beetle_components(beetle_components);
  builder_.add_beetle_life(beetle_life);
  builder_.add_has_silencer(has_silencer);
  builder_.add_has_lasersight(has_lasersight);
  builder_.add_has_torch(has_torch);
  builder_.add_has_crowbar(has_crowbar);
  builder_.add_has_save(has_save);
  builder_.add_has_load(has_load);
  builder_.add_has_diary(has_diary);
  builder_.add_has_stopwatch(has_stopwatch);
  builder_.add_has_compass(has_compass);
  builder_.add_has_binoculars(has_binoculars);
  builder_.add_old_busy(old_busy);
  builder_.add_is_busy(is_busy);
  return builder_.Finish();
}

struct LaraInventoryData::Traits {
  using type = LaraInventoryData;
  static auto constexpr Create = CreateLaraInventoryData;
};

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_busy = false,
    bool old_busy = false,
    int32_t beetle_life = 0,
    int32_t beetle_components = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    bool has_binoculars = false,
    bool has_compass = false,
    bool has_stopwatch = false,
    bool has_diary = false,
    bool has_load = false,
    bool has_save = false,
    bool has_crowbar = false,
    bool has_torch = false,
    bool has_lasersight = false,
    bool has_silencer = false,
    int32_t total_small_medipacks = 0,
    int32_t total_large_medipacks = 0,
    int32_t total_flares = 0,
    uint32_t total_secrets = 0,
    const std::vector<int32_t> *puzzles = nullptr,
    const std::vector<int32_t> *keys = nullptr,
    const std::vector<int32_t> *pickups = nullptr,
    const std::vector<int32_t> *examines = nullptr,
    const std::vector<int32_t> *puzzles_combo = nullptr,
    const std::vector<int32_t> *keys_combo = nullptr,
    const std::vector<int32_t> *pickups_combo = nullptr,
    const std::vector<int32_t> *examines_combo = nullptr) {
  auto puzzles__ = puzzles ? _fbb.CreateVector<int32_t>(*puzzles) : 0;
  auto keys__ = keys ? _fbb.CreateVector<int32_t>(*keys) : 0;
  auto pickups__ = pickups ? _fbb.CreateVector<int32_t>(*pickups) : 0;
  auto examines__ = examines ? _fbb.CreateVector<int32_t>(*examines) : 0;
  auto puzzles_combo__ = puzzles_combo ? _fbb.CreateVector<int32_t>(*puzzles_combo) : 0;
  auto keys_combo__ = keys_combo ? _fbb.CreateVector<int32_t>(*keys_combo) : 0;
  auto pickups_combo__ = pickups_combo ? _fbb.CreateVector<int32_t>(*pickups_combo) : 0;
  auto examines_combo__ = examines_combo ? _fbb.CreateVector<int32_t>(*examines_combo) : 0;
  return TEN::Save::CreateLaraInventoryData(
      _fbb,
      is_busy,
      old_busy,
      beetle_life,
      beetle_components,
      small_waterskin,
      big_waterskin,
      has_binoculars,
      has_compass,
      has_stopwatch,
      has_diary,
      has_load,
      has_save,
      has_crowbar,
      has_torch,
      has_lasersight,
      has_silencer,
      total_small_medipacks,
      total_large_medipacks,
      total_flares,
      total_secrets,
      puzzles__,
      keys__,
      pickups__,
      examines__,
      puzzles_combo__,
      keys_combo__,
      pickups_combo__,
      examines_combo__);
}

flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraCountDataT : public flatbuffers::NativeTable {
  typedef LaraCountData TableType;
  uint32_t run_jump = 0;
  uint32_t position_adjust = 0;
  uint32_t pose = 0;
  uint32_t death = 0;
  uint32_t no_cheat = 0;
};

struct LaraCountData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraCountDataT NativeTableType;
  typedef LaraCountDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RUN_JUMP = 4,
    VT_POSITION_ADJUST = 6,
    VT_POSE = 8,
    VT_DEATH = 10,
    VT_NO_CHEAT = 12
  };
  uint32_t run_jump() const {
    return GetField<uint32_t>(VT_RUN_JUMP, 0);
  }
  uint32_t position_adjust() const {
    return GetField<uint32_t>(VT_POSITION_ADJUST, 0);
  }
  uint32_t pose() const {
    return GetField<uint32_t>(VT_POSE, 0);
  }
  uint32_t death() const {
    return GetField<uint32_t>(VT_DEATH, 0);
  }
  uint32_t no_cheat() const {
    return GetField<uint32_t>(VT_NO_CHEAT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RUN_JUMP) &&
           VerifyField<uint32_t>(verifier, VT_POSITION_ADJUST) &&
           VerifyField<uint32_t>(verifier, VT_POSE) &&
           VerifyField<uint32_t>(verifier, VT_DEATH) &&
           VerifyField<uint32_t>(verifier, VT_NO_CHEAT) &&
           verifier.EndTable();
  }
  LaraCountDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraCountDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraCountData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraCountDataBuilder {
  typedef LaraCountData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_run_jump(uint32_t run_jump) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_RUN_JUMP, run_jump, 0);
  }
  void add_position_adjust(uint32_t position_adjust) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_POSITION_ADJUST, position_adjust, 0);
  }
  void add_pose(uint32_t pose) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_POSE, pose, 0);
  }
  void add_death(uint32_t death) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_DEATH, death, 0);
  }
  void add_no_cheat(uint32_t no_cheat) {
    fbb_.AddElement<uint32_t>(LaraCountData::VT_NO_CHEAT, no_cheat, 0);
  }
  explicit LaraCountDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraCountData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraCountData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraCountData> CreateLaraCountData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t run_jump = 0,
    uint32_t position_adjust = 0,
    uint32_t pose = 0,
    uint32_t death = 0,
    uint32_t no_cheat = 0) {
  LaraCountDataBuilder builder_(_fbb);
  builder_.add_no_cheat(no_cheat);
  builder_.add_death(death);
  builder_.add_pose(pose);
  builder_.add_position_adjust(position_adjust);
  builder_.add_run_jump(run_jump);
  return builder_.Finish();
}

struct LaraCountData::Traits {
  using type = LaraCountData;
  static auto constexpr Create = CreateLaraCountData;
};

flatbuffers::Offset<LaraCountData> CreateLaraCountData(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookControlDataT : public flatbuffers::NativeTable {
  typedef LookControlData TableType;
  bool is_using_binoculars = false;
  bool is_using_lasersight = false;
  int32_t mode = 0;
  int32_t optic_range = 0;
  std::unique_ptr<TEN::Save::EulerAngles> orientation{};
  std::unique_ptr<TEN::Save::EulerAngles> turn_rate{};
};

struct LookControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LookControlDataT NativeTableType;
  typedef LookControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_USING_BINOCULARS = 4,
    VT_IS_USING_LASERSIGHT = 6,
    VT_MODE = 8,
    VT_OPTIC_RANGE = 10,
    VT_ORIENTATION = 12,
    VT_TURN_RATE = 14
  };
  bool is_using_binoculars() const {
    return GetField<uint8_t>(VT_IS_USING_BINOCULARS, 0) != 0;
  }
  bool is_using_lasersight() const {
    return GetField<uint8_t>(VT_IS_USING_LASERSIGHT, 0) != 0;
  }
  int32_t mode() const {
    return GetField<int32_t>(VT_MODE, 0);
  }
  int32_t optic_range() const {
    return GetField<int32_t>(VT_OPTIC_RANGE, 0);
  }
  const TEN::Save::EulerAngles *orientation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_ORIENTATION);
  }
  const TEN::Save::EulerAngles *turn_rate() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_TURN_RATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_USING_BINOCULARS) &&
           VerifyField<uint8_t>(verifier, VT_IS_USING_LASERSIGHT) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           VerifyField<int32_t>(verifier, VT_OPTIC_RANGE) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_ORIENTATION) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_TURN_RATE) &&
           verifier.EndTable();
  }
  LookControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LookControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LookControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookControlDataBuilder {
  typedef LookControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_using_binoculars(bool is_using_binoculars) {
    fbb_.AddElement<uint8_t>(LookControlData::VT_IS_USING_BINOCULARS, static_cast<uint8_t>(is_using_binoculars), 0);
  }
  void add_is_using_lasersight(bool is_using_lasersight) {
    fbb_.AddElement<uint8_t>(LookControlData::VT_IS_USING_LASERSIGHT, static_cast<uint8_t>(is_using_lasersight), 0);
  }
  void add_mode(int32_t mode) {
    fbb_.AddElement<int32_t>(LookControlData::VT_MODE, mode, 0);
  }
  void add_optic_range(int32_t optic_range) {
    fbb_.AddElement<int32_t>(LookControlData::VT_OPTIC_RANGE, optic_range, 0);
  }
  void add_orientation(const TEN::Save::EulerAngles *orientation) {
    fbb_.AddStruct(LookControlData::VT_ORIENTATION, orientation);
  }
  void add_turn_rate(const TEN::Save::EulerAngles *turn_rate) {
    fbb_.AddStruct(LookControlData::VT_TURN_RATE, turn_rate);
  }
  explicit LookControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LookControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LookControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LookControlData> CreateLookControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_using_binoculars = false,
    bool is_using_lasersight = false,
    int32_t mode = 0,
    int32_t optic_range = 0,
    const TEN::Save::EulerAngles *orientation = 0,
    const TEN::Save::EulerAngles *turn_rate = 0) {
  LookControlDataBuilder builder_(_fbb);
  builder_.add_turn_rate(turn_rate);
  builder_.add_orientation(orientation);
  builder_.add_optic_range(optic_range);
  builder_.add_mode(mode);
  builder_.add_is_using_lasersight(is_using_lasersight);
  builder_.add_is_using_binoculars(is_using_binoculars);
  return builder_.Finish();
}

struct LookControlData::Traits {
  using type = LookControlData;
  static auto constexpr Create = CreateLookControlData;
};

flatbuffers::Offset<LookControlData> CreateLookControlData(flatbuffers::FlatBufferBuilder &_fbb, const LookControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeControlDataT : public flatbuffers::NativeTable {
  typedef RopeControlData TableType;
  int32_t segment = 0;
  int32_t direction = 0;
  int32_t arc_front = 0;
  int32_t arc_back = 0;
  int32_t last_x = 0;
  int32_t max_x_forward = 0;
  int32_t max_x_backward = 0;
  int32_t dframe = 0;
  int32_t frame = 0;
  int32_t frame_rate = 0;
  int32_t y = 0;
  int32_t ptr = 0;
  int32_t offset = 0;
  int32_t down_vel = 0;
  int32_t flag = 0;
  int32_t count = 0;
};

struct RopeControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeControlDataT NativeTableType;
  typedef RopeControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4,
    VT_DIRECTION = 6,
    VT_ARC_FRONT = 8,
    VT_ARC_BACK = 10,
    VT_LAST_X = 12,
    VT_MAX_X_FORWARD = 14,
    VT_MAX_X_BACKWARD = 16,
    VT_DFRAME = 18,
    VT_FRAME = 20,
    VT_FRAME_RATE = 22,
    VT_Y = 24,
    VT_PTR = 26,
    VT_OFFSET = 28,
    VT_DOWN_VEL = 30,
    VT_FLAG = 32,
    VT_COUNT = 34
  };
  int32_t segment() const {
    return GetField<int32_t>(VT_SEGMENT, 0);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  int32_t arc_front() const {
    return GetField<int32_t>(VT_ARC_FRONT, 0);
  }
  int32_t arc_back() const {
    return GetField<int32_t>(VT_ARC_BACK, 0);
  }
  int32_t last_x() const {
    return GetField<int32_t>(VT_LAST_X, 0);
  }
  int32_t max_x_forward() const {
    return GetField<int32_t>(VT_MAX_X_FORWARD, 0);
  }
  int32_t max_x_backward() const {
    return GetField<int32_t>(VT_MAX_X_BACKWARD, 0);
  }
  int32_t dframe() const {
    return GetField<int32_t>(VT_DFRAME, 0);
  }
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  int32_t frame_rate() const {
    return GetField<int32_t>(VT_FRAME_RATE, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t ptr() const {
    return GetField<int32_t>(VT_PTR, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  int32_t down_vel() const {
    return GetField<int32_t>(VT_DOWN_VEL, 0);
  }
  int32_t flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEGMENT) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_ARC_FRONT) &&
           VerifyField<int32_t>(verifier, VT_ARC_BACK) &&
           VerifyField<int32_t>(verifier, VT_LAST_X) &&
           VerifyField<int32_t>(verifier, VT_MAX_X_FORWARD) &&
           VerifyField<int32_t>(verifier, VT_MAX_X_BACKWARD) &&
           VerifyField<int32_t>(verifier, VT_DFRAME) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_FRAME_RATE) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_PTR) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_DOWN_VEL) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  RopeControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RopeControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeControlDataBuilder {
  typedef RopeControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(int32_t segment) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_SEGMENT, segment, 0);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DIRECTION, direction, 0);
  }
  void add_arc_front(int32_t arc_front) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_ARC_FRONT, arc_front, 0);
  }
  void add_arc_back(int32_t arc_back) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_ARC_BACK, arc_back, 0);
  }
  void add_last_x(int32_t last_x) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_LAST_X, last_x, 0);
  }
  void add_max_x_forward(int32_t max_x_forward) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_MAX_X_FORWARD, max_x_forward, 0);
  }
  void add_max_x_backward(int32_t max_x_backward) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_MAX_X_BACKWARD, max_x_backward, 0);
  }
  void add_dframe(int32_t dframe) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DFRAME, dframe, 0);
  }
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FRAME, frame, 0);
  }
  void add_frame_rate(int32_t frame_rate) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FRAME_RATE, frame_rate, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_Y, y, 0);
  }
  void add_ptr(int32_t ptr) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_PTR, ptr, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_OFFSET, offset, 0);
  }
  void add_down_vel(int32_t down_vel) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_DOWN_VEL, down_vel, 0);
  }
  void add_flag(int32_t flag) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_FLAG, flag, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(RopeControlData::VT_COUNT, count, 0);
  }
  explicit RopeControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RopeControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RopeControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RopeControlData> CreateRopeControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t segment = 0,
    int32_t direction = 0,
    int32_t arc_front = 0,
    int32_t arc_back = 0,
    int32_t last_x = 0,
    int32_t max_x_forward = 0,
    int32_t max_x_backward = 0,
    int32_t dframe = 0,
    int32_t frame = 0,
    int32_t frame_rate = 0,
    int32_t y = 0,
    int32_t ptr = 0,
    int32_t offset = 0,
    int32_t down_vel = 0,
    int32_t flag = 0,
    int32_t count = 0) {
  RopeControlDataBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_flag(flag);
  builder_.add_down_vel(down_vel);
  builder_.add_offset(offset);
  builder_.add_ptr(ptr);
  builder_.add_y(y);
  builder_.add_frame_rate(frame_rate);
  builder_.add_frame(frame);
  builder_.add_dframe(dframe);
  builder_.add_max_x_backward(max_x_backward);
  builder_.add_max_x_forward(max_x_forward);
  builder_.add_last_x(last_x);
  builder_.add_arc_back(arc_back);
  builder_.add_arc_front(arc_front);
  builder_.add_direction(direction);
  builder_.add_segment(segment);
  return builder_.Finish();
}

struct RopeControlData::Traits {
  using type = RopeControlData;
  static auto constexpr Create = CreateRopeControlData;
};

flatbuffers::Offset<RopeControlData> CreateRopeControlData(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubsuitControlDataT : public flatbuffers::NativeTable {
  typedef SubsuitControlData TableType;
  int32_t x_rot = 0;
  int32_t d_x_rot = 0;
  std::vector<int32_t> velocity{};
  int32_t vertical_velocity = 0;
  int32_t x_rot_vel = 0;
  uint32_t hit_count = 0;
};

struct SubsuitControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubsuitControlDataT NativeTableType;
  typedef SubsuitControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_ROT = 4,
    VT_D_X_ROT = 6,
    VT_VELOCITY = 8,
    VT_VERTICAL_VELOCITY = 10,
    VT_X_ROT_VEL = 12,
    VT_HIT_COUNT = 14
  };
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t d_x_rot() const {
    return GetField<int32_t>(VT_D_X_ROT, 0);
  }
  const flatbuffers::Vector<int32_t> *velocity() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VELOCITY);
  }
  int32_t vertical_velocity() const {
    return GetField<int32_t>(VT_VERTICAL_VELOCITY, 0);
  }
  int32_t x_rot_vel() const {
    return GetField<int32_t>(VT_X_ROT_VEL, 0);
  }
  uint32_t hit_count() const {
    return GetField<uint32_t>(VT_HIT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_D_X_ROT) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyVector(velocity()) &&
           VerifyField<int32_t>(verifier, VT_VERTICAL_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_X_ROT_VEL) &&
           VerifyField<uint32_t>(verifier, VT_HIT_COUNT) &&
           verifier.EndTable();
  }
  SubsuitControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubsuitControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubsuitControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubsuitControlDataBuilder {
  typedef SubsuitControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_X_ROT, x_rot, 0);
  }
  void add_d_x_rot(int32_t d_x_rot) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_D_X_ROT, d_x_rot, 0);
  }
  void add_velocity(flatbuffers::Offset<flatbuffers::Vector<int32_t>> velocity) {
    fbb_.AddOffset(SubsuitControlData::VT_VELOCITY, velocity);
  }
  void add_vertical_velocity(int32_t vertical_velocity) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_VERTICAL_VELOCITY, vertical_velocity, 0);
  }
  void add_x_rot_vel(int32_t x_rot_vel) {
    fbb_.AddElement<int32_t>(SubsuitControlData::VT_X_ROT_VEL, x_rot_vel, 0);
  }
  void add_hit_count(uint32_t hit_count) {
    fbb_.AddElement<uint32_t>(SubsuitControlData::VT_HIT_COUNT, hit_count, 0);
  }
  explicit SubsuitControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubsuitControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubsuitControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_rot = 0,
    int32_t d_x_rot = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> velocity = 0,
    int32_t vertical_velocity = 0,
    int32_t x_rot_vel = 0,
    uint32_t hit_count = 0) {
  SubsuitControlDataBuilder builder_(_fbb);
  builder_.add_hit_count(hit_count);
  builder_.add_x_rot_vel(x_rot_vel);
  builder_.add_vertical_velocity(vertical_velocity);
  builder_.add_velocity(velocity);
  builder_.add_d_x_rot(d_x_rot);
  builder_.add_x_rot(x_rot);
  return builder_.Finish();
}

struct SubsuitControlData::Traits {
  using type = SubsuitControlData;
  static auto constexpr Create = CreateSubsuitControlData;
};

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_rot = 0,
    int32_t d_x_rot = 0,
    const std::vector<int32_t> *velocity = nullptr,
    int32_t vertical_velocity = 0,
    int32_t x_rot_vel = 0,
    uint32_t hit_count = 0) {
  auto velocity__ = velocity ? _fbb.CreateVector<int32_t>(*velocity) : 0;
  return TEN::Save::CreateSubsuitControlData(
      _fbb,
      x_rot,
      d_x_rot,
      velocity__,
      vertical_velocity,
      x_rot_vel,
      hit_count);
}

flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TightropeControlDataT : public flatbuffers::NativeTable {
  typedef TightropeControlData TableType;
  float balance = 0.0f;
  uint32_t time_on_tightrope = 0;
  bool can_dismount = false;
  int32_t tightrope_item = 0;
};

struct TightropeControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TightropeControlDataT NativeTableType;
  typedef TightropeControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BALANCE = 4,
    VT_TIME_ON_TIGHTROPE = 6,
    VT_CAN_DISMOUNT = 8,
    VT_TIGHTROPE_ITEM = 10
  };
  float balance() const {
    return GetField<float>(VT_BALANCE, 0.0f);
  }
  uint32_t time_on_tightrope() const {
    return GetField<uint32_t>(VT_TIME_ON_TIGHTROPE, 0);
  }
  bool can_dismount() const {
    return GetField<uint8_t>(VT_CAN_DISMOUNT, 0) != 0;
  }
  int32_t tightrope_item() const {
    return GetField<int32_t>(VT_TIGHTROPE_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BALANCE) &&
           VerifyField<uint32_t>(verifier, VT_TIME_ON_TIGHTROPE) &&
           VerifyField<uint8_t>(verifier, VT_CAN_DISMOUNT) &&
           VerifyField<int32_t>(verifier, VT_TIGHTROPE_ITEM) &&
           verifier.EndTable();
  }
  TightropeControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TightropeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TightropeControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TightropeControlDataBuilder {
  typedef TightropeControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(float balance) {
    fbb_.AddElement<float>(TightropeControlData::VT_BALANCE, balance, 0.0f);
  }
  void add_time_on_tightrope(uint32_t time_on_tightrope) {
    fbb_.AddElement<uint32_t>(TightropeControlData::VT_TIME_ON_TIGHTROPE, time_on_tightrope, 0);
  }
  void add_can_dismount(bool can_dismount) {
    fbb_.AddElement<uint8_t>(TightropeControlData::VT_CAN_DISMOUNT, static_cast<uint8_t>(can_dismount), 0);
  }
  void add_tightrope_item(int32_t tightrope_item) {
    fbb_.AddElement<int32_t>(TightropeControlData::VT_TIGHTROPE_ITEM, tightrope_item, 0);
  }
  explicit TightropeControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TightropeControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TightropeControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float balance = 0.0f,
    uint32_t time_on_tightrope = 0,
    bool can_dismount = false,
    int32_t tightrope_item = 0) {
  TightropeControlDataBuilder builder_(_fbb);
  builder_.add_tightrope_item(tightrope_item);
  builder_.add_time_on_tightrope(time_on_tightrope);
  builder_.add_balance(balance);
  builder_.add_can_dismount(can_dismount);
  return builder_.Finish();
}

struct TightropeControlData::Traits {
  using type = TightropeControlData;
  static auto constexpr Create = CreateTightropeControlData;
};

flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponControlDataT : public flatbuffers::NativeTable {
  typedef WeaponControlData TableType;
  int32_t weapon_item = 0;
  bool has_fired = false;
  bool fired = false;
  bool uzi_left = false;
  bool uzi_right = false;
  int32_t gun_type = 0;
  int32_t request_gun_type = 0;
  int32_t last_gun_type = 0;
  std::unique_ptr<TEN::Save::HolsterInfoT> holster_info{};
  uint32_t num_shots_fired = 0;
  float interval = 0.0f;
  float timer = 0.0f;
};

struct WeaponControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponControlDataT NativeTableType;
  typedef WeaponControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEAPON_ITEM = 4,
    VT_HAS_FIRED = 6,
    VT_FIRED = 8,
    VT_UZI_LEFT = 10,
    VT_UZI_RIGHT = 12,
    VT_GUN_TYPE = 14,
    VT_REQUEST_GUN_TYPE = 16,
    VT_LAST_GUN_TYPE = 18,
    VT_HOLSTER_INFO = 20,
    VT_NUM_SHOTS_FIRED = 22,
    VT_INTERVAL = 24,
    VT_TIMER = 26
  };
  int32_t weapon_item() const {
    return GetField<int32_t>(VT_WEAPON_ITEM, 0);
  }
  bool has_fired() const {
    return GetField<uint8_t>(VT_HAS_FIRED, 0) != 0;
  }
  bool fired() const {
    return GetField<uint8_t>(VT_FIRED, 0) != 0;
  }
  bool uzi_left() const {
    return GetField<uint8_t>(VT_UZI_LEFT, 0) != 0;
  }
  bool uzi_right() const {
    return GetField<uint8_t>(VT_UZI_RIGHT, 0) != 0;
  }
  int32_t gun_type() const {
    return GetField<int32_t>(VT_GUN_TYPE, 0);
  }
  int32_t request_gun_type() const {
    return GetField<int32_t>(VT_REQUEST_GUN_TYPE, 0);
  }
  int32_t last_gun_type() const {
    return GetField<int32_t>(VT_LAST_GUN_TYPE, 0);
  }
  const TEN::Save::HolsterInfo *holster_info() const {
    return GetPointer<const TEN::Save::HolsterInfo *>(VT_HOLSTER_INFO);
  }
  uint32_t num_shots_fired() const {
    return GetField<uint32_t>(VT_NUM_SHOTS_FIRED, 0);
  }
  float interval() const {
    return GetField<float>(VT_INTERVAL, 0.0f);
  }
  float timer() const {
    return GetField<float>(VT_TIMER, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_ITEM) &&
           VerifyField<uint8_t>(verifier, VT_HAS_FIRED) &&
           VerifyField<uint8_t>(verifier, VT_FIRED) &&
           VerifyField<uint8_t>(verifier, VT_UZI_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_UZI_RIGHT) &&
           VerifyField<int32_t>(verifier, VT_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LAST_GUN_TYPE) &&
           VerifyOffset(verifier, VT_HOLSTER_INFO) &&
           verifier.VerifyTable(holster_info()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_SHOTS_FIRED) &&
           VerifyField<float>(verifier, VT_INTERVAL) &&
           VerifyField<float>(verifier, VT_TIMER) &&
           verifier.EndTable();
  }
  WeaponControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WeaponControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponControlDataBuilder {
  typedef WeaponControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weapon_item(int32_t weapon_item) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_WEAPON_ITEM, weapon_item, 0);
  }
  void add_has_fired(bool has_fired) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_HAS_FIRED, static_cast<uint8_t>(has_fired), 0);
  }
  void add_fired(bool fired) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_FIRED, static_cast<uint8_t>(fired), 0);
  }
  void add_uzi_left(bool uzi_left) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_UZI_LEFT, static_cast<uint8_t>(uzi_left), 0);
  }
  void add_uzi_right(bool uzi_right) {
    fbb_.AddElement<uint8_t>(WeaponControlData::VT_UZI_RIGHT, static_cast<uint8_t>(uzi_right), 0);
  }
  void add_gun_type(int32_t gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_GUN_TYPE, gun_type, 0);
  }
  void add_request_gun_type(int32_t request_gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_REQUEST_GUN_TYPE, request_gun_type, 0);
  }
  void add_last_gun_type(int32_t last_gun_type) {
    fbb_.AddElement<int32_t>(WeaponControlData::VT_LAST_GUN_TYPE, last_gun_type, 0);
  }
  void add_holster_info(flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info) {
    fbb_.AddOffset(WeaponControlData::VT_HOLSTER_INFO, holster_info);
  }
  void add_num_shots_fired(uint32_t num_shots_fired) {
    fbb_.AddElement<uint32_t>(WeaponControlData::VT_NUM_SHOTS_FIRED, num_shots_fired, 0);
  }
  void add_interval(float interval) {
    fbb_.AddElement<float>(WeaponControlData::VT_INTERVAL, interval, 0.0f);
  }
  void add_timer(float timer) {
    fbb_.AddElement<float>(WeaponControlData::VT_TIMER, timer, 0.0f);
  }
  explicit WeaponControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeaponControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeaponControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t weapon_item = 0,
    bool has_fired = false,
    bool fired = false,
    bool uzi_left = false,
    bool uzi_right = false,
    int32_t gun_type = 0,
    int32_t request_gun_type = 0,
    int32_t last_gun_type = 0,
    flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info = 0,
    uint32_t num_shots_fired = 0,
    float interval = 0.0f,
    float timer = 0.0f) {
  WeaponControlDataBuilder builder_(_fbb);
  builder_.add_timer(timer);
  builder_.add_interval(interval);
  builder_.add_num_shots_fired(num_shots_fired);
  builder_.add_holster_info(holster_info);
  builder_.add_last_gun_type(last_gun_type);
  builder_.add_request_gun_type(request_gun_type);
  builder_.add_gun_type(gun_type);
  builder_.add_weapon_item(weapon_item);
  builder_.add_uzi_right(uzi_right);
  builder_.add_uzi_left(uzi_left);
  builder_.add_fired(fired);
  builder_.add_has_fired(has_fired);
  return builder_.Finish();
}

struct WeaponControlData::Traits {
  using type = WeaponControlData;
  static auto constexpr Create = CreateWeaponControlData;
};

flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraControlDataT : public flatbuffers::NativeTable {
  typedef LaraControlData TableType;
  bool can_climb_ladder = false;
  bool can_monkey_swing = false;
  std::unique_ptr<TEN::Save::LaraCountDataT> count{};
  int32_t hand_status = 0;
  bool is_climbing_ladder = false;
  bool is_locked = false;
  bool is_low = false;
  bool is_moving = false;
  bool is_run_jump_queued = false;
  int32_t jump_direction = 0;
  bool keep_low = false;
  std::unique_ptr<TEN::Save::LookControlDataT> look{};
  int32_t move_angle = 0;
  std::unique_ptr<TEN::Save::RopeControlDataT> rope{};
  std::unique_ptr<TEN::Save::SubsuitControlDataT> subsuit{};
  std::unique_ptr<TEN::Save::TightropeControlDataT> tightrope{};
  int32_t turn_rate = 0;
  int32_t water_status = 0;
  std::unique_ptr<TEN::Save::WeaponControlDataT> weapon{};
};

struct LaraControlData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraControlDataT NativeTableType;
  typedef LaraControlDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAN_CLIMB_LADDER = 4,
    VT_CAN_MONKEY_SWING = 6,
    VT_COUNT = 8,
    VT_HAND_STATUS = 10,
    VT_IS_CLIMBING_LADDER = 12,
    VT_IS_LOCKED = 14,
    VT_IS_LOW = 16,
    VT_IS_MOVING = 18,
    VT_IS_RUN_JUMP_QUEUED = 20,
    VT_JUMP_DIRECTION = 22,
    VT_KEEP_LOW = 24,
    VT_LOOK = 26,
    VT_MOVE_ANGLE = 28,
    VT_ROPE = 30,
    VT_SUBSUIT = 32,
    VT_TIGHTROPE = 34,
    VT_TURN_RATE = 36,
    VT_WATER_STATUS = 38,
    VT_WEAPON = 40
  };
  bool can_climb_ladder() const {
    return GetField<uint8_t>(VT_CAN_CLIMB_LADDER, 0) != 0;
  }
  bool can_monkey_swing() const {
    return GetField<uint8_t>(VT_CAN_MONKEY_SWING, 0) != 0;
  }
  const TEN::Save::LaraCountData *count() const {
    return GetPointer<const TEN::Save::LaraCountData *>(VT_COUNT);
  }
  int32_t hand_status() const {
    return GetField<int32_t>(VT_HAND_STATUS, 0);
  }
  bool is_climbing_ladder() const {
    return GetField<uint8_t>(VT_IS_CLIMBING_LADDER, 0) != 0;
  }
  bool is_locked() const {
    return GetField<uint8_t>(VT_IS_LOCKED, 0) != 0;
  }
  bool is_low() const {
    return GetField<uint8_t>(VT_IS_LOW, 0) != 0;
  }
  bool is_moving() const {
    return GetField<uint8_t>(VT_IS_MOVING, 0) != 0;
  }
  bool is_run_jump_queued() const {
    return GetField<uint8_t>(VT_IS_RUN_JUMP_QUEUED, 0) != 0;
  }
  int32_t jump_direction() const {
    return GetField<int32_t>(VT_JUMP_DIRECTION, 0);
  }
  bool keep_low() const {
    return GetField<uint8_t>(VT_KEEP_LOW, 0) != 0;
  }
  const TEN::Save::LookControlData *look() const {
    return GetPointer<const TEN::Save::LookControlData *>(VT_LOOK);
  }
  int32_t move_angle() const {
    return GetField<int32_t>(VT_MOVE_ANGLE, 0);
  }
  const TEN::Save::RopeControlData *rope() const {
    return GetPointer<const TEN::Save::RopeControlData *>(VT_ROPE);
  }
  const TEN::Save::SubsuitControlData *subsuit() const {
    return GetPointer<const TEN::Save::SubsuitControlData *>(VT_SUBSUIT);
  }
  const TEN::Save::TightropeControlData *tightrope() const {
    return GetPointer<const TEN::Save::TightropeControlData *>(VT_TIGHTROPE);
  }
  int32_t turn_rate() const {
    return GetField<int32_t>(VT_TURN_RATE, 0);
  }
  int32_t water_status() const {
    return GetField<int32_t>(VT_WATER_STATUS, 0);
  }
  const TEN::Save::WeaponControlData *weapon() const {
    return GetPointer<const TEN::Save::WeaponControlData *>(VT_WEAPON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CAN_CLIMB_LADDER) &&
           VerifyField<uint8_t>(verifier, VT_CAN_MONKEY_SWING) &&
           VerifyOffset(verifier, VT_COUNT) &&
           verifier.VerifyTable(count()) &&
           VerifyField<int32_t>(verifier, VT_HAND_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_IS_CLIMBING_LADDER) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOCKED) &&
           VerifyField<uint8_t>(verifier, VT_IS_LOW) &&
           VerifyField<uint8_t>(verifier, VT_IS_MOVING) &&
           VerifyField<uint8_t>(verifier, VT_IS_RUN_JUMP_QUEUED) &&
           VerifyField<int32_t>(verifier, VT_JUMP_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_LOW) &&
           VerifyOffset(verifier, VT_LOOK) &&
           verifier.VerifyTable(look()) &&
           VerifyField<int32_t>(verifier, VT_MOVE_ANGLE) &&
           VerifyOffset(verifier, VT_ROPE) &&
           verifier.VerifyTable(rope()) &&
           VerifyOffset(verifier, VT_SUBSUIT) &&
           verifier.VerifyTable(subsuit()) &&
           VerifyOffset(verifier, VT_TIGHTROPE) &&
           verifier.VerifyTable(tightrope()) &&
           VerifyField<int32_t>(verifier, VT_TURN_RATE) &&
           VerifyField<int32_t>(verifier, VT_WATER_STATUS) &&
           VerifyOffset(verifier, VT_WEAPON) &&
           verifier.VerifyTable(weapon()) &&
           verifier.EndTable();
  }
  LaraControlDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraControlDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraControlData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraControlDataBuilder {
  typedef LaraControlData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_can_climb_ladder(bool can_climb_ladder) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_CAN_CLIMB_LADDER, static_cast<uint8_t>(can_climb_ladder), 0);
  }
  void add_can_monkey_swing(bool can_monkey_swing) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_CAN_MONKEY_SWING, static_cast<uint8_t>(can_monkey_swing), 0);
  }
  void add_count(flatbuffers::Offset<TEN::Save::LaraCountData> count) {
    fbb_.AddOffset(LaraControlData::VT_COUNT, count);
  }
  void add_hand_status(int32_t hand_status) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_HAND_STATUS, hand_status, 0);
  }
  void add_is_climbing_ladder(bool is_climbing_ladder) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_CLIMBING_LADDER, static_cast<uint8_t>(is_climbing_ladder), 0);
  }
  void add_is_locked(bool is_locked) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_LOCKED, static_cast<uint8_t>(is_locked), 0);
  }
  void add_is_low(bool is_low) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_LOW, static_cast<uint8_t>(is_low), 0);
  }
  void add_is_moving(bool is_moving) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_MOVING, static_cast<uint8_t>(is_moving), 0);
  }
  void add_is_run_jump_queued(bool is_run_jump_queued) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_IS_RUN_JUMP_QUEUED, static_cast<uint8_t>(is_run_jump_queued), 0);
  }
  void add_jump_direction(int32_t jump_direction) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_JUMP_DIRECTION, jump_direction, 0);
  }
  void add_keep_low(bool keep_low) {
    fbb_.AddElement<uint8_t>(LaraControlData::VT_KEEP_LOW, static_cast<uint8_t>(keep_low), 0);
  }
  void add_look(flatbuffers::Offset<TEN::Save::LookControlData> look) {
    fbb_.AddOffset(LaraControlData::VT_LOOK, look);
  }
  void add_move_angle(int32_t move_angle) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_MOVE_ANGLE, move_angle, 0);
  }
  void add_rope(flatbuffers::Offset<TEN::Save::RopeControlData> rope) {
    fbb_.AddOffset(LaraControlData::VT_ROPE, rope);
  }
  void add_subsuit(flatbuffers::Offset<TEN::Save::SubsuitControlData> subsuit) {
    fbb_.AddOffset(LaraControlData::VT_SUBSUIT, subsuit);
  }
  void add_tightrope(flatbuffers::Offset<TEN::Save::TightropeControlData> tightrope) {
    fbb_.AddOffset(LaraControlData::VT_TIGHTROPE, tightrope);
  }
  void add_turn_rate(int32_t turn_rate) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_TURN_RATE, turn_rate, 0);
  }
  void add_water_status(int32_t water_status) {
    fbb_.AddElement<int32_t>(LaraControlData::VT_WATER_STATUS, water_status, 0);
  }
  void add_weapon(flatbuffers::Offset<TEN::Save::WeaponControlData> weapon) {
    fbb_.AddOffset(LaraControlData::VT_WEAPON, weapon);
  }
  explicit LaraControlDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraControlData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraControlData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraControlData> CreateLaraControlData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool can_climb_ladder = false,
    bool can_monkey_swing = false,
    flatbuffers::Offset<TEN::Save::LaraCountData> count = 0,
    int32_t hand_status = 0,
    bool is_climbing_ladder = false,
    bool is_locked = false,
    bool is_low = false,
    bool is_moving = false,
    bool is_run_jump_queued = false,
    int32_t jump_direction = 0,
    bool keep_low = false,
    flatbuffers::Offset<TEN::Save::LookControlData> look = 0,
    int32_t move_angle = 0,
    flatbuffers::Offset<TEN::Save::RopeControlData> rope = 0,
    flatbuffers::Offset<TEN::Save::SubsuitControlData> subsuit = 0,
    flatbuffers::Offset<TEN::Save::TightropeControlData> tightrope = 0,
    int32_t turn_rate = 0,
    int32_t water_status = 0,
    flatbuffers::Offset<TEN::Save::WeaponControlData> weapon = 0) {
  LaraControlDataBuilder builder_(_fbb);
  builder_.add_weapon(weapon);
  builder_.add_water_status(water_status);
  builder_.add_turn_rate(turn_rate);
  builder_.add_tightrope(tightrope);
  builder_.add_subsuit(subsuit);
  builder_.add_rope(rope);
  builder_.add_move_angle(move_angle);
  builder_.add_look(look);
  builder_.add_jump_direction(jump_direction);
  builder_.add_hand_status(hand_status);
  builder_.add_count(count);
  builder_.add_keep_low(keep_low);
  builder_.add_is_run_jump_queued(is_run_jump_queued);
  builder_.add_is_moving(is_moving);
  builder_.add_is_low(is_low);
  builder_.add_is_locked(is_locked);
  builder_.add_is_climbing_ladder(is_climbing_ladder);
  builder_.add_can_monkey_swing(can_monkey_swing);
  builder_.add_can_climb_ladder(can_climb_ladder);
  return builder_.Finish();
}

struct LaraControlData::Traits {
  using type = LaraControlData;
  static auto constexpr Create = CreateLaraControlData;
};

flatbuffers::Offset<LaraControlData> CreateLaraControlData(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerEffectDataT : public flatbuffers::NativeTable {
  typedef PlayerEffectData TableType;
  std::vector<float> bubble_nodes{};
  std::vector<float> drip_nodes{};
};

struct PlayerEffectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerEffectDataT NativeTableType;
  typedef PlayerEffectDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUBBLE_NODES = 4,
    VT_DRIP_NODES = 6
  };
  const flatbuffers::Vector<float> *bubble_nodes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BUBBLE_NODES);
  }
  const flatbuffers::Vector<float> *drip_nodes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DRIP_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUBBLE_NODES) &&
           verifier.VerifyVector(bubble_nodes()) &&
           VerifyOffset(verifier, VT_DRIP_NODES) &&
           verifier.VerifyVector(drip_nodes()) &&
           verifier.EndTable();
  }
  PlayerEffectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerEffectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerEffectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerEffectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerEffectDataBuilder {
  typedef PlayerEffectData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bubble_nodes(flatbuffers::Offset<flatbuffers::Vector<float>> bubble_nodes) {
    fbb_.AddOffset(PlayerEffectData::VT_BUBBLE_NODES, bubble_nodes);
  }
  void add_drip_nodes(flatbuffers::Offset<flatbuffers::Vector<float>> drip_nodes) {
    fbb_.AddOffset(PlayerEffectData::VT_DRIP_NODES, drip_nodes);
  }
  explicit PlayerEffectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlayerEffectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerEffectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerEffectData> CreatePlayerEffectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> bubble_nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> drip_nodes = 0) {
  PlayerEffectDataBuilder builder_(_fbb);
  builder_.add_drip_nodes(drip_nodes);
  builder_.add_bubble_nodes(bubble_nodes);
  return builder_.Finish();
}

struct PlayerEffectData::Traits {
  using type = PlayerEffectData;
  static auto constexpr Create = CreatePlayerEffectData;
};

inline flatbuffers::Offset<PlayerEffectData> CreatePlayerEffectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *bubble_nodes = nullptr,
    const std::vector<float> *drip_nodes = nullptr) {
  auto bubble_nodes__ = bubble_nodes ? _fbb.CreateVector<float>(*bubble_nodes) : 0;
  auto drip_nodes__ = drip_nodes ? _fbb.CreateVector<float>(*drip_nodes) : 0;
  return TEN::Save::CreatePlayerEffectData(
      _fbb,
      bubble_nodes__,
      drip_nodes__);
}

flatbuffers::Offset<PlayerEffectData> CreatePlayerEffectData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerEffectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerStatusDataT : public flatbuffers::NativeTable {
  typedef PlayerStatusData TableType;
  int32_t air = 0;
  int32_t exposure = 0;
  int32_t poison = 0;
  int32_t stamina = 0;
};

struct PlayerStatusData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerStatusDataT NativeTableType;
  typedef PlayerStatusDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AIR = 4,
    VT_EXPOSURE = 6,
    VT_POISON = 8,
    VT_STAMINA = 10
  };
  int32_t air() const {
    return GetField<int32_t>(VT_AIR, 0);
  }
  int32_t exposure() const {
    return GetField<int32_t>(VT_EXPOSURE, 0);
  }
  int32_t poison() const {
    return GetField<int32_t>(VT_POISON, 0);
  }
  int32_t stamina() const {
    return GetField<int32_t>(VT_STAMINA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AIR) &&
           VerifyField<int32_t>(verifier, VT_EXPOSURE) &&
           VerifyField<int32_t>(verifier, VT_POISON) &&
           VerifyField<int32_t>(verifier, VT_STAMINA) &&
           verifier.EndTable();
  }
  PlayerStatusDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerStatusDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerStatusData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerStatusDataBuilder {
  typedef PlayerStatusData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_air(int32_t air) {
    fbb_.AddElement<int32_t>(PlayerStatusData::VT_AIR, air, 0);
  }
  void add_exposure(int32_t exposure) {
    fbb_.AddElement<int32_t>(PlayerStatusData::VT_EXPOSURE, exposure, 0);
  }
  void add_poison(int32_t poison) {
    fbb_.AddElement<int32_t>(PlayerStatusData::VT_POISON, poison, 0);
  }
  void add_stamina(int32_t stamina) {
    fbb_.AddElement<int32_t>(PlayerStatusData::VT_STAMINA, stamina, 0);
  }
  explicit PlayerStatusDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlayerStatusData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerStatusData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerStatusData> CreatePlayerStatusData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t air = 0,
    int32_t exposure = 0,
    int32_t poison = 0,
    int32_t stamina = 0) {
  PlayerStatusDataBuilder builder_(_fbb);
  builder_.add_stamina(stamina);
  builder_.add_poison(poison);
  builder_.add_exposure(exposure);
  builder_.add_air(air);
  return builder_.Finish();
}

struct PlayerStatusData::Traits {
  using type = PlayerStatusData;
  static auto constexpr Create = CreatePlayerStatusData;
};

flatbuffers::Offset<PlayerStatusData> CreatePlayerStatusData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerContextDataT : public flatbuffers::NativeTable {
  typedef PlayerContextData TableType;
  int32_t calc_jump_velocity = 0;
  int32_t interacted_item_number = 0;
  std::unique_ptr<TEN::Save::Pose> next_corner_pose{};
  int32_t projected_floor_height = 0;
  std::unique_ptr<TEN::Save::EulerAngles> target_orient{};
  int32_t vehicle_item_number = 0;
  int32_t water_current_active = 0;
  std::unique_ptr<TEN::Save::Vector3> water_current_pull{};
  int32_t water_surface_dist = 0;
};

struct PlayerContextData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerContextDataT NativeTableType;
  typedef PlayerContextDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALC_JUMP_VELOCITY = 4,
    VT_INTERACTED_ITEM_NUMBER = 6,
    VT_NEXT_CORNER_POSE = 8,
    VT_PROJECTED_FLOOR_HEIGHT = 10,
    VT_TARGET_ORIENT = 12,
    VT_VEHICLE_ITEM_NUMBER = 14,
    VT_WATER_CURRENT_ACTIVE = 16,
    VT_WATER_CURRENT_PULL = 18,
    VT_WATER_SURFACE_DIST = 20
  };
  int32_t calc_jump_velocity() const {
    return GetField<int32_t>(VT_CALC_JUMP_VELOCITY, 0);
  }
  int32_t interacted_item_number() const {
    return GetField<int32_t>(VT_INTERACTED_ITEM_NUMBER, 0);
  }
  const TEN::Save::Pose *next_corner_pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_NEXT_CORNER_POSE);
  }
  int32_t projected_floor_height() const {
    return GetField<int32_t>(VT_PROJECTED_FLOOR_HEIGHT, 0);
  }
  const TEN::Save::EulerAngles *target_orient() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_TARGET_ORIENT);
  }
  int32_t vehicle_item_number() const {
    return GetField<int32_t>(VT_VEHICLE_ITEM_NUMBER, 0);
  }
  int32_t water_current_active() const {
    return GetField<int32_t>(VT_WATER_CURRENT_ACTIVE, 0);
  }
  const TEN::Save::Vector3 *water_current_pull() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_WATER_CURRENT_PULL);
  }
  int32_t water_surface_dist() const {
    return GetField<int32_t>(VT_WATER_SURFACE_DIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CALC_JUMP_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_INTERACTED_ITEM_NUMBER) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_NEXT_CORNER_POSE) &&
           VerifyField<int32_t>(verifier, VT_PROJECTED_FLOOR_HEIGHT) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_TARGET_ORIENT) &&
           VerifyField<int32_t>(verifier, VT_VEHICLE_ITEM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_WATER_CURRENT_ACTIVE) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_WATER_CURRENT_PULL) &&
           VerifyField<int32_t>(verifier, VT_WATER_SURFACE_DIST) &&
           verifier.EndTable();
  }
  PlayerContextDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerContextDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerContextData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerContextDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerContextDataBuilder {
  typedef PlayerContextData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_calc_jump_velocity(int32_t calc_jump_velocity) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_CALC_JUMP_VELOCITY, calc_jump_velocity, 0);
  }
  void add_interacted_item_number(int32_t interacted_item_number) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_INTERACTED_ITEM_NUMBER, interacted_item_number, 0);
  }
  void add_next_corner_pose(const TEN::Save::Pose *next_corner_pose) {
    fbb_.AddStruct(PlayerContextData::VT_NEXT_CORNER_POSE, next_corner_pose);
  }
  void add_projected_floor_height(int32_t projected_floor_height) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_PROJECTED_FLOOR_HEIGHT, projected_floor_height, 0);
  }
  void add_target_orient(const TEN::Save::EulerAngles *target_orient) {
    fbb_.AddStruct(PlayerContextData::VT_TARGET_ORIENT, target_orient);
  }
  void add_vehicle_item_number(int32_t vehicle_item_number) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_VEHICLE_ITEM_NUMBER, vehicle_item_number, 0);
  }
  void add_water_current_active(int32_t water_current_active) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_WATER_CURRENT_ACTIVE, water_current_active, 0);
  }
  void add_water_current_pull(const TEN::Save::Vector3 *water_current_pull) {
    fbb_.AddStruct(PlayerContextData::VT_WATER_CURRENT_PULL, water_current_pull);
  }
  void add_water_surface_dist(int32_t water_surface_dist) {
    fbb_.AddElement<int32_t>(PlayerContextData::VT_WATER_SURFACE_DIST, water_surface_dist, 0);
  }
  explicit PlayerContextDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlayerContextData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerContextData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerContextData> CreatePlayerContextData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t calc_jump_velocity = 0,
    int32_t interacted_item_number = 0,
    const TEN::Save::Pose *next_corner_pose = 0,
    int32_t projected_floor_height = 0,
    const TEN::Save::EulerAngles *target_orient = 0,
    int32_t vehicle_item_number = 0,
    int32_t water_current_active = 0,
    const TEN::Save::Vector3 *water_current_pull = 0,
    int32_t water_surface_dist = 0) {
  PlayerContextDataBuilder builder_(_fbb);
  builder_.add_water_surface_dist(water_surface_dist);
  builder_.add_water_current_pull(water_current_pull);
  builder_.add_water_current_active(water_current_active);
  builder_.add_vehicle_item_number(vehicle_item_number);
  builder_.add_target_orient(target_orient);
  builder_.add_projected_floor_height(projected_floor_height);
  builder_.add_next_corner_pose(next_corner_pose);
  builder_.add_interacted_item_number(interacted_item_number);
  builder_.add_calc_jump_velocity(calc_jump_velocity);
  return builder_.Finish();
}

struct PlayerContextData::Traits {
  using type = PlayerContextData;
  static auto constexpr Create = CreatePlayerContextData;
};

flatbuffers::Offset<PlayerContextData> CreatePlayerContextData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerContextDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CollisionInfoDataT : public flatbuffers::NativeTable {
  typedef CollisionInfoData TableType;
  int32_t last_bridge_item_number = 0;
  std::unique_ptr<TEN::Save::Pose> last_bridge_item_pose{};
};

struct CollisionInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CollisionInfoDataT NativeTableType;
  typedef CollisionInfoDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAST_BRIDGE_ITEM_NUMBER = 4,
    VT_LAST_BRIDGE_ITEM_POSE = 6
  };
  int32_t last_bridge_item_number() const {
    return GetField<int32_t>(VT_LAST_BRIDGE_ITEM_NUMBER, 0);
  }
  const TEN::Save::Pose *last_bridge_item_pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_LAST_BRIDGE_ITEM_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAST_BRIDGE_ITEM_NUMBER) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_LAST_BRIDGE_ITEM_POSE) &&
           verifier.EndTable();
  }
  CollisionInfoDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollisionInfoDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CollisionInfoData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollisionInfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CollisionInfoDataBuilder {
  typedef CollisionInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_last_bridge_item_number(int32_t last_bridge_item_number) {
    fbb_.AddElement<int32_t>(CollisionInfoData::VT_LAST_BRIDGE_ITEM_NUMBER, last_bridge_item_number, 0);
  }
  void add_last_bridge_item_pose(const TEN::Save::Pose *last_bridge_item_pose) {
    fbb_.AddStruct(CollisionInfoData::VT_LAST_BRIDGE_ITEM_POSE, last_bridge_item_pose);
  }
  explicit CollisionInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CollisionInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CollisionInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CollisionInfoData> CreateCollisionInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t last_bridge_item_number = 0,
    const TEN::Save::Pose *last_bridge_item_pose = 0) {
  CollisionInfoDataBuilder builder_(_fbb);
  builder_.add_last_bridge_item_pose(last_bridge_item_pose);
  builder_.add_last_bridge_item_number(last_bridge_item_number);
  return builder_.Finish();
}

struct CollisionInfoData::Traits {
  using type = CollisionInfoData;
  static auto constexpr Create = CreateCollisionInfoData;
};

flatbuffers::Offset<CollisionInfoData> CreateCollisionInfoData(flatbuffers::FlatBufferBuilder &_fbb, const CollisionInfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraT : public flatbuffers::NativeTable {
  typedef Lara TableType;
  std::unique_ptr<TEN::Save::PlayerContextDataT> context{};
  std::unique_ptr<TEN::Save::LaraControlDataT> control{};
  std::unique_ptr<TEN::Save::PlayerEffectDataT> effect{};
  std::unique_ptr<TEN::Save::CollisionInfoDataT> collision{};
  int32_t extra_anim = 0;
  std::unique_ptr<TEN::Save::EulerAngles> extra_head_rot{};
  std::unique_ptr<TEN::Save::EulerAngles> extra_torso_rot{};
  std::unique_ptr<TEN::Save::FlareDataT> flare{};
  int32_t highest_location = 0;
  int32_t hit_direction = 0;
  int32_t hit_frame = 0;
  std::unique_ptr<TEN::Save::LaraInventoryDataT> inventory{};
  std::unique_ptr<TEN::Save::ArmInfoT> left_arm{};
  int32_t location = 0;
  int32_t location_pad = 0;
  std::unique_ptr<TEN::Save::ArmInfoT> right_arm{};
  std::unique_ptr<TEN::Save::PlayerStatusDataT> status{};
  std::unique_ptr<TEN::Save::EulerAngles> target_arm_orient{};
  int32_t target_entity_number = 0;
  std::unique_ptr<TEN::Save::TorchDataT> torch{};
  std::vector<std::unique_ptr<TEN::Save::CarriedWeaponInfoT>> weapons{};
};

struct Lara FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraT NativeTableType;
  typedef LaraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_CONTROL = 6,
    VT_EFFECT = 8,
    VT_COLLISION = 10,
    VT_EXTRA_ANIM = 12,
    VT_EXTRA_HEAD_ROT = 14,
    VT_EXTRA_TORSO_ROT = 16,
    VT_FLARE = 18,
    VT_HIGHEST_LOCATION = 20,
    VT_HIT_DIRECTION = 22,
    VT_HIT_FRAME = 24,
    VT_INVENTORY = 26,
    VT_LEFT_ARM = 28,
    VT_LOCATION = 30,
    VT_LOCATION_PAD = 32,
    VT_RIGHT_ARM = 34,
    VT_STATUS = 36,
    VT_TARGET_ARM_ORIENT = 38,
    VT_TARGET_ENTITY_NUMBER = 40,
    VT_TORCH = 42,
    VT_WEAPONS = 44
  };
  const TEN::Save::PlayerContextData *context() const {
    return GetPointer<const TEN::Save::PlayerContextData *>(VT_CONTEXT);
  }
  const TEN::Save::LaraControlData *control() const {
    return GetPointer<const TEN::Save::LaraControlData *>(VT_CONTROL);
  }
  const TEN::Save::PlayerEffectData *effect() const {
    return GetPointer<const TEN::Save::PlayerEffectData *>(VT_EFFECT);
  }
  const TEN::Save::CollisionInfoData *collision() const {
    return GetPointer<const TEN::Save::CollisionInfoData *>(VT_COLLISION);
  }
  int32_t extra_anim() const {
    return GetField<int32_t>(VT_EXTRA_ANIM, 0);
  }
  const TEN::Save::EulerAngles *extra_head_rot() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_EXTRA_HEAD_ROT);
  }
  const TEN::Save::EulerAngles *extra_torso_rot() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_EXTRA_TORSO_ROT);
  }
  const TEN::Save::FlareData *flare() const {
    return GetPointer<const TEN::Save::FlareData *>(VT_FLARE);
  }
  int32_t highest_location() const {
    return GetField<int32_t>(VT_HIGHEST_LOCATION, 0);
  }
  int32_t hit_direction() const {
    return GetField<int32_t>(VT_HIT_DIRECTION, 0);
  }
  int32_t hit_frame() const {
    return GetField<int32_t>(VT_HIT_FRAME, 0);
  }
  const TEN::Save::LaraInventoryData *inventory() const {
    return GetPointer<const TEN::Save::LaraInventoryData *>(VT_INVENTORY);
  }
  const TEN::Save::ArmInfo *left_arm() const {
    return GetPointer<const TEN::Save::ArmInfo *>(VT_LEFT_ARM);
  }
  int32_t location() const {
    return GetField<int32_t>(VT_LOCATION, 0);
  }
  int32_t location_pad() const {
    return GetField<int32_t>(VT_LOCATION_PAD, 0);
  }
  const TEN::Save::ArmInfo *right_arm() const {
    return GetPointer<const TEN::Save::ArmInfo *>(VT_RIGHT_ARM);
  }
  const TEN::Save::PlayerStatusData *status() const {
    return GetPointer<const TEN::Save::PlayerStatusData *>(VT_STATUS);
  }
  const TEN::Save::EulerAngles *target_arm_orient() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_TARGET_ARM_ORIENT);
  }
  int32_t target_entity_number() const {
    return GetField<int32_t>(VT_TARGET_ENTITY_NUMBER, 0);
  }
  const TEN::Save::TorchData *torch() const {
    return GetPointer<const TEN::Save::TorchData *>(VT_TORCH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *>(VT_WEAPONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyTable(context()) &&
           VerifyOffset(verifier, VT_CONTROL) &&
           verifier.VerifyTable(control()) &&
           VerifyOffset(verifier, VT_EFFECT) &&
           verifier.VerifyTable(effect()) &&
           VerifyOffset(verifier, VT_COLLISION) &&
           verifier.VerifyTable(collision()) &&
           VerifyField<int32_t>(verifier, VT_EXTRA_ANIM) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_EXTRA_HEAD_ROT) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_EXTRA_TORSO_ROT) &&
           VerifyOffset(verifier, VT_FLARE) &&
           verifier.VerifyTable(flare()) &&
           VerifyField<int32_t>(verifier, VT_HIGHEST_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_HIT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_HIT_FRAME) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyTable(inventory()) &&
           VerifyOffset(verifier, VT_LEFT_ARM) &&
           verifier.VerifyTable(left_arm()) &&
           VerifyField<int32_t>(verifier, VT_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_LOCATION_PAD) &&
           VerifyOffset(verifier, VT_RIGHT_ARM) &&
           verifier.VerifyTable(right_arm()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_TARGET_ARM_ORIENT) &&
           VerifyField<int32_t>(verifier, VT_TARGET_ENTITY_NUMBER) &&
           VerifyOffset(verifier, VT_TORCH) &&
           verifier.VerifyTable(torch()) &&
           VerifyOffset(verifier, VT_WEAPONS) &&
           verifier.VerifyVector(weapons()) &&
           verifier.VerifyVectorOfTables(weapons()) &&
           verifier.EndTable();
  }
  LaraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lara> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraBuilder {
  typedef Lara Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_context(flatbuffers::Offset<TEN::Save::PlayerContextData> context) {
    fbb_.AddOffset(Lara::VT_CONTEXT, context);
  }
  void add_control(flatbuffers::Offset<TEN::Save::LaraControlData> control) {
    fbb_.AddOffset(Lara::VT_CONTROL, control);
  }
  void add_effect(flatbuffers::Offset<TEN::Save::PlayerEffectData> effect) {
    fbb_.AddOffset(Lara::VT_EFFECT, effect);
  }
  void add_collision(flatbuffers::Offset<TEN::Save::CollisionInfoData> collision) {
    fbb_.AddOffset(Lara::VT_COLLISION, collision);
  }
  void add_extra_anim(int32_t extra_anim) {
    fbb_.AddElement<int32_t>(Lara::VT_EXTRA_ANIM, extra_anim, 0);
  }
  void add_extra_head_rot(const TEN::Save::EulerAngles *extra_head_rot) {
    fbb_.AddStruct(Lara::VT_EXTRA_HEAD_ROT, extra_head_rot);
  }
  void add_extra_torso_rot(const TEN::Save::EulerAngles *extra_torso_rot) {
    fbb_.AddStruct(Lara::VT_EXTRA_TORSO_ROT, extra_torso_rot);
  }
  void add_flare(flatbuffers::Offset<TEN::Save::FlareData> flare) {
    fbb_.AddOffset(Lara::VT_FLARE, flare);
  }
  void add_highest_location(int32_t highest_location) {
    fbb_.AddElement<int32_t>(Lara::VT_HIGHEST_LOCATION, highest_location, 0);
  }
  void add_hit_direction(int32_t hit_direction) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_DIRECTION, hit_direction, 0);
  }
  void add_hit_frame(int32_t hit_frame) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_FRAME, hit_frame, 0);
  }
  void add_inventory(flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory) {
    fbb_.AddOffset(Lara::VT_INVENTORY, inventory);
  }
  void add_left_arm(flatbuffers::Offset<TEN::Save::ArmInfo> left_arm) {
    fbb_.AddOffset(Lara::VT_LEFT_ARM, left_arm);
  }
  void add_location(int32_t location) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION, location, 0);
  }
  void add_location_pad(int32_t location_pad) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION_PAD, location_pad, 0);
  }
  void add_right_arm(flatbuffers::Offset<TEN::Save::ArmInfo> right_arm) {
    fbb_.AddOffset(Lara::VT_RIGHT_ARM, right_arm);
  }
  void add_status(flatbuffers::Offset<TEN::Save::PlayerStatusData> status) {
    fbb_.AddOffset(Lara::VT_STATUS, status);
  }
  void add_target_arm_orient(const TEN::Save::EulerAngles *target_arm_orient) {
    fbb_.AddStruct(Lara::VT_TARGET_ARM_ORIENT, target_arm_orient);
  }
  void add_target_entity_number(int32_t target_entity_number) {
    fbb_.AddElement<int32_t>(Lara::VT_TARGET_ENTITY_NUMBER, target_entity_number, 0);
  }
  void add_torch(flatbuffers::Offset<TEN::Save::TorchData> torch) {
    fbb_.AddOffset(Lara::VT_TORCH, torch);
  }
  void add_weapons(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons) {
    fbb_.AddOffset(Lara::VT_WEAPONS, weapons);
  }
  explicit LaraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lara> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lara>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lara> CreateLara(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::PlayerContextData> context = 0,
    flatbuffers::Offset<TEN::Save::LaraControlData> control = 0,
    flatbuffers::Offset<TEN::Save::PlayerEffectData> effect = 0,
    flatbuffers::Offset<TEN::Save::CollisionInfoData> collision = 0,
    int32_t extra_anim = 0,
    const TEN::Save::EulerAngles *extra_head_rot = 0,
    const TEN::Save::EulerAngles *extra_torso_rot = 0,
    flatbuffers::Offset<TEN::Save::FlareData> flare = 0,
    int32_t highest_location = 0,
    int32_t hit_direction = 0,
    int32_t hit_frame = 0,
    flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> left_arm = 0,
    int32_t location = 0,
    int32_t location_pad = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> right_arm = 0,
    flatbuffers::Offset<TEN::Save::PlayerStatusData> status = 0,
    const TEN::Save::EulerAngles *target_arm_orient = 0,
    int32_t target_entity_number = 0,
    flatbuffers::Offset<TEN::Save::TorchData> torch = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons = 0) {
  LaraBuilder builder_(_fbb);
  builder_.add_weapons(weapons);
  builder_.add_torch(torch);
  builder_.add_target_entity_number(target_entity_number);
  builder_.add_target_arm_orient(target_arm_orient);
  builder_.add_status(status);
  builder_.add_right_arm(right_arm);
  builder_.add_location_pad(location_pad);
  builder_.add_location(location);
  builder_.add_left_arm(left_arm);
  builder_.add_inventory(inventory);
  builder_.add_hit_frame(hit_frame);
  builder_.add_hit_direction(hit_direction);
  builder_.add_highest_location(highest_location);
  builder_.add_flare(flare);
  builder_.add_extra_torso_rot(extra_torso_rot);
  builder_.add_extra_head_rot(extra_head_rot);
  builder_.add_extra_anim(extra_anim);
  builder_.add_collision(collision);
  builder_.add_effect(effect);
  builder_.add_control(control);
  builder_.add_context(context);
  return builder_.Finish();
}

struct Lara::Traits {
  using type = Lara;
  static auto constexpr Create = CreateLara;
};

inline flatbuffers::Offset<Lara> CreateLaraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::PlayerContextData> context = 0,
    flatbuffers::Offset<TEN::Save::LaraControlData> control = 0,
    flatbuffers::Offset<TEN::Save::PlayerEffectData> effect = 0,
    flatbuffers::Offset<TEN::Save::CollisionInfoData> collision = 0,
    int32_t extra_anim = 0,
    const TEN::Save::EulerAngles *extra_head_rot = 0,
    const TEN::Save::EulerAngles *extra_torso_rot = 0,
    flatbuffers::Offset<TEN::Save::FlareData> flare = 0,
    int32_t highest_location = 0,
    int32_t hit_direction = 0,
    int32_t hit_frame = 0,
    flatbuffers::Offset<TEN::Save::LaraInventoryData> inventory = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> left_arm = 0,
    int32_t location = 0,
    int32_t location_pad = 0,
    flatbuffers::Offset<TEN::Save::ArmInfo> right_arm = 0,
    flatbuffers::Offset<TEN::Save::PlayerStatusData> status = 0,
    const TEN::Save::EulerAngles *target_arm_orient = 0,
    int32_t target_entity_number = 0,
    flatbuffers::Offset<TEN::Save::TorchData> torch = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons = nullptr) {
  auto weapons__ = weapons ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>(*weapons) : 0;
  return TEN::Save::CreateLara(
      _fbb,
      context,
      control,
      effect,
      collision,
      extra_anim,
      extra_head_rot,
      extra_torso_rot,
      flare,
      highest_location,
      hit_direction,
      hit_frame,
      inventory,
      left_arm,
      location,
      location_pad,
      right_arm,
      status,
      target_arm_orient,
      target_entity_number,
      torch,
      weapons__);
}

flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraT : public flatbuffers::NativeTable {
  typedef Camera TableType;
  std::unique_ptr<TEN::Save::GameVector> position{};
  std::unique_ptr<TEN::Save::GameVector> target{};
};

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraT NativeTableType;
  typedef CameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_TARGET = 6
  };
  const TEN::Save::GameVector *position() const {
    return GetStruct<const TEN::Save::GameVector *>(VT_POSITION);
  }
  const TEN::Save::GameVector *target() const {
    return GetStruct<const TEN::Save::GameVector *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::GameVector>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::GameVector>(verifier, VT_TARGET) &&
           verifier.EndTable();
  }
  CameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Camera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraBuilder {
  typedef Camera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const TEN::Save::GameVector *position) {
    fbb_.AddStruct(Camera::VT_POSITION, position);
  }
  void add_target(const TEN::Save::GameVector *target) {
    fbb_.AddStruct(Camera::VT_TARGET, target);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::GameVector *position = 0,
    const TEN::Save::GameVector *target = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Camera::Traits {
  using type = Camera;
  static auto constexpr Create = CreateCamera;
};

flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder &_fbb, const CameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FixedCameraT : public flatbuffers::NativeTable {
  typedef FixedCamera TableType;
  int32_t flags = 0;
};

struct FixedCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixedCameraT NativeTableType;
  typedef FixedCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FixedCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FixedCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixedCameraBuilder {
  typedef FixedCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FixedCamera::VT_FLAGS, flags, 0);
  }
  explicit FixedCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FixedCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FixedCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FixedCamera::Traits {
  using type = FixedCamera;
  static auto constexpr Create = CreateFixedCamera;
};

flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlyByCameraT : public flatbuffers::NativeTable {
  typedef FlyByCamera TableType;
  int32_t flags = 0;
};

struct FlyByCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlyByCameraT NativeTableType;
  typedef FlyByCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FlyByCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlyByCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlyByCameraBuilder {
  typedef FlyByCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FlyByCamera::VT_FLAGS, flags, 0);
  }
  explicit FlyByCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlyByCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlyByCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FlyByCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FlyByCamera::Traits {
  using type = FlyByCamera;
  static auto constexpr Create = CreateFlyByCamera;
};

flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SinkT : public flatbuffers::NativeTable {
  typedef Sink TableType;
  int32_t flags = 0;
};

struct Sink FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinkT NativeTableType;
  typedef SinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sink> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SinkBuilder {
  typedef Sink Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Sink::VT_FLAGS, flags, 0);
  }
  explicit SinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sink>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sink> CreateSink(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  SinkBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct Sink::Traits {
  using type = Sink;
  static auto constexpr Create = CreateSink;
};

flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StaticMeshInfoT : public flatbuffers::NativeTable {
  typedef StaticMeshInfo TableType;
  int32_t number = 0;
  int32_t room_number = 0;
  std::unique_ptr<TEN::Save::Pose> pose{};
  float scale = 0.0f;
  std::unique_ptr<TEN::Save::Vector4> color{};
  int32_t hit_points = 0;
  int32_t flags = 0;
};

struct StaticMeshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StaticMeshInfoT NativeTableType;
  typedef StaticMeshInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER = 4,
    VT_ROOM_NUMBER = 6,
    VT_POSE = 8,
    VT_SCALE = 10,
    VT_COLOR = 12,
    VT_HIT_POINTS = 14,
    VT_FLAGS = 16
  };
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  const TEN::Save::Pose *pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_POSE);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  const TEN::Save::Vector4 *color() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_COLOR);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_POSE) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  StaticMeshInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StaticMeshInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StaticMeshInfoBuilder {
  typedef StaticMeshInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_NUMBER, number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_pose(const TEN::Save::Pose *pose) {
    fbb_.AddStruct(StaticMeshInfo::VT_POSE, pose);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(StaticMeshInfo::VT_SCALE, scale, 0.0f);
  }
  void add_color(const TEN::Save::Vector4 *color) {
    fbb_.AddStruct(StaticMeshInfo::VT_COLOR, color);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_HIT_POINTS, hit_points, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_FLAGS, flags, 0);
  }
  explicit StaticMeshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StaticMeshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StaticMeshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t number = 0,
    int32_t room_number = 0,
    const TEN::Save::Pose *pose = 0,
    float scale = 0.0f,
    const TEN::Save::Vector4 *color = 0,
    int32_t hit_points = 0,
    int32_t flags = 0) {
  StaticMeshInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_hit_points(hit_points);
  builder_.add_color(color);
  builder_.add_scale(scale);
  builder_.add_pose(pose);
  builder_.add_room_number(room_number);
  builder_.add_number(number);
  return builder_.Finish();
}

struct StaticMeshInfo::Traits {
  using type = StaticMeshInfo;
  static auto constexpr Create = CreateStaticMeshInfo;
};

flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ParticleInfoT : public flatbuffers::NativeTable {
  typedef ParticleInfo TableType;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_vel = 0;
  int32_t y_vel = 0;
  int32_t z_vel = 0;
  int32_t gravity = 0;
  int32_t rot_ang = 0;
  int32_t flags = 0;
  float s_size = 0.0f;
  float d_size = 0.0f;
  float size = 0.0f;
  int32_t friction = 0;
  int32_t scalar = 0;
  int32_t sprite_index = 0;
  int32_t rot_add = 0;
  int32_t max_y_vel = 0;
  bool on = false;
  int32_t s_r = 0;
  int32_t s_g = 0;
  int32_t s_b = 0;
  int32_t d_r = 0;
  int32_t d_g = 0;
  int32_t d_b = 0;
  int32_t r = 0;
  int32_t g = 0;
  int32_t b = 0;
  int32_t col_fade_speed = 0;
  int32_t fade_to_black = 0;
  int32_t s_life = 0;
  int32_t life = 0;
  int32_t blend_mode = 0;
  int32_t extras = 0;
  int32_t dynamic = 0;
  int32_t fx_obj = 0;
  int32_t room_number = 0;
  int32_t node_number = 0;
  std::unique_ptr<TEN::Save::Vector3> target_pos{};
  int32_t sprite_id = 0;
  int32_t damage = 0;
  float framerate = 0.0f;
  int32_t animation_type = 0;
  int32_t light_radius = 0;
  int32_t light_flicker = 0;
  int32_t light_flicker_s = 0;
  int32_t sound = 0;
};

struct ParticleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParticleInfoT NativeTableType;
  typedef ParticleInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_X_VEL = 10,
    VT_Y_VEL = 12,
    VT_Z_VEL = 14,
    VT_GRAVITY = 16,
    VT_ROT_ANG = 18,
    VT_FLAGS = 20,
    VT_S_SIZE = 22,
    VT_D_SIZE = 24,
    VT_SIZE = 26,
    VT_FRICTION = 28,
    VT_SCALAR = 30,
    VT_SPRITE_INDEX = 32,
    VT_ROT_ADD = 34,
    VT_MAX_Y_VEL = 36,
    VT_ON = 38,
    VT_S_R = 40,
    VT_S_G = 42,
    VT_S_B = 44,
    VT_D_R = 46,
    VT_D_G = 48,
    VT_D_B = 50,
    VT_R = 52,
    VT_G = 54,
    VT_B = 56,
    VT_COL_FADE_SPEED = 58,
    VT_FADE_TO_BLACK = 60,
    VT_S_LIFE = 62,
    VT_LIFE = 64,
    VT_BLEND_MODE = 66,
    VT_EXTRAS = 68,
    VT_DYNAMIC = 70,
    VT_FX_OBJ = 72,
    VT_ROOM_NUMBER = 74,
    VT_NODE_NUMBER = 76,
    VT_TARGET_POS = 78,
    VT_SPRITE_ID = 80,
    VT_DAMAGE = 82,
    VT_FRAMERATE = 84,
    VT_ANIMATION_TYPE = 86,
    VT_LIGHT_RADIUS = 88,
    VT_LIGHT_FLICKER = 90,
    VT_LIGHT_FLICKER_S = 92,
    VT_SOUND = 94
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_vel() const {
    return GetField<int32_t>(VT_X_VEL, 0);
  }
  int32_t y_vel() const {
    return GetField<int32_t>(VT_Y_VEL, 0);
  }
  int32_t z_vel() const {
    return GetField<int32_t>(VT_Z_VEL, 0);
  }
  int32_t gravity() const {
    return GetField<int32_t>(VT_GRAVITY, 0);
  }
  int32_t rot_ang() const {
    return GetField<int32_t>(VT_ROT_ANG, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  float s_size() const {
    return GetField<float>(VT_S_SIZE, 0.0f);
  }
  float d_size() const {
    return GetField<float>(VT_D_SIZE, 0.0f);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  int32_t friction() const {
    return GetField<int32_t>(VT_FRICTION, 0);
  }
  int32_t scalar() const {
    return GetField<int32_t>(VT_SCALAR, 0);
  }
  int32_t sprite_index() const {
    return GetField<int32_t>(VT_SPRITE_INDEX, 0);
  }
  int32_t rot_add() const {
    return GetField<int32_t>(VT_ROT_ADD, 0);
  }
  int32_t max_y_vel() const {
    return GetField<int32_t>(VT_MAX_Y_VEL, 0);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t s_r() const {
    return GetField<int32_t>(VT_S_R, 0);
  }
  int32_t s_g() const {
    return GetField<int32_t>(VT_S_G, 0);
  }
  int32_t s_b() const {
    return GetField<int32_t>(VT_S_B, 0);
  }
  int32_t d_r() const {
    return GetField<int32_t>(VT_D_R, 0);
  }
  int32_t d_g() const {
    return GetField<int32_t>(VT_D_G, 0);
  }
  int32_t d_b() const {
    return GetField<int32_t>(VT_D_B, 0);
  }
  int32_t r() const {
    return GetField<int32_t>(VT_R, 0);
  }
  int32_t g() const {
    return GetField<int32_t>(VT_G, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  int32_t col_fade_speed() const {
    return GetField<int32_t>(VT_COL_FADE_SPEED, 0);
  }
  int32_t fade_to_black() const {
    return GetField<int32_t>(VT_FADE_TO_BLACK, 0);
  }
  int32_t s_life() const {
    return GetField<int32_t>(VT_S_LIFE, 0);
  }
  int32_t life() const {
    return GetField<int32_t>(VT_LIFE, 0);
  }
  int32_t blend_mode() const {
    return GetField<int32_t>(VT_BLEND_MODE, 0);
  }
  int32_t extras() const {
    return GetField<int32_t>(VT_EXTRAS, 0);
  }
  int32_t dynamic() const {
    return GetField<int32_t>(VT_DYNAMIC, 0);
  }
  int32_t fx_obj() const {
    return GetField<int32_t>(VT_FX_OBJ, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t node_number() const {
    return GetField<int32_t>(VT_NODE_NUMBER, 0);
  }
  const TEN::Save::Vector3 *target_pos() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_TARGET_POS);
  }
  int32_t sprite_id() const {
    return GetField<int32_t>(VT_SPRITE_ID, 0);
  }
  int32_t damage() const {
    return GetField<int32_t>(VT_DAMAGE, 0);
  }
  float framerate() const {
    return GetField<float>(VT_FRAMERATE, 0.0f);
  }
  int32_t animation_type() const {
    return GetField<int32_t>(VT_ANIMATION_TYPE, 0);
  }
  int32_t light_radius() const {
    return GetField<int32_t>(VT_LIGHT_RADIUS, 0);
  }
  int32_t light_flicker() const {
    return GetField<int32_t>(VT_LIGHT_FLICKER, 0);
  }
  int32_t light_flicker_s() const {
    return GetField<int32_t>(VT_LIGHT_FLICKER_S, 0);
  }
  int32_t sound() const {
    return GetField<int32_t>(VT_SOUND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_VEL) &&
           VerifyField<int32_t>(verifier, VT_Y_VEL) &&
           VerifyField<int32_t>(verifier, VT_Z_VEL) &&
           VerifyField<int32_t>(verifier, VT_GRAVITY) &&
           VerifyField<int32_t>(verifier, VT_ROT_ANG) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<float>(verifier, VT_S_SIZE) &&
           VerifyField<float>(verifier, VT_D_SIZE) &&
           VerifyField<float>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FRICTION) &&
           VerifyField<int32_t>(verifier, VT_SCALAR) &&
           VerifyField<int32_t>(verifier, VT_SPRITE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ROT_ADD) &&
           VerifyField<int32_t>(verifier, VT_MAX_Y_VEL) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_S_R) &&
           VerifyField<int32_t>(verifier, VT_S_G) &&
           VerifyField<int32_t>(verifier, VT_S_B) &&
           VerifyField<int32_t>(verifier, VT_D_R) &&
           VerifyField<int32_t>(verifier, VT_D_G) &&
           VerifyField<int32_t>(verifier, VT_D_B) &&
           VerifyField<int32_t>(verifier, VT_R) &&
           VerifyField<int32_t>(verifier, VT_G) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           VerifyField<int32_t>(verifier, VT_COL_FADE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FADE_TO_BLACK) &&
           VerifyField<int32_t>(verifier, VT_S_LIFE) &&
           VerifyField<int32_t>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_BLEND_MODE) &&
           VerifyField<int32_t>(verifier, VT_EXTRAS) &&
           VerifyField<int32_t>(verifier, VT_DYNAMIC) &&
           VerifyField<int32_t>(verifier, VT_FX_OBJ) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_NODE_NUMBER) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_TARGET_POS) &&
           VerifyField<int32_t>(verifier, VT_SPRITE_ID) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE) &&
           VerifyField<float>(verifier, VT_FRAMERATE) &&
           VerifyField<int32_t>(verifier, VT_ANIMATION_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LIGHT_RADIUS) &&
           VerifyField<int32_t>(verifier, VT_LIGHT_FLICKER) &&
           VerifyField<int32_t>(verifier, VT_LIGHT_FLICKER_S) &&
           VerifyField<int32_t>(verifier, VT_SOUND) &&
           verifier.EndTable();
  }
  ParticleInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ParticleInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ParticleInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ParticleInfoBuilder {
  typedef ParticleInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Z, z, 0);
  }
  void add_x_vel(int32_t x_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_X_VEL, x_vel, 0);
  }
  void add_y_vel(int32_t y_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Y_VEL, y_vel, 0);
  }
  void add_z_vel(int32_t z_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_Z_VEL, z_vel, 0);
  }
  void add_gravity(int32_t gravity) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_GRAVITY, gravity, 0);
  }
  void add_rot_ang(int32_t rot_ang) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROT_ANG, rot_ang, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FLAGS, flags, 0);
  }
  void add_s_size(float s_size) {
    fbb_.AddElement<float>(ParticleInfo::VT_S_SIZE, s_size, 0.0f);
  }
  void add_d_size(float d_size) {
    fbb_.AddElement<float>(ParticleInfo::VT_D_SIZE, d_size, 0.0f);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(ParticleInfo::VT_SIZE, size, 0.0f);
  }
  void add_friction(int32_t friction) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FRICTION, friction, 0);
  }
  void add_scalar(int32_t scalar) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SCALAR, scalar, 0);
  }
  void add_sprite_index(int32_t sprite_index) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SPRITE_INDEX, sprite_index, 0);
  }
  void add_rot_add(int32_t rot_add) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROT_ADD, rot_add, 0);
  }
  void add_max_y_vel(int32_t max_y_vel) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_MAX_Y_VEL, max_y_vel, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(ParticleInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_s_r(int32_t s_r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_R, s_r, 0);
  }
  void add_s_g(int32_t s_g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_G, s_g, 0);
  }
  void add_s_b(int32_t s_b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_B, s_b, 0);
  }
  void add_d_r(int32_t d_r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_R, d_r, 0);
  }
  void add_d_g(int32_t d_g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_G, d_g, 0);
  }
  void add_d_b(int32_t d_b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_D_B, d_b, 0);
  }
  void add_r(int32_t r) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_R, r, 0);
  }
  void add_g(int32_t g) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_G, g, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_B, b, 0);
  }
  void add_col_fade_speed(int32_t col_fade_speed) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_COL_FADE_SPEED, col_fade_speed, 0);
  }
  void add_fade_to_black(int32_t fade_to_black) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FADE_TO_BLACK, fade_to_black, 0);
  }
  void add_s_life(int32_t s_life) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_S_LIFE, s_life, 0);
  }
  void add_life(int32_t life) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_LIFE, life, 0);
  }
  void add_blend_mode(int32_t blend_mode) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_BLEND_MODE, blend_mode, 0);
  }
  void add_extras(int32_t extras) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_EXTRAS, extras, 0);
  }
  void add_dynamic(int32_t dynamic) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_DYNAMIC, dynamic, 0);
  }
  void add_fx_obj(int32_t fx_obj) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_FX_OBJ, fx_obj, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_node_number(int32_t node_number) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_NODE_NUMBER, node_number, 0);
  }
  void add_target_pos(const TEN::Save::Vector3 *target_pos) {
    fbb_.AddStruct(ParticleInfo::VT_TARGET_POS, target_pos);
  }
  void add_sprite_id(int32_t sprite_id) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SPRITE_ID, sprite_id, 0);
  }
  void add_damage(int32_t damage) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_DAMAGE, damage, 0);
  }
  void add_framerate(float framerate) {
    fbb_.AddElement<float>(ParticleInfo::VT_FRAMERATE, framerate, 0.0f);
  }
  void add_animation_type(int32_t animation_type) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_ANIMATION_TYPE, animation_type, 0);
  }
  void add_light_radius(int32_t light_radius) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_LIGHT_RADIUS, light_radius, 0);
  }
  void add_light_flicker(int32_t light_flicker) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_LIGHT_FLICKER, light_flicker, 0);
  }
  void add_light_flicker_s(int32_t light_flicker_s) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_LIGHT_FLICKER_S, light_flicker_s, 0);
  }
  void add_sound(int32_t sound) {
    fbb_.AddElement<int32_t>(ParticleInfo::VT_SOUND, sound, 0);
  }
  explicit ParticleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParticleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParticleInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParticleInfo> CreateParticleInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_vel = 0,
    int32_t y_vel = 0,
    int32_t z_vel = 0,
    int32_t gravity = 0,
    int32_t rot_ang = 0,
    int32_t flags = 0,
    float s_size = 0.0f,
    float d_size = 0.0f,
    float size = 0.0f,
    int32_t friction = 0,
    int32_t scalar = 0,
    int32_t sprite_index = 0,
    int32_t rot_add = 0,
    int32_t max_y_vel = 0,
    bool on = false,
    int32_t s_r = 0,
    int32_t s_g = 0,
    int32_t s_b = 0,
    int32_t d_r = 0,
    int32_t d_g = 0,
    int32_t d_b = 0,
    int32_t r = 0,
    int32_t g = 0,
    int32_t b = 0,
    int32_t col_fade_speed = 0,
    int32_t fade_to_black = 0,
    int32_t s_life = 0,
    int32_t life = 0,
    int32_t blend_mode = 0,
    int32_t extras = 0,
    int32_t dynamic = 0,
    int32_t fx_obj = 0,
    int32_t room_number = 0,
    int32_t node_number = 0,
    const TEN::Save::Vector3 *target_pos = 0,
    int32_t sprite_id = 0,
    int32_t damage = 0,
    float framerate = 0.0f,
    int32_t animation_type = 0,
    int32_t light_radius = 0,
    int32_t light_flicker = 0,
    int32_t light_flicker_s = 0,
    int32_t sound = 0) {
  ParticleInfoBuilder builder_(_fbb);
  builder_.add_sound(sound);
  builder_.add_light_flicker_s(light_flicker_s);
  builder_.add_light_flicker(light_flicker);
  builder_.add_light_radius(light_radius);
  builder_.add_animation_type(animation_type);
  builder_.add_framerate(framerate);
  builder_.add_damage(damage);
  builder_.add_sprite_id(sprite_id);
  builder_.add_target_pos(target_pos);
  builder_.add_node_number(node_number);
  builder_.add_room_number(room_number);
  builder_.add_fx_obj(fx_obj);
  builder_.add_dynamic(dynamic);
  builder_.add_extras(extras);
  builder_.add_blend_mode(blend_mode);
  builder_.add_life(life);
  builder_.add_s_life(s_life);
  builder_.add_fade_to_black(fade_to_black);
  builder_.add_col_fade_speed(col_fade_speed);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  builder_.add_d_b(d_b);
  builder_.add_d_g(d_g);
  builder_.add_d_r(d_r);
  builder_.add_s_b(s_b);
  builder_.add_s_g(s_g);
  builder_.add_s_r(s_r);
  builder_.add_max_y_vel(max_y_vel);
  builder_.add_rot_add(rot_add);
  builder_.add_sprite_index(sprite_index);
  builder_.add_scalar(scalar);
  builder_.add_friction(friction);
  builder_.add_size(size);
  builder_.add_d_size(d_size);
  builder_.add_s_size(s_size);
  builder_.add_flags(flags);
  builder_.add_rot_ang(rot_ang);
  builder_.add_gravity(gravity);
  builder_.add_z_vel(z_vel);
  builder_.add_y_vel(y_vel);
  builder_.add_x_vel(x_vel);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct ParticleInfo::Traits {
  using type = ParticleInfo;
  static auto constexpr Create = CreateParticleInfo;
};

flatbuffers::Offset<ParticleInfo> CreateParticleInfo(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoundtrackT : public flatbuffers::NativeTable {
  typedef Soundtrack TableType;
  std::string name{};
  uint64_t position = 0;
};

struct Soundtrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoundtrackT NativeTableType;
  typedef SoundtrackBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_POSITION = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t position() const {
    return GetField<uint64_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
  SoundtrackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoundtrackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Soundtrack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoundtrackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoundtrackBuilder {
  typedef Soundtrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Soundtrack::VT_NAME, name);
  }
  void add_position(uint64_t position) {
    fbb_.AddElement<uint64_t>(Soundtrack::VT_POSITION, position, 0);
  }
  explicit SoundtrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Soundtrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Soundtrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Soundtrack> CreateSoundtrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t position = 0) {
  SoundtrackBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Soundtrack::Traits {
  using type = Soundtrack;
  static auto constexpr Create = CreateSoundtrack;
};

inline flatbuffers::Offset<Soundtrack> CreateSoundtrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t position = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return TEN::Save::CreateSoundtrack(
      _fbb,
      name__,
      position);
}

flatbuffers::Offset<Soundtrack> CreateSoundtrack(flatbuffers::FlatBufferBuilder &_fbb, const SoundtrackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VideoInfoT : public flatbuffers::NativeTable {
  typedef VideoInfo TableType;
  std::string name{};
  float position = 0.0f;
  bool silent = false;
  bool looped = false;
};

struct VideoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VideoInfoT NativeTableType;
  typedef VideoInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_POSITION = 6,
    VT_SILENT = 8,
    VT_LOOPED = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float position() const {
    return GetField<float>(VT_POSITION, 0.0f);
  }
  bool silent() const {
    return GetField<uint8_t>(VT_SILENT, 0) != 0;
  }
  bool looped() const {
    return GetField<uint8_t>(VT_LOOPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_SILENT) &&
           VerifyField<uint8_t>(verifier, VT_LOOPED) &&
           verifier.EndTable();
  }
  VideoInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VideoInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VideoInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VideoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VideoInfoBuilder {
  typedef VideoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(VideoInfo::VT_NAME, name);
  }
  void add_position(float position) {
    fbb_.AddElement<float>(VideoInfo::VT_POSITION, position, 0.0f);
  }
  void add_silent(bool silent) {
    fbb_.AddElement<uint8_t>(VideoInfo::VT_SILENT, static_cast<uint8_t>(silent), 0);
  }
  void add_looped(bool looped) {
    fbb_.AddElement<uint8_t>(VideoInfo::VT_LOOPED, static_cast<uint8_t>(looped), 0);
  }
  explicit VideoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VideoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VideoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<VideoInfo> CreateVideoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float position = 0.0f,
    bool silent = false,
    bool looped = false) {
  VideoInfoBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_name(name);
  builder_.add_looped(looped);
  builder_.add_silent(silent);
  return builder_.Finish();
}

struct VideoInfo::Traits {
  using type = VideoInfo;
  static auto constexpr Create = CreateVideoInfo;
};

inline flatbuffers::Offset<VideoInfo> CreateVideoInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float position = 0.0f,
    bool silent = false,
    bool looped = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return TEN::Save::CreateVideoInfo(
      _fbb,
      name__,
      position,
      silent,
      looped);
}

flatbuffers::Offset<VideoInfo> CreateVideoInfo(flatbuffers::FlatBufferBuilder &_fbb, const VideoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwarmObjectInfoT : public flatbuffers::NativeTable {
  typedef SwarmObjectInfo TableType;
  bool on = false;
  std::unique_ptr<TEN::Save::Pose> pose{};
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct SwarmObjectInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwarmObjectInfoT NativeTableType;
  typedef SwarmObjectInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_POSE = 6,
    VT_ROOM_NUMBER = 8,
    VT_FLAGS = 10
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  const TEN::Save::Pose *pose() const {
    return GetStruct<const TEN::Save::Pose *>(VT_POSE);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<TEN::Save::Pose>(verifier, VT_POSE) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SwarmObjectInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwarmObjectInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SwarmObjectInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwarmObjectInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwarmObjectInfoBuilder {
  typedef SwarmObjectInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(SwarmObjectInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_pose(const TEN::Save::Pose *pose) {
    fbb_.AddStruct(SwarmObjectInfo::VT_POSE, pose);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(SwarmObjectInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(SwarmObjectInfo::VT_FLAGS, flags, 0);
  }
  explicit SwarmObjectInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SwarmObjectInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwarmObjectInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwarmObjectInfo> CreateSwarmObjectInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    const TEN::Save::Pose *pose = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  SwarmObjectInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_pose(pose);
  builder_.add_on(on);
  return builder_.Finish();
}

struct SwarmObjectInfo::Traits {
  using type = SwarmObjectInfo;
  static auto constexpr Create = CreateSwarmObjectInfo;
};

flatbuffers::Offset<SwarmObjectInfo> CreateSwarmObjectInfo(flatbuffers::FlatBufferBuilder &_fbb, const SwarmObjectInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeSegmentT : public flatbuffers::NativeTable {
  typedef RopeSegment TableType;
  std::unique_ptr<TEN::Save::Vector3> segment{};
  std::unique_ptr<TEN::Save::Vector3> velocity{};
  std::unique_ptr<TEN::Save::Vector3> normalised_segment{};
  std::unique_ptr<TEN::Save::Vector3> mesh_segment{};
  std::unique_ptr<TEN::Save::Vector3> coord{};
};

struct RopeSegment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeSegmentT NativeTableType;
  typedef RopeSegmentBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4,
    VT_VELOCITY = 6,
    VT_NORMALISED_SEGMENT = 8,
    VT_MESH_SEGMENT = 10,
    VT_COORD = 12
  };
  const TEN::Save::Vector3 *segment() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_SEGMENT);
  }
  const TEN::Save::Vector3 *velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VELOCITY);
  }
  const TEN::Save::Vector3 *normalised_segment() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_NORMALISED_SEGMENT);
  }
  const TEN::Save::Vector3 *mesh_segment() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_MESH_SEGMENT);
  }
  const TEN::Save::Vector3 *coord() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_COORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_SEGMENT) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_NORMALISED_SEGMENT) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_MESH_SEGMENT) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_COORD) &&
           verifier.EndTable();
  }
  RopeSegmentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeSegmentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RopeSegment> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeSegmentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeSegmentBuilder {
  typedef RopeSegment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(const TEN::Save::Vector3 *segment) {
    fbb_.AddStruct(RopeSegment::VT_SEGMENT, segment);
  }
  void add_velocity(const TEN::Save::Vector3 *velocity) {
    fbb_.AddStruct(RopeSegment::VT_VELOCITY, velocity);
  }
  void add_normalised_segment(const TEN::Save::Vector3 *normalised_segment) {
    fbb_.AddStruct(RopeSegment::VT_NORMALISED_SEGMENT, normalised_segment);
  }
  void add_mesh_segment(const TEN::Save::Vector3 *mesh_segment) {
    fbb_.AddStruct(RopeSegment::VT_MESH_SEGMENT, mesh_segment);
  }
  void add_coord(const TEN::Save::Vector3 *coord) {
    fbb_.AddStruct(RopeSegment::VT_COORD, coord);
  }
  explicit RopeSegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RopeSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RopeSegment>(end);
    return o;
  }
};

inline flatbuffers::Offset<RopeSegment> CreateRopeSegment(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *segment = 0,
    const TEN::Save::Vector3 *velocity = 0,
    const TEN::Save::Vector3 *normalised_segment = 0,
    const TEN::Save::Vector3 *mesh_segment = 0,
    const TEN::Save::Vector3 *coord = 0) {
  RopeSegmentBuilder builder_(_fbb);
  builder_.add_coord(coord);
  builder_.add_mesh_segment(mesh_segment);
  builder_.add_normalised_segment(normalised_segment);
  builder_.add_velocity(velocity);
  builder_.add_segment(segment);
  return builder_.Finish();
}

struct RopeSegment::Traits {
  using type = RopeSegment;
  static auto constexpr Create = CreateRopeSegment;
};

flatbuffers::Offset<RopeSegment> CreateRopeSegment(flatbuffers::FlatBufferBuilder &_fbb, const RopeSegmentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeT : public flatbuffers::NativeTable {
  typedef Rope TableType;
  std::vector<std::unique_ptr<TEN::Save::RopeSegmentT>> segments{};
  std::unique_ptr<TEN::Save::Vector3> position{};
  int32_t segment_length = 0;
  int32_t active = 0;
  int32_t coiled = 0;
};

struct Rope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeT NativeTableType;
  typedef RopeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENTS = 4,
    VT_POSITION = 6,
    VT_SEGMENT_LENGTH = 8,
    VT_ACTIVE = 10,
    VT_COILED = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RopeSegment>> *segments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RopeSegment>> *>(VT_SEGMENTS);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  int32_t segment_length() const {
    return GetField<int32_t>(VT_SEGMENT_LENGTH, 0);
  }
  int32_t active() const {
    return GetField<int32_t>(VT_ACTIVE, 0);
  }
  int32_t coiled() const {
    return GetField<int32_t>(VT_COILED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<int32_t>(verifier, VT_SEGMENT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_COILED) &&
           verifier.EndTable();
  }
  RopeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rope> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeBuilder {
  typedef Rope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RopeSegment>>> segments) {
    fbb_.AddOffset(Rope::VT_SEGMENTS, segments);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Rope::VT_POSITION, position);
  }
  void add_segment_length(int32_t segment_length) {
    fbb_.AddElement<int32_t>(Rope::VT_SEGMENT_LENGTH, segment_length, 0);
  }
  void add_active(int32_t active) {
    fbb_.AddElement<int32_t>(Rope::VT_ACTIVE, active, 0);
  }
  void add_coiled(int32_t coiled) {
    fbb_.AddElement<int32_t>(Rope::VT_COILED, coiled, 0);
  }
  explicit RopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rope>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rope> CreateRope(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RopeSegment>>> segments = 0,
    const TEN::Save::Vector3 *position = 0,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  RopeBuilder builder_(_fbb);
  builder_.add_coiled(coiled);
  builder_.add_active(active);
  builder_.add_segment_length(segment_length);
  builder_.add_position(position);
  builder_.add_segments(segments);
  return builder_.Finish();
}

struct Rope::Traits {
  using type = Rope;
  static auto constexpr Create = CreateRope;
};

inline flatbuffers::Offset<Rope> CreateRopeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TEN::Save::RopeSegment>> *segments = nullptr,
    const TEN::Save::Vector3 *position = 0,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  auto segments__ = segments ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RopeSegment>>(*segments) : 0;
  return TEN::Save::CreateRope(
      _fbb,
      segments__,
      position,
      segment_length,
      active,
      coiled);
}

flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PendulumT : public flatbuffers::NativeTable {
  typedef Pendulum TableType;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector3> velocity{};
  int32_t node = 0;
};

struct Pendulum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PendulumT NativeTableType;
  typedef PendulumBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6,
    VT_NODE = 8
  };
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector3 *velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VELOCITY);
  }
  int32_t node() const {
    return GetField<int32_t>(VT_NODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_NODE) &&
           verifier.EndTable();
  }
  PendulumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pendulum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PendulumBuilder {
  typedef Pendulum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Pendulum::VT_POSITION, position);
  }
  void add_velocity(const TEN::Save::Vector3 *velocity) {
    fbb_.AddStruct(Pendulum::VT_VELOCITY, velocity);
  }
  void add_node(int32_t node) {
    fbb_.AddElement<int32_t>(Pendulum::VT_NODE, node, 0);
  }
  explicit PendulumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pendulum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pendulum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pendulum> CreatePendulum(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector3 *velocity = 0,
    int32_t node = 0) {
  PendulumBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Pendulum::Traits {
  using type = Pendulum;
  static auto constexpr Create = CreatePendulum;
};

flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventSetT : public flatbuffers::NativeTable {
  typedef EventSet TableType;
  int32_t index = 0;
  std::vector<bool> statuses{};
  std::vector<int32_t> call_counters{};
};

struct EventSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventSetT NativeTableType;
  typedef EventSetBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_STATUSES = 6,
    VT_CALL_COUNTERS = 8
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *statuses() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_STATUSES);
  }
  const flatbuffers::Vector<int32_t> *call_counters() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CALL_COUNTERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_STATUSES) &&
           verifier.VerifyVector(statuses()) &&
           VerifyOffset(verifier, VT_CALL_COUNTERS) &&
           verifier.VerifyVector(call_counters()) &&
           verifier.EndTable();
  }
  EventSetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventSetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventSet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventSetBuilder {
  typedef EventSet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(EventSet::VT_INDEX, index, 0);
  }
  void add_statuses(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> statuses) {
    fbb_.AddOffset(EventSet::VT_STATUSES, statuses);
  }
  void add_call_counters(flatbuffers::Offset<flatbuffers::Vector<int32_t>> call_counters) {
    fbb_.AddOffset(EventSet::VT_CALL_COUNTERS, call_counters);
  }
  explicit EventSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EventSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventSet> CreateEventSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> statuses = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> call_counters = 0) {
  EventSetBuilder builder_(_fbb);
  builder_.add_call_counters(call_counters);
  builder_.add_statuses(statuses);
  builder_.add_index(index);
  return builder_.Finish();
}

struct EventSet::Traits {
  using type = EventSet;
  static auto constexpr Create = CreateEventSet;
};

inline flatbuffers::Offset<EventSet> CreateEventSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    const std::vector<uint8_t> *statuses = nullptr,
    const std::vector<int32_t> *call_counters = nullptr) {
  auto statuses__ = statuses ? _fbb.CreateVector<uint8_t>(*statuses) : 0;
  auto call_counters__ = call_counters ? _fbb.CreateVector<int32_t>(*call_counters) : 0;
  return TEN::Save::CreateEventSet(
      _fbb,
      index,
      statuses__,
      call_counters__);
}

flatbuffers::Offset<EventSet> CreateEventSet(flatbuffers::FlatBufferBuilder &_fbb, const EventSetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolumeStateT : public flatbuffers::NativeTable {
  typedef VolumeState TableType;
  int32_t status = 0;
  int32_t activator = 0;
  int32_t timestamp = 0;
};

struct VolumeState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VolumeStateT NativeTableType;
  typedef VolumeStateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_ACTIVATOR = 6,
    VT_TIMESTAMP = 8
  };
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  int32_t activator() const {
    return GetField<int32_t>(VT_ACTIVATOR, 0);
  }
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_ACTIVATOR) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
  VolumeStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolumeStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VolumeState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VolumeStateBuilder {
  typedef VolumeState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(VolumeState::VT_STATUS, status, 0);
  }
  void add_activator(int32_t activator) {
    fbb_.AddElement<int32_t>(VolumeState::VT_ACTIVATOR, activator, 0);
  }
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(VolumeState::VT_TIMESTAMP, timestamp, 0);
  }
  explicit VolumeStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VolumeState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VolumeState>(end);
    return o;
  }
};

inline flatbuffers::Offset<VolumeState> CreateVolumeState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    int32_t activator = 0,
    int32_t timestamp = 0) {
  VolumeStateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_activator(activator);
  builder_.add_status(status);
  return builder_.Finish();
}

struct VolumeState::Traits {
  using type = VolumeState;
  static auto constexpr Create = CreateVolumeState;
};

flatbuffers::Offset<VolumeState> CreateVolumeState(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolumeT : public flatbuffers::NativeTable {
  typedef Volume TableType;
  std::string name{};
  int32_t number = 0;
  int32_t room_number = 0;
  bool enabled = false;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector4> rotation{};
  std::unique_ptr<TEN::Save::Vector3> scale{};
  std::vector<std::unique_ptr<TEN::Save::VolumeStateT>> queue{};
};

struct Volume FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VolumeT NativeTableType;
  typedef VolumeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NUMBER = 6,
    VT_ROOM_NUMBER = 8,
    VT_ENABLED = 10,
    VT_POSITION = 12,
    VT_ROTATION = 14,
    VT_SCALE = 16,
    VT_QUEUE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector4 *rotation() const {
    return GetStruct<const TEN::Save::Vector4 *>(VT_ROTATION);
  }
  const TEN::Save::Vector3 *scale() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_SCALE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>> *queue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>> *>(VT_QUEUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector4>(verifier, VT_ROTATION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_SCALE) &&
           VerifyOffset(verifier, VT_QUEUE) &&
           verifier.VerifyVector(queue()) &&
           verifier.VerifyVectorOfTables(queue()) &&
           verifier.EndTable();
  }
  VolumeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolumeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Volume> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VolumeBuilder {
  typedef Volume Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Volume::VT_NAME, name);
  }
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(Volume::VT_NUMBER, number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(Volume::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(Volume::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Volume::VT_POSITION, position);
  }
  void add_rotation(const TEN::Save::Vector4 *rotation) {
    fbb_.AddStruct(Volume::VT_ROTATION, rotation);
  }
  void add_scale(const TEN::Save::Vector3 *scale) {
    fbb_.AddStruct(Volume::VT_SCALE, scale);
  }
  void add_queue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>>> queue) {
    fbb_.AddOffset(Volume::VT_QUEUE, queue);
  }
  explicit VolumeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Volume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Volume>(end);
    return o;
  }
};

inline flatbuffers::Offset<Volume> CreateVolume(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t number = 0,
    int32_t room_number = 0,
    bool enabled = false,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector4 *rotation = 0,
    const TEN::Save::Vector3 *scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::VolumeState>>> queue = 0) {
  VolumeBuilder builder_(_fbb);
  builder_.add_queue(queue);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_room_number(room_number);
  builder_.add_number(number);
  builder_.add_name(name);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct Volume::Traits {
  using type = Volume;
  static auto constexpr Create = CreateVolume;
};

inline flatbuffers::Offset<Volume> CreateVolumeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t number = 0,
    int32_t room_number = 0,
    bool enabled = false,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector4 *rotation = 0,
    const TEN::Save::Vector3 *scale = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::VolumeState>> *queue = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto queue__ = queue ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::VolumeState>>(*queue) : 0;
  return TEN::Save::CreateVolume(
      _fbb,
      name__,
      number,
      room_number,
      enabled,
      position,
      rotation,
      scale,
      queue__);
}

flatbuffers::Offset<Volume> CreateVolume(flatbuffers::FlatBufferBuilder &_fbb, const VolumeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FishDataT : public flatbuffers::NativeTable {
  typedef FishData TableType;
  bool is_patrolling = false;
  bool is_lethal = false;
  int32_t leader_item_number = 0;
  float life = 0.0f;
  int32_t mesh_index = 0;
  std::unique_ptr<TEN::Save::EulerAngles> orientation{};
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector3> position_target{};
  int32_t room_number = 0;
  int32_t target_item_number = 0;
  float undulation = 0.0f;
  float velocity = 0.0f;
};

struct FishData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FishDataT NativeTableType;
  typedef FishDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_PATROLLING = 4,
    VT_IS_LETHAL = 6,
    VT_LEADER_ITEM_NUMBER = 8,
    VT_LIFE = 10,
    VT_MESH_INDEX = 12,
    VT_ORIENTATION = 14,
    VT_POSITION = 16,
    VT_POSITION_TARGET = 18,
    VT_ROOM_NUMBER = 20,
    VT_TARGET_ITEM_NUMBER = 22,
    VT_UNDULATION = 24,
    VT_VELOCITY = 26
  };
  bool is_patrolling() const {
    return GetField<uint8_t>(VT_IS_PATROLLING, 0) != 0;
  }
  bool is_lethal() const {
    return GetField<uint8_t>(VT_IS_LETHAL, 0) != 0;
  }
  int32_t leader_item_number() const {
    return GetField<int32_t>(VT_LEADER_ITEM_NUMBER, 0);
  }
  float life() const {
    return GetField<float>(VT_LIFE, 0.0f);
  }
  int32_t mesh_index() const {
    return GetField<int32_t>(VT_MESH_INDEX, 0);
  }
  const TEN::Save::EulerAngles *orientation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_ORIENTATION);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector3 *position_target() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION_TARGET);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t target_item_number() const {
    return GetField<int32_t>(VT_TARGET_ITEM_NUMBER, 0);
  }
  float undulation() const {
    return GetField<float>(VT_UNDULATION, 0.0f);
  }
  float velocity() const {
    return GetField<float>(VT_VELOCITY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_PATROLLING) &&
           VerifyField<uint8_t>(verifier, VT_IS_LETHAL) &&
           VerifyField<int32_t>(verifier, VT_LEADER_ITEM_NUMBER) &&
           VerifyField<float>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_MESH_INDEX) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_ORIENTATION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION_TARGET) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_TARGET_ITEM_NUMBER) &&
           VerifyField<float>(verifier, VT_UNDULATION) &&
           VerifyField<float>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  FishDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FishDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FishData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FishDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FishDataBuilder {
  typedef FishData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_patrolling(bool is_patrolling) {
    fbb_.AddElement<uint8_t>(FishData::VT_IS_PATROLLING, static_cast<uint8_t>(is_patrolling), 0);
  }
  void add_is_lethal(bool is_lethal) {
    fbb_.AddElement<uint8_t>(FishData::VT_IS_LETHAL, static_cast<uint8_t>(is_lethal), 0);
  }
  void add_leader_item_number(int32_t leader_item_number) {
    fbb_.AddElement<int32_t>(FishData::VT_LEADER_ITEM_NUMBER, leader_item_number, 0);
  }
  void add_life(float life) {
    fbb_.AddElement<float>(FishData::VT_LIFE, life, 0.0f);
  }
  void add_mesh_index(int32_t mesh_index) {
    fbb_.AddElement<int32_t>(FishData::VT_MESH_INDEX, mesh_index, 0);
  }
  void add_orientation(const TEN::Save::EulerAngles *orientation) {
    fbb_.AddStruct(FishData::VT_ORIENTATION, orientation);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(FishData::VT_POSITION, position);
  }
  void add_position_target(const TEN::Save::Vector3 *position_target) {
    fbb_.AddStruct(FishData::VT_POSITION_TARGET, position_target);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(FishData::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_target_item_number(int32_t target_item_number) {
    fbb_.AddElement<int32_t>(FishData::VT_TARGET_ITEM_NUMBER, target_item_number, 0);
  }
  void add_undulation(float undulation) {
    fbb_.AddElement<float>(FishData::VT_UNDULATION, undulation, 0.0f);
  }
  void add_velocity(float velocity) {
    fbb_.AddElement<float>(FishData::VT_VELOCITY, velocity, 0.0f);
  }
  explicit FishDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FishData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FishData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FishData> CreateFishData(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_patrolling = false,
    bool is_lethal = false,
    int32_t leader_item_number = 0,
    float life = 0.0f,
    int32_t mesh_index = 0,
    const TEN::Save::EulerAngles *orientation = 0,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector3 *position_target = 0,
    int32_t room_number = 0,
    int32_t target_item_number = 0,
    float undulation = 0.0f,
    float velocity = 0.0f) {
  FishDataBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_undulation(undulation);
  builder_.add_target_item_number(target_item_number);
  builder_.add_room_number(room_number);
  builder_.add_position_target(position_target);
  builder_.add_position(position);
  builder_.add_orientation(orientation);
  builder_.add_mesh_index(mesh_index);
  builder_.add_life(life);
  builder_.add_leader_item_number(leader_item_number);
  builder_.add_is_lethal(is_lethal);
  builder_.add_is_patrolling(is_patrolling);
  return builder_.Finish();
}

struct FishData::Traits {
  using type = FishData;
  static auto constexpr Create = CreateFishData;
};

flatbuffers::Offset<FishData> CreateFishData(flatbuffers::FlatBufferBuilder &_fbb, const FishDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FireflyDataT : public flatbuffers::NativeTable {
  typedef FireflyData TableType;
  int32_t sprite_index = 0;
  int32_t sprite_id = 0;
  int32_t blend_mode = 0;
  int32_t scalar = 0;
  std::unique_ptr<TEN::Save::Vector3> position{};
  int32_t room_number = 0;
  std::unique_ptr<TEN::Save::Vector3> position_target{};
  std::unique_ptr<TEN::Save::EulerAngles> orientation{};
  float velocity = 0.0f;
  int32_t target_item_number = 0;
  float z_vel = 0.0f;
  float life = 0.0f;
  int32_t number = 0;
  int32_t d_r = 0;
  int32_t d_g = 0;
  int32_t d_b = 0;
  int32_t r = 0;
  int32_t g = 0;
  int32_t b = 0;
  bool on = false;
  float size = 0.0f;
  int32_t rot_Ang = 0;
};

struct FireflyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FireflyDataT NativeTableType;
  typedef FireflyDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPRITE_INDEX = 4,
    VT_SPRITE_ID = 6,
    VT_BLEND_MODE = 8,
    VT_SCALAR = 10,
    VT_POSITION = 12,
    VT_ROOM_NUMBER = 14,
    VT_POSITION_TARGET = 16,
    VT_ORIENTATION = 18,
    VT_VELOCITY = 20,
    VT_TARGET_ITEM_NUMBER = 22,
    VT_Z_VEL = 24,
    VT_LIFE = 26,
    VT_NUMBER = 28,
    VT_D_R = 30,
    VT_D_G = 32,
    VT_D_B = 34,
    VT_R = 36,
    VT_G = 38,
    VT_B = 40,
    VT_ON = 42,
    VT_SIZE = 44,
    VT_ROT_ANG = 46
  };
  int32_t sprite_index() const {
    return GetField<int32_t>(VT_SPRITE_INDEX, 0);
  }
  int32_t sprite_id() const {
    return GetField<int32_t>(VT_SPRITE_ID, 0);
  }
  int32_t blend_mode() const {
    return GetField<int32_t>(VT_BLEND_MODE, 0);
  }
  int32_t scalar() const {
    return GetField<int32_t>(VT_SCALAR, 0);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  const TEN::Save::Vector3 *position_target() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION_TARGET);
  }
  const TEN::Save::EulerAngles *orientation() const {
    return GetStruct<const TEN::Save::EulerAngles *>(VT_ORIENTATION);
  }
  float velocity() const {
    return GetField<float>(VT_VELOCITY, 0.0f);
  }
  int32_t target_item_number() const {
    return GetField<int32_t>(VT_TARGET_ITEM_NUMBER, 0);
  }
  float z_vel() const {
    return GetField<float>(VT_Z_VEL, 0.0f);
  }
  float life() const {
    return GetField<float>(VT_LIFE, 0.0f);
  }
  int32_t number() const {
    return GetField<int32_t>(VT_NUMBER, 0);
  }
  int32_t d_r() const {
    return GetField<int32_t>(VT_D_R, 0);
  }
  int32_t d_g() const {
    return GetField<int32_t>(VT_D_G, 0);
  }
  int32_t d_b() const {
    return GetField<int32_t>(VT_D_B, 0);
  }
  int32_t r() const {
    return GetField<int32_t>(VT_R, 0);
  }
  int32_t g() const {
    return GetField<int32_t>(VT_G, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  int32_t rot_Ang() const {
    return GetField<int32_t>(VT_ROT_ANG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SPRITE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_SPRITE_ID) &&
           VerifyField<int32_t>(verifier, VT_BLEND_MODE) &&
           VerifyField<int32_t>(verifier, VT_SCALAR) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION_TARGET) &&
           VerifyField<TEN::Save::EulerAngles>(verifier, VT_ORIENTATION) &&
           VerifyField<float>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_TARGET_ITEM_NUMBER) &&
           VerifyField<float>(verifier, VT_Z_VEL) &&
           VerifyField<float>(verifier, VT_LIFE) &&
           VerifyField<int32_t>(verifier, VT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_D_R) &&
           VerifyField<int32_t>(verifier, VT_D_G) &&
           VerifyField<int32_t>(verifier, VT_D_B) &&
           VerifyField<int32_t>(verifier, VT_R) &&
           VerifyField<int32_t>(verifier, VT_G) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<float>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_ROT_ANG) &&
           verifier.EndTable();
  }
  FireflyDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FireflyDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FireflyData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FireflyDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FireflyDataBuilder {
  typedef FireflyData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sprite_index(int32_t sprite_index) {
    fbb_.AddElement<int32_t>(FireflyData::VT_SPRITE_INDEX, sprite_index, 0);
  }
  void add_sprite_id(int32_t sprite_id) {
    fbb_.AddElement<int32_t>(FireflyData::VT_SPRITE_ID, sprite_id, 0);
  }
  void add_blend_mode(int32_t blend_mode) {
    fbb_.AddElement<int32_t>(FireflyData::VT_BLEND_MODE, blend_mode, 0);
  }
  void add_scalar(int32_t scalar) {
    fbb_.AddElement<int32_t>(FireflyData::VT_SCALAR, scalar, 0);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(FireflyData::VT_POSITION, position);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(FireflyData::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_position_target(const TEN::Save::Vector3 *position_target) {
    fbb_.AddStruct(FireflyData::VT_POSITION_TARGET, position_target);
  }
  void add_orientation(const TEN::Save::EulerAngles *orientation) {
    fbb_.AddStruct(FireflyData::VT_ORIENTATION, orientation);
  }
  void add_velocity(float velocity) {
    fbb_.AddElement<float>(FireflyData::VT_VELOCITY, velocity, 0.0f);
  }
  void add_target_item_number(int32_t target_item_number) {
    fbb_.AddElement<int32_t>(FireflyData::VT_TARGET_ITEM_NUMBER, target_item_number, 0);
  }
  void add_z_vel(float z_vel) {
    fbb_.AddElement<float>(FireflyData::VT_Z_VEL, z_vel, 0.0f);
  }
  void add_life(float life) {
    fbb_.AddElement<float>(FireflyData::VT_LIFE, life, 0.0f);
  }
  void add_number(int32_t number) {
    fbb_.AddElement<int32_t>(FireflyData::VT_NUMBER, number, 0);
  }
  void add_d_r(int32_t d_r) {
    fbb_.AddElement<int32_t>(FireflyData::VT_D_R, d_r, 0);
  }
  void add_d_g(int32_t d_g) {
    fbb_.AddElement<int32_t>(FireflyData::VT_D_G, d_g, 0);
  }
  void add_d_b(int32_t d_b) {
    fbb_.AddElement<int32_t>(FireflyData::VT_D_B, d_b, 0);
  }
  void add_r(int32_t r) {
    fbb_.AddElement<int32_t>(FireflyData::VT_R, r, 0);
  }
  void add_g(int32_t g) {
    fbb_.AddElement<int32_t>(FireflyData::VT_G, g, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(FireflyData::VT_B, b, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(FireflyData::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(FireflyData::VT_SIZE, size, 0.0f);
  }
  void add_rot_Ang(int32_t rot_Ang) {
    fbb_.AddElement<int32_t>(FireflyData::VT_ROT_ANG, rot_Ang, 0);
  }
  explicit FireflyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FireflyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FireflyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FireflyData> CreateFireflyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sprite_index = 0,
    int32_t sprite_id = 0,
    int32_t blend_mode = 0,
    int32_t scalar = 0,
    const TEN::Save::Vector3 *position = 0,
    int32_t room_number = 0,
    const TEN::Save::Vector3 *position_target = 0,
    const TEN::Save::EulerAngles *orientation = 0,
    float velocity = 0.0f,
    int32_t target_item_number = 0,
    float z_vel = 0.0f,
    float life = 0.0f,
    int32_t number = 0,
    int32_t d_r = 0,
    int32_t d_g = 0,
    int32_t d_b = 0,
    int32_t r = 0,
    int32_t g = 0,
    int32_t b = 0,
    bool on = false,
    float size = 0.0f,
    int32_t rot_Ang = 0) {
  FireflyDataBuilder builder_(_fbb);
  builder_.add_rot_Ang(rot_Ang);
  builder_.add_size(size);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  builder_.add_d_b(d_b);
  builder_.add_d_g(d_g);
  builder_.add_d_r(d_r);
  builder_.add_number(number);
  builder_.add_life(life);
  builder_.add_z_vel(z_vel);
  builder_.add_target_item_number(target_item_number);
  builder_.add_velocity(velocity);
  builder_.add_orientation(orientation);
  builder_.add_position_target(position_target);
  builder_.add_room_number(room_number);
  builder_.add_position(position);
  builder_.add_scalar(scalar);
  builder_.add_blend_mode(blend_mode);
  builder_.add_sprite_id(sprite_id);
  builder_.add_sprite_index(sprite_index);
  builder_.add_on(on);
  return builder_.Finish();
}

struct FireflyData::Traits {
  using type = FireflyData;
  static auto constexpr Create = CreateFireflyData;
};

flatbuffers::Offset<FireflyData> CreateFireflyData(flatbuffers::FlatBufferBuilder &_fbb, const FireflyDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScriptTableT : public flatbuffers::NativeTable {
  typedef ScriptTable TableType;
  std::vector<TEN::Save::KeyValPair> keys_vals{};
};

struct ScriptTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScriptTableT NativeTableType;
  typedef ScriptTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS_VALS = 4
  };
  const flatbuffers::Vector<const TEN::Save::KeyValPair *> *keys_vals() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::KeyValPair *> *>(VT_KEYS_VALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS_VALS) &&
           verifier.VerifyVector(keys_vals()) &&
           verifier.EndTable();
  }
  ScriptTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScriptTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScriptTableBuilder {
  typedef ScriptTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys_vals(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals) {
    fbb_.AddOffset(ScriptTable::VT_KEYS_VALS, keys_vals);
  }
  explicit ScriptTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScriptTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScriptTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals = 0) {
  ScriptTableBuilder builder_(_fbb);
  builder_.add_keys_vals(keys_vals);
  return builder_.Finish();
}

struct ScriptTable::Traits {
  using type = ScriptTable;
  static auto constexpr Create = CreateScriptTable;
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<TEN::Save::KeyValPair> *keys_vals = nullptr) {
  auto keys_vals__ = keys_vals ? _fbb.CreateVectorOfStructs<TEN::Save::KeyValPair>(*keys_vals) : 0;
  return TEN::Save::CreateScriptTable(
      _fbb,
      keys_vals__);
}

flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct stringTableT : public flatbuffers::NativeTable {
  typedef stringTable TableType;
  std::string str{};
};

struct stringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef stringTableT NativeTableType;
  typedef stringTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4
  };
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
  stringTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<stringTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct stringTableBuilder {
  typedef stringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(stringTable::VT_STR, str);
  }
  explicit stringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<stringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<stringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<stringTable> CreatestringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  stringTableBuilder builder_(_fbb);
  builder_.add_str(str);
  return builder_.Finish();
}

struct stringTable::Traits {
  using type = stringTable;
  static auto constexpr Create = CreatestringTable;
};

inline flatbuffers::Offset<stringTable> CreatestringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return TEN::Save::CreatestringTable(
      _fbb,
      str__);
}

flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct doubleTableT : public flatbuffers::NativeTable {
  typedef doubleTable TableType;
  double scalar = 0.0;
};

struct doubleTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef doubleTableT NativeTableType;
  typedef doubleTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  double scalar() const {
    return GetField<double>(VT_SCALAR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  doubleTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<doubleTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct doubleTableBuilder {
  typedef doubleTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(double scalar) {
    fbb_.AddElement<double>(doubleTable::VT_SCALAR, scalar, 0.0);
  }
  explicit doubleTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<doubleTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<doubleTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scalar = 0.0) {
  doubleTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct doubleTable::Traits {
  using type = doubleTable;
  static auto constexpr Create = CreatedoubleTable;
};

flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct boolTableT : public flatbuffers::NativeTable {
  typedef boolTable TableType;
  bool scalar = false;
};

struct boolTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef boolTableT NativeTableType;
  typedef boolTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  bool scalar() const {
    return GetField<uint8_t>(VT_SCALAR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  boolTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(boolTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<boolTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct boolTableBuilder {
  typedef boolTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(bool scalar) {
    fbb_.AddElement<uint8_t>(boolTable::VT_SCALAR, static_cast<uint8_t>(scalar), 0);
  }
  explicit boolTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<boolTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<boolTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<boolTable> CreateboolTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool scalar = false) {
  boolTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct boolTable::Traits {
  using type = boolTable;
  static auto constexpr Create = CreateboolTable;
};

flatbuffers::Offset<boolTable> CreateboolTable(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct timeTableT : public flatbuffers::NativeTable {
  typedef timeTable TableType;
  int32_t scalar = 0;
};

struct timeTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef timeTableT NativeTableType;
  typedef timeTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  int32_t scalar() const {
    return GetField<int32_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  timeTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(timeTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<timeTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const timeTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct timeTableBuilder {
  typedef timeTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(int32_t scalar) {
    fbb_.AddElement<int32_t>(timeTable::VT_SCALAR, scalar, 0);
  }
  explicit timeTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<timeTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<timeTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<timeTable> CreatetimeTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t scalar = 0) {
  timeTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct timeTable::Traits {
  using type = timeTable;
  static auto constexpr Create = CreatetimeTable;
};

flatbuffers::Offset<timeTable> CreatetimeTable(flatbuffers::FlatBufferBuilder &_fbb, const timeTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct vec2TableT : public flatbuffers::NativeTable {
  typedef vec2Table TableType;
  std::unique_ptr<TEN::Save::Vector2> vec{};
};

struct vec2Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef vec2TableT NativeTableType;
  typedef vec2TableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEC = 4
  };
  const TEN::Save::Vector2 *vec() const {
    return GetStruct<const TEN::Save::Vector2 *>(VT_VEC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector2>(verifier, VT_VEC) &&
           verifier.EndTable();
  }
  vec2TableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(vec2TableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<vec2Table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const vec2TableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct vec2TableBuilder {
  typedef vec2Table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vec(const TEN::Save::Vector2 *vec) {
    fbb_.AddStruct(vec2Table::VT_VEC, vec);
  }
  explicit vec2TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<vec2Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<vec2Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<vec2Table> Createvec2Table(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector2 *vec = 0) {
  vec2TableBuilder builder_(_fbb);
  builder_.add_vec(vec);
  return builder_.Finish();
}

struct vec2Table::Traits {
  using type = vec2Table;
  static auto constexpr Create = Createvec2Table;
};

flatbuffers::Offset<vec2Table> Createvec2Table(flatbuffers::FlatBufferBuilder &_fbb, const vec2TableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct vec3TableT : public flatbuffers::NativeTable {
  typedef vec3Table TableType;
  std::unique_ptr<TEN::Save::Vector3> vec{};
};

struct vec3Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef vec3TableT NativeTableType;
  typedef vec3TableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEC = 4
  };
  const TEN::Save::Vector3 *vec() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VEC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VEC) &&
           verifier.EndTable();
  }
  vec3TableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(vec3TableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<vec3Table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const vec3TableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct vec3TableBuilder {
  typedef vec3Table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vec(const TEN::Save::Vector3 *vec) {
    fbb_.AddStruct(vec3Table::VT_VEC, vec);
  }
  explicit vec3TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<vec3Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<vec3Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<vec3Table> Createvec3Table(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *vec = 0) {
  vec3TableBuilder builder_(_fbb);
  builder_.add_vec(vec);
  return builder_.Finish();
}

struct vec3Table::Traits {
  using type = vec3Table;
  static auto constexpr Create = Createvec3Table;
};

flatbuffers::Offset<vec3Table> Createvec3Table(flatbuffers::FlatBufferBuilder &_fbb, const vec3TableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct rotationTableT : public flatbuffers::NativeTable {
  typedef rotationTable TableType;
  std::unique_ptr<TEN::Save::Vector3> vec{};
};

struct rotationTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef rotationTableT NativeTableType;
  typedef rotationTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEC = 4
  };
  const TEN::Save::Vector3 *vec() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VEC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VEC) &&
           verifier.EndTable();
  }
  rotationTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(rotationTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<rotationTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const rotationTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct rotationTableBuilder {
  typedef rotationTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vec(const TEN::Save::Vector3 *vec) {
    fbb_.AddStruct(rotationTable::VT_VEC, vec);
  }
  explicit rotationTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<rotationTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<rotationTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<rotationTable> CreaterotationTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *vec = 0) {
  rotationTableBuilder builder_(_fbb);
  builder_.add_vec(vec);
  return builder_.Finish();
}

struct rotationTable::Traits {
  using type = rotationTable;
  static auto constexpr Create = CreaterotationTable;
};

flatbuffers::Offset<rotationTable> CreaterotationTable(flatbuffers::FlatBufferBuilder &_fbb, const rotationTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct colorTableT : public flatbuffers::NativeTable {
  typedef colorTable TableType;
  uint32_t color = 0;
};

struct colorTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef colorTableT NativeTableType;
  typedef colorTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4
  };
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  colorTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(colorTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<colorTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const colorTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct colorTableBuilder {
  typedef colorTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(colorTable::VT_COLOR, color, 0);
  }
  explicit colorTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<colorTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<colorTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<colorTable> CreatecolorTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t color = 0) {
  colorTableBuilder builder_(_fbb);
  builder_.add_color(color);
  return builder_.Finish();
}

struct colorTable::Traits {
  using type = colorTable;
  static auto constexpr Create = CreatecolorTable;
};

flatbuffers::Offset<colorTable> CreatecolorTable(flatbuffers::FlatBufferBuilder &_fbb, const colorTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct funcNameTableT : public flatbuffers::NativeTable {
  typedef funcNameTable TableType;
  std::string str{};
};

struct funcNameTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef funcNameTableT NativeTableType;
  typedef funcNameTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4
  };
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
  funcNameTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(funcNameTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<funcNameTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const funcNameTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct funcNameTableBuilder {
  typedef funcNameTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(funcNameTable::VT_STR, str);
  }
  explicit funcNameTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<funcNameTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<funcNameTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<funcNameTable> CreatefuncNameTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  funcNameTableBuilder builder_(_fbb);
  builder_.add_str(str);
  return builder_.Finish();
}

struct funcNameTable::Traits {
  using type = funcNameTable;
  static auto constexpr Create = CreatefuncNameTable;
};

inline flatbuffers::Offset<funcNameTable> CreatefuncNameTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return TEN::Save::CreatefuncNameTable(
      _fbb,
      str__);
}

flatbuffers::Offset<funcNameTable> CreatefuncNameTable(flatbuffers::FlatBufferBuilder &_fbb, const funcNameTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionTableT : public flatbuffers::NativeTable {
  typedef UnionTable TableType;
  TEN::Save::VarUnionUnion u{};
};

struct UnionTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionTableT NativeTableType;
  typedef UnionTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U_TYPE = 4,
    VT_U = 6
  };
  TEN::Save::VarUnion u_type() const {
    return static_cast<TEN::Save::VarUnion>(GetField<uint8_t>(VT_U_TYPE, 0));
  }
  const void *u() const {
    return GetPointer<const void *>(VT_U);
  }
  template<typename T> const T *u_as() const;
  const TEN::Save::stringTable *u_as_str() const {
    return u_type() == TEN::Save::VarUnion::str ? static_cast<const TEN::Save::stringTable *>(u()) : nullptr;
  }
  const TEN::Save::ScriptTable *u_as_tab() const {
    return u_type() == TEN::Save::VarUnion::tab ? static_cast<const TEN::Save::ScriptTable *>(u()) : nullptr;
  }
  const TEN::Save::doubleTable *u_as_num() const {
    return u_type() == TEN::Save::VarUnion::num ? static_cast<const TEN::Save::doubleTable *>(u()) : nullptr;
  }
  const TEN::Save::boolTable *u_as_boolean() const {
    return u_type() == TEN::Save::VarUnion::boolean ? static_cast<const TEN::Save::boolTable *>(u()) : nullptr;
  }
  const TEN::Save::timeTable *u_as_time() const {
    return u_type() == TEN::Save::VarUnion::time ? static_cast<const TEN::Save::timeTable *>(u()) : nullptr;
  }
  const TEN::Save::vec2Table *u_as_vec2() const {
    return u_type() == TEN::Save::VarUnion::vec2 ? static_cast<const TEN::Save::vec2Table *>(u()) : nullptr;
  }
  const TEN::Save::vec3Table *u_as_vec3() const {
    return u_type() == TEN::Save::VarUnion::vec3 ? static_cast<const TEN::Save::vec3Table *>(u()) : nullptr;
  }
  const TEN::Save::rotationTable *u_as_rotation() const {
    return u_type() == TEN::Save::VarUnion::rotation ? static_cast<const TEN::Save::rotationTable *>(u()) : nullptr;
  }
  const TEN::Save::colorTable *u_as_color() const {
    return u_type() == TEN::Save::VarUnion::color ? static_cast<const TEN::Save::colorTable *>(u()) : nullptr;
  }
  const TEN::Save::funcNameTable *u_as_funcName() const {
    return u_type() == TEN::Save::VarUnion::funcName ? static_cast<const TEN::Save::funcNameTable *>(u()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_U_TYPE) &&
           VerifyOffset(verifier, VT_U) &&
           VerifyVarUnion(verifier, u(), u_type()) &&
           verifier.EndTable();
  }
  UnionTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::stringTable *UnionTable::u_as<TEN::Save::stringTable>() const {
  return u_as_str();
}

template<> inline const TEN::Save::ScriptTable *UnionTable::u_as<TEN::Save::ScriptTable>() const {
  return u_as_tab();
}

template<> inline const TEN::Save::doubleTable *UnionTable::u_as<TEN::Save::doubleTable>() const {
  return u_as_num();
}

template<> inline const TEN::Save::boolTable *UnionTable::u_as<TEN::Save::boolTable>() const {
  return u_as_boolean();
}

template<> inline const TEN::Save::timeTable *UnionTable::u_as<TEN::Save::timeTable>() const {
  return u_as_time();
}

template<> inline const TEN::Save::vec2Table *UnionTable::u_as<TEN::Save::vec2Table>() const {
  return u_as_vec2();
}

template<> inline const TEN::Save::vec3Table *UnionTable::u_as<TEN::Save::vec3Table>() const {
  return u_as_vec3();
}

template<> inline const TEN::Save::rotationTable *UnionTable::u_as<TEN::Save::rotationTable>() const {
  return u_as_rotation();
}

template<> inline const TEN::Save::colorTable *UnionTable::u_as<TEN::Save::colorTable>() const {
  return u_as_color();
}

template<> inline const TEN::Save::funcNameTable *UnionTable::u_as<TEN::Save::funcNameTable>() const {
  return u_as_funcName();
}

struct UnionTableBuilder {
  typedef UnionTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_u_type(TEN::Save::VarUnion u_type) {
    fbb_.AddElement<uint8_t>(UnionTable::VT_U_TYPE, static_cast<uint8_t>(u_type), 0);
  }
  void add_u(flatbuffers::Offset<void> u) {
    fbb_.AddOffset(UnionTable::VT_U, u);
  }
  explicit UnionTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionTable> CreateUnionTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    TEN::Save::VarUnion u_type = TEN::Save::VarUnion::NONE,
    flatbuffers::Offset<void> u = 0) {
  UnionTableBuilder builder_(_fbb);
  builder_.add_u(u);
  builder_.add_u_type(u_type);
  return builder_.Finish();
}

struct UnionTable::Traits {
  using type = UnionTable;
  static auto constexpr Create = CreateUnionTable;
};

flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionVecT : public flatbuffers::NativeTable {
  typedef UnionVec TableType;
  std::vector<std::unique_ptr<TEN::Save::UnionTableT>> members{};
};

struct UnionVec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionVecT NativeTableType;
  typedef UnionVecBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEMBERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
  UnionVecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionVec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnionVecBuilder {
  typedef UnionVec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members) {
    fbb_.AddOffset(UnionVec::VT_MEMBERS, members);
  }
  explicit UnionVecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionVec>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionVec> CreateUnionVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members = 0) {
  UnionVecBuilder builder_(_fbb);
  builder_.add_members(members);
  return builder_.Finish();
}

struct UnionVec::Traits {
  using type = UnionVec;
  static auto constexpr Create = CreateUnionVec;
};

inline flatbuffers::Offset<UnionVec> CreateUnionVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members = nullptr) {
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>>(*members) : 0;
  return TEN::Save::CreateUnionVec(
      _fbb,
      members__);
}

flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameHeaderT : public flatbuffers::NativeTable {
  typedef SaveGameHeader TableType;
  std::string level_name{};
  int32_t level_hash = 0;
  int32_t hours = 0;
  int32_t minutes = 0;
  int32_t seconds = 0;
  int32_t level = 0;
  int32_t timer = 0;
  int32_t count = 0;
};

struct SaveGameHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameHeaderT NativeTableType;
  typedef SaveGameHeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL_NAME = 4,
    VT_LEVEL_HASH = 6,
    VT_HOURS = 8,
    VT_MINUTES = 10,
    VT_SECONDS = 12,
    VT_LEVEL = 14,
    VT_TIMER = 16,
    VT_COUNT = 18
  };
  const flatbuffers::String *level_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEVEL_NAME);
  }
  int32_t level_hash() const {
    return GetField<int32_t>(VT_LEVEL_HASH, 0);
  }
  int32_t hours() const {
    return GetField<int32_t>(VT_HOURS, 0);
  }
  int32_t minutes() const {
    return GetField<int32_t>(VT_MINUTES, 0);
  }
  int32_t seconds() const {
    return GetField<int32_t>(VT_SECONDS, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEVEL_NAME) &&
           verifier.VerifyString(level_name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL_HASH) &&
           VerifyField<int32_t>(verifier, VT_HOURS) &&
           VerifyField<int32_t>(verifier, VT_MINUTES) &&
           VerifyField<int32_t>(verifier, VT_SECONDS) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  SaveGameHeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameHeader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameHeaderBuilder {
  typedef SaveGameHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level_name(flatbuffers::Offset<flatbuffers::String> level_name) {
    fbb_.AddOffset(SaveGameHeader::VT_LEVEL_NAME, level_name);
  }
  void add_level_hash(int32_t level_hash) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_LEVEL_HASH, level_hash, 0);
  }
  void add_hours(int32_t hours) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_HOURS, hours, 0);
  }
  void add_minutes(int32_t minutes) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_MINUTES, minutes, 0);
  }
  void add_seconds(int32_t seconds) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_SECONDS, seconds, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_LEVEL, level, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_TIMER, timer, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_COUNT, count, 0);
  }
  explicit SaveGameHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> level_name = 0,
    int32_t level_hash = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  SaveGameHeaderBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_timer(timer);
  builder_.add_level(level);
  builder_.add_seconds(seconds);
  builder_.add_minutes(minutes);
  builder_.add_hours(hours);
  builder_.add_level_hash(level_hash);
  builder_.add_level_name(level_name);
  return builder_.Finish();
}

struct SaveGameHeader::Traits {
  using type = SaveGameHeader;
  static auto constexpr Create = CreateSaveGameHeader;
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *level_name = nullptr,
    int32_t level_hash = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  auto level_name__ = level_name ? _fbb.CreateString(level_name) : 0;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      level_name__,
      level_hash,
      hours,
      minutes,
      seconds,
      level,
      timer,
      count);
}

flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameStatisticsT : public flatbuffers::NativeTable {
  typedef SaveGameStatistics TableType;
  int32_t ammo_hits = 0;
  int32_t ammo_used = 0;
  int32_t medipacks_used = 0;
  int32_t damage_taken = 0;
  int32_t distance = 0;
  int32_t kills = 0;
  int32_t pickups = 0;
  int32_t secrets = 0;
  int32_t timer = 0;
};

struct SaveGameStatistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameStatisticsT NativeTableType;
  typedef SaveGameStatisticsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMMO_HITS = 4,
    VT_AMMO_USED = 6,
    VT_MEDIPACKS_USED = 8,
    VT_DAMAGE_TAKEN = 10,
    VT_DISTANCE = 12,
    VT_KILLS = 14,
    VT_PICKUPS = 16,
    VT_SECRETS = 18,
    VT_TIMER = 20
  };
  int32_t ammo_hits() const {
    return GetField<int32_t>(VT_AMMO_HITS, 0);
  }
  int32_t ammo_used() const {
    return GetField<int32_t>(VT_AMMO_USED, 0);
  }
  int32_t medipacks_used() const {
    return GetField<int32_t>(VT_MEDIPACKS_USED, 0);
  }
  int32_t damage_taken() const {
    return GetField<int32_t>(VT_DAMAGE_TAKEN, 0);
  }
  int32_t distance() const {
    return GetField<int32_t>(VT_DISTANCE, 0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t pickups() const {
    return GetField<int32_t>(VT_PICKUPS, 0);
  }
  int32_t secrets() const {
    return GetField<int32_t>(VT_SECRETS, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AMMO_HITS) &&
           VerifyField<int32_t>(verifier, VT_AMMO_USED) &&
           VerifyField<int32_t>(verifier, VT_MEDIPACKS_USED) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE_TAKEN) &&
           VerifyField<int32_t>(verifier, VT_DISTANCE) &&
           VerifyField<int32_t>(verifier, VT_KILLS) &&
           VerifyField<int32_t>(verifier, VT_PICKUPS) &&
           VerifyField<int32_t>(verifier, VT_SECRETS) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           verifier.EndTable();
  }
  SaveGameStatisticsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameStatistics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameStatisticsBuilder {
  typedef SaveGameStatistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ammo_hits(int32_t ammo_hits) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_HITS, ammo_hits, 0);
  }
  void add_ammo_used(int32_t ammo_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_USED, ammo_used, 0);
  }
  void add_medipacks_used(int32_t medipacks_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_MEDIPACKS_USED, medipacks_used, 0);
  }
  void add_damage_taken(int32_t damage_taken) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_DAMAGE_TAKEN, damage_taken, 0);
  }
  void add_distance(int32_t distance) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_DISTANCE, distance, 0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_KILLS, kills, 0);
  }
  void add_pickups(int32_t pickups) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_PICKUPS, pickups, 0);
  }
  void add_secrets(int32_t secrets) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_SECRETS, secrets, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_TIMER, timer, 0);
  }
  explicit SaveGameStatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameStatistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameStatistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ammo_hits = 0,
    int32_t ammo_used = 0,
    int32_t medipacks_used = 0,
    int32_t damage_taken = 0,
    int32_t distance = 0,
    int32_t kills = 0,
    int32_t pickups = 0,
    int32_t secrets = 0,
    int32_t timer = 0) {
  SaveGameStatisticsBuilder builder_(_fbb);
  builder_.add_timer(timer);
  builder_.add_secrets(secrets);
  builder_.add_pickups(pickups);
  builder_.add_kills(kills);
  builder_.add_distance(distance);
  builder_.add_damage_taken(damage_taken);
  builder_.add_medipacks_used(medipacks_used);
  builder_.add_ammo_used(ammo_used);
  builder_.add_ammo_hits(ammo_hits);
  return builder_.Finish();
}

struct SaveGameStatistics::Traits {
  using type = SaveGameStatistics;
  static auto constexpr Create = CreateSaveGameStatistics;
};

flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameT : public flatbuffers::NativeTable {
  typedef SaveGame TableType;
  std::unique_ptr<TEN::Save::SaveGameHeaderT> header{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> game{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> level{};
  std::unique_ptr<TEN::Save::LevelDataT> level_data{};
  int32_t secret_bits = 0;
  std::unique_ptr<TEN::Save::CameraT> camera{};
  std::unique_ptr<TEN::Save::LaraT> lara{};
  std::vector<std::unique_ptr<TEN::Save::RoomT>> rooms{};
  std::vector<std::unique_ptr<TEN::Save::ItemT>> items{};
  int32_t next_item_free = 0;
  int32_t next_item_active = 0;
  std::vector<int32_t> room_items{};
  std::vector<std::unique_ptr<TEN::Save::FishDataT>> fish_swarm{};
  std::vector<std::unique_ptr<TEN::Save::FireflyDataT>> firefly_swarm{};
  std::vector<std::unique_ptr<TEN::Save::FXInfoT>> fxinfos{};
  int32_t next_fx_free = 0;
  int32_t next_fx_active = 0;
  std::vector<std::unique_ptr<TEN::Save::FixedCameraT>> fixed_cameras{};
  std::vector<std::unique_ptr<TEN::Save::SinkT>> sinks{};
  std::vector<std::unique_ptr<TEN::Save::StaticMeshInfoT>> static_meshes{};
  std::vector<std::unique_ptr<TEN::Save::FlyByCameraT>> flyby_cameras{};
  std::vector<std::unique_ptr<TEN::Save::ParticleInfoT>> particles{};
  std::vector<std::unique_ptr<TEN::Save::SwarmObjectInfoT>> rats{};
  std::vector<std::unique_ptr<TEN::Save::SwarmObjectInfoT>> spiders{};
  std::vector<std::unique_ptr<TEN::Save::SwarmObjectInfoT>> scarabs{};
  std::vector<std::unique_ptr<TEN::Save::SwarmObjectInfoT>> bats{};
  std::vector<int32_t> flip_maps{};
  std::vector<int32_t> flip_stats{};
  int32_t flip_effect = 0;
  int32_t flip_timer = 0;
  int32_t flip_status = 0;
  int16_t current_fov = 0;
  int32_t last_inv_item = 0;
  std::vector<int32_t> action_queue{};
  std::vector<std::unique_ptr<TEN::Save::SoundtrackT>> soundtracks{};
  std::vector<int32_t> cd_flags{};
  std::unique_ptr<TEN::Save::VideoInfoT> video{};
  int32_t postprocess_mode = 0;
  float postprocess_strength = 0.0f;
  std::unique_ptr<TEN::Save::Vector3> postprocess_tint{};
  std::unique_ptr<TEN::Save::RopeT> rope{};
  std::unique_ptr<TEN::Save::PendulumT> pendulum{};
  std::unique_ptr<TEN::Save::PendulumT> alternate_pendulum{};
  std::vector<std::unique_ptr<TEN::Save::VolumeT>> volumes{};
  std::vector<std::unique_ptr<TEN::Save::EventSetT>> global_event_sets{};
  std::vector<std::unique_ptr<TEN::Save::EventSetT>> volume_event_sets{};
  std::unique_ptr<TEN::Save::UnionVecT> script_vars{};
  std::vector<std::string> callbacks_pre_start{};
  std::vector<std::string> callbacks_post_start{};
  std::vector<std::string> callbacks_pre_end{};
  std::vector<std::string> callbacks_post_end{};
  std::vector<std::string> callbacks_pre_save{};
  std::vector<std::string> callbacks_post_save{};
  std::vector<std::string> callbacks_pre_load{};
  std::vector<std::string> callbacks_post_load{};
  std::vector<std::string> callbacks_pre_loop{};
  std::vector<std::string> callbacks_post_loop{};
  std::vector<std::string> callbacks_pre_useitem{};
  std::vector<std::string> callbacks_post_useitem{};
  std::vector<std::string> callbacks_pre_freeze{};
  std::vector<std::string> callbacks_post_freeze{};
};

struct SaveGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameT NativeTableType;
  typedef SaveGameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GAME = 6,
    VT_LEVEL = 8,
    VT_LEVEL_DATA = 10,
    VT_SECRET_BITS = 12,
    VT_CAMERA = 14,
    VT_LARA = 16,
    VT_ROOMS = 18,
    VT_ITEMS = 20,
    VT_NEXT_ITEM_FREE = 22,
    VT_NEXT_ITEM_ACTIVE = 24,
    VT_ROOM_ITEMS = 26,
    VT_FISH_SWARM = 28,
    VT_FIREFLY_SWARM = 30,
    VT_FXINFOS = 32,
    VT_NEXT_FX_FREE = 34,
    VT_NEXT_FX_ACTIVE = 36,
    VT_FIXED_CAMERAS = 38,
    VT_SINKS = 40,
    VT_STATIC_MESHES = 42,
    VT_FLYBY_CAMERAS = 44,
    VT_PARTICLES = 46,
    VT_RATS = 48,
    VT_SPIDERS = 50,
    VT_SCARABS = 52,
    VT_BATS = 54,
    VT_FLIP_MAPS = 56,
    VT_FLIP_STATS = 58,
    VT_FLIP_EFFECT = 60,
    VT_FLIP_TIMER = 62,
    VT_FLIP_STATUS = 64,
    VT_CURRENT_FOV = 66,
    VT_LAST_INV_ITEM = 68,
    VT_ACTION_QUEUE = 70,
    VT_SOUNDTRACKS = 72,
    VT_CD_FLAGS = 74,
    VT_VIDEO = 76,
    VT_POSTPROCESS_MODE = 78,
    VT_POSTPROCESS_STRENGTH = 80,
    VT_POSTPROCESS_TINT = 82,
    VT_ROPE = 84,
    VT_PENDULUM = 86,
    VT_ALTERNATE_PENDULUM = 88,
    VT_VOLUMES = 90,
    VT_GLOBAL_EVENT_SETS = 92,
    VT_VOLUME_EVENT_SETS = 94,
    VT_SCRIPT_VARS = 96,
    VT_CALLBACKS_PRE_START = 98,
    VT_CALLBACKS_POST_START = 100,
    VT_CALLBACKS_PRE_END = 102,
    VT_CALLBACKS_POST_END = 104,
    VT_CALLBACKS_PRE_SAVE = 106,
    VT_CALLBACKS_POST_SAVE = 108,
    VT_CALLBACKS_PRE_LOAD = 110,
    VT_CALLBACKS_POST_LOAD = 112,
    VT_CALLBACKS_PRE_LOOP = 114,
    VT_CALLBACKS_POST_LOOP = 116,
    VT_CALLBACKS_PRE_USEITEM = 118,
    VT_CALLBACKS_POST_USEITEM = 120,
    VT_CALLBACKS_PRE_FREEZE = 122,
    VT_CALLBACKS_POST_FREEZE = 124
  };
  const TEN::Save::SaveGameHeader *header() const {
    return GetPointer<const TEN::Save::SaveGameHeader *>(VT_HEADER);
  }
  const TEN::Save::SaveGameStatistics *game() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_GAME);
  }
  const TEN::Save::SaveGameStatistics *level() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_LEVEL);
  }
  const TEN::Save::LevelData *level_data() const {
    return GetPointer<const TEN::Save::LevelData *>(VT_LEVEL_DATA);
  }
  int32_t secret_bits() const {
    return GetField<int32_t>(VT_SECRET_BITS, 0);
  }
  const TEN::Save::Camera *camera() const {
    return GetPointer<const TEN::Save::Camera *>(VT_CAMERA);
  }
  const TEN::Save::Lara *lara() const {
    return GetPointer<const TEN::Save::Lara *>(VT_LARA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Room>> *rooms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Room>> *>(VT_ROOMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *>(VT_ITEMS);
  }
  int32_t next_item_free() const {
    return GetField<int32_t>(VT_NEXT_ITEM_FREE, 0);
  }
  int32_t next_item_active() const {
    return GetField<int32_t>(VT_NEXT_ITEM_ACTIVE, 0);
  }
  const flatbuffers::Vector<int32_t> *room_items() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ROOM_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FishData>> *fish_swarm() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FishData>> *>(VT_FISH_SWARM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FireflyData>> *firefly_swarm() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FireflyData>> *>(VT_FIREFLY_SWARM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>> *fxinfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>> *>(VT_FXINFOS);
  }
  int32_t next_fx_free() const {
    return GetField<int32_t>(VT_NEXT_FX_FREE, 0);
  }
  int32_t next_fx_active() const {
    return GetField<int32_t>(VT_NEXT_FX_ACTIVE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *>(VT_FIXED_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *>(VT_SINKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *>(VT_STATIC_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *>(VT_FLYBY_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *particles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *>(VT_PARTICLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *rats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *>(VT_RATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *spiders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *>(VT_SPIDERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *scarabs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *>(VT_SCARABS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *bats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *>(VT_BATS);
  }
  const flatbuffers::Vector<int32_t> *flip_maps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_MAPS);
  }
  const flatbuffers::Vector<int32_t> *flip_stats() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_STATS);
  }
  int32_t flip_effect() const {
    return GetField<int32_t>(VT_FLIP_EFFECT, 0);
  }
  int32_t flip_timer() const {
    return GetField<int32_t>(VT_FLIP_TIMER, 0);
  }
  int32_t flip_status() const {
    return GetField<int32_t>(VT_FLIP_STATUS, 0);
  }
  int16_t current_fov() const {
    return GetField<int16_t>(VT_CURRENT_FOV, 0);
  }
  int32_t last_inv_item() const {
    return GetField<int32_t>(VT_LAST_INV_ITEM, 0);
  }
  const flatbuffers::Vector<int32_t> *action_queue() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTION_QUEUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Soundtrack>> *soundtracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Soundtrack>> *>(VT_SOUNDTRACKS);
  }
  const flatbuffers::Vector<int32_t> *cd_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CD_FLAGS);
  }
  const TEN::Save::VideoInfo *video() const {
    return GetPointer<const TEN::Save::VideoInfo *>(VT_VIDEO);
  }
  int32_t postprocess_mode() const {
    return GetField<int32_t>(VT_POSTPROCESS_MODE, 0);
  }
  float postprocess_strength() const {
    return GetField<float>(VT_POSTPROCESS_STRENGTH, 0.0f);
  }
  const TEN::Save::Vector3 *postprocess_tint() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSTPROCESS_TINT);
  }
  const TEN::Save::Rope *rope() const {
    return GetPointer<const TEN::Save::Rope *>(VT_ROPE);
  }
  const TEN::Save::Pendulum *pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_PENDULUM);
  }
  const TEN::Save::Pendulum *alternate_pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_ALTERNATE_PENDULUM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Volume>> *volumes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Volume>> *>(VT_VOLUMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>> *global_event_sets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>> *>(VT_GLOBAL_EVENT_SETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>> *volume_event_sets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>> *>(VT_VOLUME_EVENT_SETS);
  }
  const TEN::Save::UnionVec *script_vars() const {
    return GetPointer<const TEN::Save::UnionVec *>(VT_SCRIPT_VARS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_start() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_START);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_start() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_START);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_end() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_END);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_end() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_END);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_save() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_SAVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_save() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_SAVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_load() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_LOAD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_load() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_LOAD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_loop() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_LOOP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_loop() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_LOOP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_useitem() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_USEITEM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_useitem() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_USEITEM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_freeze() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_PRE_FREEZE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_freeze() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CALLBACKS_POST_FREEZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_GAME) &&
           verifier.VerifyTable(game()) &&
           VerifyOffset(verifier, VT_LEVEL) &&
           verifier.VerifyTable(level()) &&
           VerifyOffset(verifier, VT_LEVEL_DATA) &&
           verifier.VerifyTable(level_data()) &&
           VerifyField<int32_t>(verifier, VT_SECRET_BITS) &&
           VerifyOffset(verifier, VT_CAMERA) &&
           verifier.VerifyTable(camera()) &&
           VerifyOffset(verifier, VT_LARA) &&
           verifier.VerifyTable(lara()) &&
           VerifyOffset(verifier, VT_ROOMS) &&
           verifier.VerifyVector(rooms()) &&
           verifier.VerifyVectorOfTables(rooms()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_FREE) &&
           VerifyField<int32_t>(verifier, VT_NEXT_ITEM_ACTIVE) &&
           VerifyOffset(verifier, VT_ROOM_ITEMS) &&
           verifier.VerifyVector(room_items()) &&
           VerifyOffset(verifier, VT_FISH_SWARM) &&
           verifier.VerifyVector(fish_swarm()) &&
           verifier.VerifyVectorOfTables(fish_swarm()) &&
           VerifyOffset(verifier, VT_FIREFLY_SWARM) &&
           verifier.VerifyVector(firefly_swarm()) &&
           verifier.VerifyVectorOfTables(firefly_swarm()) &&
           VerifyOffset(verifier, VT_FXINFOS) &&
           verifier.VerifyVector(fxinfos()) &&
           verifier.VerifyVectorOfTables(fxinfos()) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX_FREE) &&
           VerifyField<int32_t>(verifier, VT_NEXT_FX_ACTIVE) &&
           VerifyOffset(verifier, VT_FIXED_CAMERAS) &&
           verifier.VerifyVector(fixed_cameras()) &&
           verifier.VerifyVectorOfTables(fixed_cameras()) &&
           VerifyOffset(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_STATIC_MESHES) &&
           verifier.VerifyVector(static_meshes()) &&
           verifier.VerifyVectorOfTables(static_meshes()) &&
           VerifyOffset(verifier, VT_FLYBY_CAMERAS) &&
           verifier.VerifyVector(flyby_cameras()) &&
           verifier.VerifyVectorOfTables(flyby_cameras()) &&
           VerifyOffset(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffset(verifier, VT_RATS) &&
           verifier.VerifyVector(rats()) &&
           verifier.VerifyVectorOfTables(rats()) &&
           VerifyOffset(verifier, VT_SPIDERS) &&
           verifier.VerifyVector(spiders()) &&
           verifier.VerifyVectorOfTables(spiders()) &&
           VerifyOffset(verifier, VT_SCARABS) &&
           verifier.VerifyVector(scarabs()) &&
           verifier.VerifyVectorOfTables(scarabs()) &&
           VerifyOffset(verifier, VT_BATS) &&
           verifier.VerifyVector(bats()) &&
           verifier.VerifyVectorOfTables(bats()) &&
           VerifyOffset(verifier, VT_FLIP_MAPS) &&
           verifier.VerifyVector(flip_maps()) &&
           VerifyOffset(verifier, VT_FLIP_STATS) &&
           verifier.VerifyVector(flip_stats()) &&
           VerifyField<int32_t>(verifier, VT_FLIP_EFFECT) &&
           VerifyField<int32_t>(verifier, VT_FLIP_TIMER) &&
           VerifyField<int32_t>(verifier, VT_FLIP_STATUS) &&
           VerifyField<int16_t>(verifier, VT_CURRENT_FOV) &&
           VerifyField<int32_t>(verifier, VT_LAST_INV_ITEM) &&
           VerifyOffset(verifier, VT_ACTION_QUEUE) &&
           verifier.VerifyVector(action_queue()) &&
           VerifyOffset(verifier, VT_SOUNDTRACKS) &&
           verifier.VerifyVector(soundtracks()) &&
           verifier.VerifyVectorOfTables(soundtracks()) &&
           VerifyOffset(verifier, VT_CD_FLAGS) &&
           verifier.VerifyVector(cd_flags()) &&
           VerifyOffset(verifier, VT_VIDEO) &&
           verifier.VerifyTable(video()) &&
           VerifyField<int32_t>(verifier, VT_POSTPROCESS_MODE) &&
           VerifyField<float>(verifier, VT_POSTPROCESS_STRENGTH) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSTPROCESS_TINT) &&
           VerifyOffset(verifier, VT_ROPE) &&
           verifier.VerifyTable(rope()) &&
           VerifyOffset(verifier, VT_PENDULUM) &&
           verifier.VerifyTable(pendulum()) &&
           VerifyOffset(verifier, VT_ALTERNATE_PENDULUM) &&
           verifier.VerifyTable(alternate_pendulum()) &&
           VerifyOffset(verifier, VT_VOLUMES) &&
           verifier.VerifyVector(volumes()) &&
           verifier.VerifyVectorOfTables(volumes()) &&
           VerifyOffset(verifier, VT_GLOBAL_EVENT_SETS) &&
           verifier.VerifyVector(global_event_sets()) &&
           verifier.VerifyVectorOfTables(global_event_sets()) &&
           VerifyOffset(verifier, VT_VOLUME_EVENT_SETS) &&
           verifier.VerifyVector(volume_event_sets()) &&
           verifier.VerifyVectorOfTables(volume_event_sets()) &&
           VerifyOffset(verifier, VT_SCRIPT_VARS) &&
           verifier.VerifyTable(script_vars()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_START) &&
           verifier.VerifyVector(callbacks_pre_start()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_start()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_START) &&
           verifier.VerifyVector(callbacks_post_start()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_start()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_END) &&
           verifier.VerifyVector(callbacks_pre_end()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_end()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_END) &&
           verifier.VerifyVector(callbacks_post_end()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_end()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_SAVE) &&
           verifier.VerifyVector(callbacks_pre_save()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_save()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_SAVE) &&
           verifier.VerifyVector(callbacks_post_save()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_save()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_LOAD) &&
           verifier.VerifyVector(callbacks_pre_load()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_load()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_LOAD) &&
           verifier.VerifyVector(callbacks_post_load()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_load()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_LOOP) &&
           verifier.VerifyVector(callbacks_pre_loop()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_loop()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_LOOP) &&
           verifier.VerifyVector(callbacks_post_loop()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_loop()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_USEITEM) &&
           verifier.VerifyVector(callbacks_pre_useitem()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_useitem()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_USEITEM) &&
           verifier.VerifyVector(callbacks_post_useitem()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_useitem()) &&
           VerifyOffset(verifier, VT_CALLBACKS_PRE_FREEZE) &&
           verifier.VerifyVector(callbacks_pre_freeze()) &&
           verifier.VerifyVectorOfStrings(callbacks_pre_freeze()) &&
           VerifyOffset(verifier, VT_CALLBACKS_POST_FREEZE) &&
           verifier.VerifyVector(callbacks_post_freeze()) &&
           verifier.VerifyVectorOfStrings(callbacks_post_freeze()) &&
           verifier.EndTable();
  }
  SaveGameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameBuilder {
  typedef SaveGame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<TEN::Save::SaveGameHeader> header) {
    fbb_.AddOffset(SaveGame::VT_HEADER, header);
  }
  void add_game(flatbuffers::Offset<TEN::Save::SaveGameStatistics> game) {
    fbb_.AddOffset(SaveGame::VT_GAME, game);
  }
  void add_level(flatbuffers::Offset<TEN::Save::SaveGameStatistics> level) {
    fbb_.AddOffset(SaveGame::VT_LEVEL, level);
  }
  void add_level_data(flatbuffers::Offset<TEN::Save::LevelData> level_data) {
    fbb_.AddOffset(SaveGame::VT_LEVEL_DATA, level_data);
  }
  void add_secret_bits(int32_t secret_bits) {
    fbb_.AddElement<int32_t>(SaveGame::VT_SECRET_BITS, secret_bits, 0);
  }
  void add_camera(flatbuffers::Offset<TEN::Save::Camera> camera) {
    fbb_.AddOffset(SaveGame::VT_CAMERA, camera);
  }
  void add_lara(flatbuffers::Offset<TEN::Save::Lara> lara) {
    fbb_.AddOffset(SaveGame::VT_LARA, lara);
  }
  void add_rooms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Room>>> rooms) {
    fbb_.AddOffset(SaveGame::VT_ROOMS, rooms);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items) {
    fbb_.AddOffset(SaveGame::VT_ITEMS, items);
  }
  void add_next_item_free(int32_t next_item_free) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_ITEM_FREE, next_item_free, 0);
  }
  void add_next_item_active(int32_t next_item_active) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_ITEM_ACTIVE, next_item_active, 0);
  }
  void add_room_items(flatbuffers::Offset<flatbuffers::Vector<int32_t>> room_items) {
    fbb_.AddOffset(SaveGame::VT_ROOM_ITEMS, room_items);
  }
  void add_fish_swarm(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FishData>>> fish_swarm) {
    fbb_.AddOffset(SaveGame::VT_FISH_SWARM, fish_swarm);
  }
  void add_firefly_swarm(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FireflyData>>> firefly_swarm) {
    fbb_.AddOffset(SaveGame::VT_FIREFLY_SWARM, firefly_swarm);
  }
  void add_fxinfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>>> fxinfos) {
    fbb_.AddOffset(SaveGame::VT_FXINFOS, fxinfos);
  }
  void add_next_fx_free(int32_t next_fx_free) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_FX_FREE, next_fx_free, 0);
  }
  void add_next_fx_active(int32_t next_fx_active) {
    fbb_.AddElement<int32_t>(SaveGame::VT_NEXT_FX_ACTIVE, next_fx_active, 0);
  }
  void add_fixed_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras) {
    fbb_.AddOffset(SaveGame::VT_FIXED_CAMERAS, fixed_cameras);
  }
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks) {
    fbb_.AddOffset(SaveGame::VT_SINKS, sinks);
  }
  void add_static_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes) {
    fbb_.AddOffset(SaveGame::VT_STATIC_MESHES, static_meshes);
  }
  void add_flyby_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras) {
    fbb_.AddOffset(SaveGame::VT_FLYBY_CAMERAS, flyby_cameras);
  }
  void add_particles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>>> particles) {
    fbb_.AddOffset(SaveGame::VT_PARTICLES, particles);
  }
  void add_rats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> rats) {
    fbb_.AddOffset(SaveGame::VT_RATS, rats);
  }
  void add_spiders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> spiders) {
    fbb_.AddOffset(SaveGame::VT_SPIDERS, spiders);
  }
  void add_scarabs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> scarabs) {
    fbb_.AddOffset(SaveGame::VT_SCARABS, scarabs);
  }
  void add_bats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> bats) {
    fbb_.AddOffset(SaveGame::VT_BATS, bats);
  }
  void add_flip_maps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps) {
    fbb_.AddOffset(SaveGame::VT_FLIP_MAPS, flip_maps);
  }
  void add_flip_stats(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats) {
    fbb_.AddOffset(SaveGame::VT_FLIP_STATS, flip_stats);
  }
  void add_flip_effect(int32_t flip_effect) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_EFFECT, flip_effect, 0);
  }
  void add_flip_timer(int32_t flip_timer) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_TIMER, flip_timer, 0);
  }
  void add_flip_status(int32_t flip_status) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_STATUS, flip_status, 0);
  }
  void add_current_fov(int16_t current_fov) {
    fbb_.AddElement<int16_t>(SaveGame::VT_CURRENT_FOV, current_fov, 0);
  }
  void add_last_inv_item(int32_t last_inv_item) {
    fbb_.AddElement<int32_t>(SaveGame::VT_LAST_INV_ITEM, last_inv_item, 0);
  }
  void add_action_queue(flatbuffers::Offset<flatbuffers::Vector<int32_t>> action_queue) {
    fbb_.AddOffset(SaveGame::VT_ACTION_QUEUE, action_queue);
  }
  void add_soundtracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Soundtrack>>> soundtracks) {
    fbb_.AddOffset(SaveGame::VT_SOUNDTRACKS, soundtracks);
  }
  void add_cd_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags) {
    fbb_.AddOffset(SaveGame::VT_CD_FLAGS, cd_flags);
  }
  void add_video(flatbuffers::Offset<TEN::Save::VideoInfo> video) {
    fbb_.AddOffset(SaveGame::VT_VIDEO, video);
  }
  void add_postprocess_mode(int32_t postprocess_mode) {
    fbb_.AddElement<int32_t>(SaveGame::VT_POSTPROCESS_MODE, postprocess_mode, 0);
  }
  void add_postprocess_strength(float postprocess_strength) {
    fbb_.AddElement<float>(SaveGame::VT_POSTPROCESS_STRENGTH, postprocess_strength, 0.0f);
  }
  void add_postprocess_tint(const TEN::Save::Vector3 *postprocess_tint) {
    fbb_.AddStruct(SaveGame::VT_POSTPROCESS_TINT, postprocess_tint);
  }
  void add_rope(flatbuffers::Offset<TEN::Save::Rope> rope) {
    fbb_.AddOffset(SaveGame::VT_ROPE, rope);
  }
  void add_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> pendulum) {
    fbb_.AddOffset(SaveGame::VT_PENDULUM, pendulum);
  }
  void add_alternate_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum) {
    fbb_.AddOffset(SaveGame::VT_ALTERNATE_PENDULUM, alternate_pendulum);
  }
  void add_volumes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Volume>>> volumes) {
    fbb_.AddOffset(SaveGame::VT_VOLUMES, volumes);
  }
  void add_global_event_sets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>>> global_event_sets) {
    fbb_.AddOffset(SaveGame::VT_GLOBAL_EVENT_SETS, global_event_sets);
  }
  void add_volume_event_sets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>>> volume_event_sets) {
    fbb_.AddOffset(SaveGame::VT_VOLUME_EVENT_SETS, volume_event_sets);
  }
  void add_script_vars(flatbuffers::Offset<TEN::Save::UnionVec> script_vars) {
    fbb_.AddOffset(SaveGame::VT_SCRIPT_VARS, script_vars);
  }
  void add_callbacks_pre_start(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_start) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_START, callbacks_pre_start);
  }
  void add_callbacks_post_start(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_start) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_START, callbacks_post_start);
  }
  void add_callbacks_pre_end(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_end) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_END, callbacks_pre_end);
  }
  void add_callbacks_post_end(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_end) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_END, callbacks_post_end);
  }
  void add_callbacks_pre_save(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_save) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_SAVE, callbacks_pre_save);
  }
  void add_callbacks_post_save(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_save) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_SAVE, callbacks_post_save);
  }
  void add_callbacks_pre_load(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_load) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_LOAD, callbacks_pre_load);
  }
  void add_callbacks_post_load(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_load) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_LOAD, callbacks_post_load);
  }
  void add_callbacks_pre_loop(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_loop) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_LOOP, callbacks_pre_loop);
  }
  void add_callbacks_post_loop(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_loop) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_LOOP, callbacks_post_loop);
  }
  void add_callbacks_pre_useitem(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_useitem) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_USEITEM, callbacks_pre_useitem);
  }
  void add_callbacks_post_useitem(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_useitem) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_USEITEM, callbacks_post_useitem);
  }
  void add_callbacks_pre_freeze(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_freeze) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_PRE_FREEZE, callbacks_pre_freeze);
  }
  void add_callbacks_post_freeze(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_freeze) {
    fbb_.AddOffset(SaveGame::VT_CALLBACKS_POST_FREEZE, callbacks_post_freeze);
  }
  explicit SaveGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGame> CreateSaveGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::LevelData> level_data = 0,
    int32_t secret_bits = 0,
    flatbuffers::Offset<TEN::Save::Camera> camera = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Room>>> rooms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items = 0,
    int32_t next_item_free = 0,
    int32_t next_item_active = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> room_items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FishData>>> fish_swarm = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FireflyData>>> firefly_swarm = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FXInfo>>> fxinfos = 0,
    int32_t next_fx_free = 0,
    int32_t next_fx_active = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ParticleInfo>>> particles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> rats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> spiders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> scarabs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>> bats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats = 0,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    int16_t current_fov = 0,
    int32_t last_inv_item = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> action_queue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Soundtrack>>> soundtracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags = 0,
    flatbuffers::Offset<TEN::Save::VideoInfo> video = 0,
    int32_t postprocess_mode = 0,
    float postprocess_strength = 0.0f,
    const TEN::Save::Vector3 *postprocess_tint = 0,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Volume>>> volumes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>>> global_event_sets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::EventSet>>> volume_event_sets = 0,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_start = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_start = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_end = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_end = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_save = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_save = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_load = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_load = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_loop = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_loop = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_useitem = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_useitem = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_pre_freeze = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> callbacks_post_freeze = 0) {
  SaveGameBuilder builder_(_fbb);
  builder_.add_callbacks_post_freeze(callbacks_post_freeze);
  builder_.add_callbacks_pre_freeze(callbacks_pre_freeze);
  builder_.add_callbacks_post_useitem(callbacks_post_useitem);
  builder_.add_callbacks_pre_useitem(callbacks_pre_useitem);
  builder_.add_callbacks_post_loop(callbacks_post_loop);
  builder_.add_callbacks_pre_loop(callbacks_pre_loop);
  builder_.add_callbacks_post_load(callbacks_post_load);
  builder_.add_callbacks_pre_load(callbacks_pre_load);
  builder_.add_callbacks_post_save(callbacks_post_save);
  builder_.add_callbacks_pre_save(callbacks_pre_save);
  builder_.add_callbacks_post_end(callbacks_post_end);
  builder_.add_callbacks_pre_end(callbacks_pre_end);
  builder_.add_callbacks_post_start(callbacks_post_start);
  builder_.add_callbacks_pre_start(callbacks_pre_start);
  builder_.add_script_vars(script_vars);
  builder_.add_volume_event_sets(volume_event_sets);
  builder_.add_global_event_sets(global_event_sets);
  builder_.add_volumes(volumes);
  builder_.add_alternate_pendulum(alternate_pendulum);
  builder_.add_pendulum(pendulum);
  builder_.add_rope(rope);
  builder_.add_postprocess_tint(postprocess_tint);
  builder_.add_postprocess_strength(postprocess_strength);
  builder_.add_postprocess_mode(postprocess_mode);
  builder_.add_video(video);
  builder_.add_cd_flags(cd_flags);
  builder_.add_soundtracks(soundtracks);
  builder_.add_action_queue(action_queue);
  builder_.add_last_inv_item(last_inv_item);
  builder_.add_flip_status(flip_status);
  builder_.add_flip_timer(flip_timer);
  builder_.add_flip_effect(flip_effect);
  builder_.add_flip_stats(flip_stats);
  builder_.add_flip_maps(flip_maps);
  builder_.add_bats(bats);
  builder_.add_scarabs(scarabs);
  builder_.add_spiders(spiders);
  builder_.add_rats(rats);
  builder_.add_particles(particles);
  builder_.add_flyby_cameras(flyby_cameras);
  builder_.add_static_meshes(static_meshes);
  builder_.add_sinks(sinks);
  builder_.add_fixed_cameras(fixed_cameras);
  builder_.add_next_fx_active(next_fx_active);
  builder_.add_next_fx_free(next_fx_free);
  builder_.add_fxinfos(fxinfos);
  builder_.add_firefly_swarm(firefly_swarm);
  builder_.add_fish_swarm(fish_swarm);
  builder_.add_room_items(room_items);
  builder_.add_next_item_active(next_item_active);
  builder_.add_next_item_free(next_item_free);
  builder_.add_items(items);
  builder_.add_rooms(rooms);
  builder_.add_lara(lara);
  builder_.add_camera(camera);
  builder_.add_secret_bits(secret_bits);
  builder_.add_level_data(level_data);
  builder_.add_level(level);
  builder_.add_game(game);
  builder_.add_header(header);
  builder_.add_current_fov(current_fov);
  return builder_.Finish();
}

struct SaveGame::Traits {
  using type = SaveGame;
  static auto constexpr Create = CreateSaveGame;
};

inline flatbuffers::Offset<SaveGame> CreateSaveGameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::LevelData> level_data = 0,
    int32_t secret_bits = 0,
    flatbuffers::Offset<TEN::Save::Camera> camera = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::Room>> *rooms = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::Item>> *items = nullptr,
    int32_t next_item_free = 0,
    int32_t next_item_active = 0,
    const std::vector<int32_t> *room_items = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FishData>> *fish_swarm = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FireflyData>> *firefly_swarm = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FXInfo>> *fxinfos = nullptr,
    int32_t next_fx_free = 0,
    int32_t next_fx_active = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::ParticleInfo>> *particles = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *rats = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *spiders = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *scarabs = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> *bats = nullptr,
    const std::vector<int32_t> *flip_maps = nullptr,
    const std::vector<int32_t> *flip_stats = nullptr,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    int16_t current_fov = 0,
    int32_t last_inv_item = 0,
    const std::vector<int32_t> *action_queue = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::Soundtrack>> *soundtracks = nullptr,
    const std::vector<int32_t> *cd_flags = nullptr,
    flatbuffers::Offset<TEN::Save::VideoInfo> video = 0,
    int32_t postprocess_mode = 0,
    float postprocess_strength = 0.0f,
    const TEN::Save::Vector3 *postprocess_tint = 0,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::Volume>> *volumes = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::EventSet>> *global_event_sets = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::EventSet>> *volume_event_sets = nullptr,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_start = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_start = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_end = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_end = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_save = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_save = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_load = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_load = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_loop = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_loop = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_useitem = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_useitem = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_pre_freeze = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *callbacks_post_freeze = nullptr) {
  auto rooms__ = rooms ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Room>>(*rooms) : 0;
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>>(*items) : 0;
  auto room_items__ = room_items ? _fbb.CreateVector<int32_t>(*room_items) : 0;
  auto fish_swarm__ = fish_swarm ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FishData>>(*fish_swarm) : 0;
  auto firefly_swarm__ = firefly_swarm ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FireflyData>>(*firefly_swarm) : 0;
  auto fxinfos__ = fxinfos ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FXInfo>>(*fxinfos) : 0;
  auto fixed_cameras__ = fixed_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>>(*fixed_cameras) : 0;
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>>(*sinks) : 0;
  auto static_meshes__ = static_meshes ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>(*static_meshes) : 0;
  auto flyby_cameras__ = flyby_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>>(*flyby_cameras) : 0;
  auto particles__ = particles ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ParticleInfo>>(*particles) : 0;
  auto rats__ = rats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>(*rats) : 0;
  auto spiders__ = spiders ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>(*spiders) : 0;
  auto scarabs__ = scarabs ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>(*scarabs) : 0;
  auto bats__ = bats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>>(*bats) : 0;
  auto flip_maps__ = flip_maps ? _fbb.CreateVector<int32_t>(*flip_maps) : 0;
  auto flip_stats__ = flip_stats ? _fbb.CreateVector<int32_t>(*flip_stats) : 0;
  auto action_queue__ = action_queue ? _fbb.CreateVector<int32_t>(*action_queue) : 0;
  auto soundtracks__ = soundtracks ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Soundtrack>>(*soundtracks) : 0;
  auto cd_flags__ = cd_flags ? _fbb.CreateVector<int32_t>(*cd_flags) : 0;
  auto volumes__ = volumes ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Volume>>(*volumes) : 0;
  auto global_event_sets__ = global_event_sets ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSet>>(*global_event_sets) : 0;
  auto volume_event_sets__ = volume_event_sets ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSet>>(*volume_event_sets) : 0;
  auto callbacks_pre_start__ = callbacks_pre_start ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_start) : 0;
  auto callbacks_post_start__ = callbacks_post_start ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_start) : 0;
  auto callbacks_pre_end__ = callbacks_pre_end ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_end) : 0;
  auto callbacks_post_end__ = callbacks_post_end ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_end) : 0;
  auto callbacks_pre_save__ = callbacks_pre_save ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_save) : 0;
  auto callbacks_post_save__ = callbacks_post_save ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_save) : 0;
  auto callbacks_pre_load__ = callbacks_pre_load ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_load) : 0;
  auto callbacks_post_load__ = callbacks_post_load ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_load) : 0;
  auto callbacks_pre_loop__ = callbacks_pre_loop ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_loop) : 0;
  auto callbacks_post_loop__ = callbacks_post_loop ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_loop) : 0;
  auto callbacks_pre_useitem__ = callbacks_pre_useitem ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_useitem) : 0;
  auto callbacks_post_useitem__ = callbacks_post_useitem ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_useitem) : 0;
  auto callbacks_pre_freeze__ = callbacks_pre_freeze ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_pre_freeze) : 0;
  auto callbacks_post_freeze__ = callbacks_post_freeze ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*callbacks_post_freeze) : 0;
  return TEN::Save::CreateSaveGame(
      _fbb,
      header,
      game,
      level,
      level_data,
      secret_bits,
      camera,
      lara,
      rooms__,
      items__,
      next_item_free,
      next_item_active,
      room_items__,
      fish_swarm__,
      firefly_swarm__,
      fxinfos__,
      next_fx_free,
      next_fx_active,
      fixed_cameras__,
      sinks__,
      static_meshes__,
      flyby_cameras__,
      particles__,
      rats__,
      spiders__,
      scarabs__,
      bats__,
      flip_maps__,
      flip_stats__,
      flip_effect,
      flip_timer,
      flip_status,
      current_fov,
      last_inv_item,
      action_queue__,
      soundtracks__,
      cd_flags__,
      video,
      postprocess_mode,
      postprocess_strength,
      postprocess_tint,
      rope,
      pendulum,
      alternate_pendulum,
      volumes__,
      global_event_sets__,
      volume_event_sets__,
      script_vars,
      callbacks_pre_start__,
      callbacks_post_start__,
      callbacks_pre_end__,
      callbacks_post_end__,
      callbacks_pre_save__,
      callbacks_post_save__,
      callbacks_pre_load__,
      callbacks_post_load__,
      callbacks_pre_loop__,
      callbacks_post_loop__,
      callbacks_pre_useitem__,
      callbacks_post_useitem__,
      callbacks_pre_freeze__,
      callbacks_post_freeze__);
}

flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline LevelDataT *LevelData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LevelDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LevelData::UnPackTo(LevelDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level_far_view(); _o->level_far_view = _e; }
  { auto _e = storm_enabled(); _o->storm_enabled = _e; }
  { auto _e = rumble_enabled(); _o->rumble_enabled = _e; }
  { auto _e = weather_type(); _o->weather_type = _e; }
  { auto _e = weather_strength(); _o->weather_strength = _e; }
  { auto _e = fog_color(); _o->fog_color = _e; }
  { auto _e = fog_min_distance(); _o->fog_min_distance = _e; }
  { auto _e = fog_max_distance(); _o->fog_max_distance = _e; }
  { auto _e = sky_layer_1_enabled(); _o->sky_layer_1_enabled = _e; }
  { auto _e = sky_layer_1_color(); _o->sky_layer_1_color = _e; }
  { auto _e = sky_layer_1_speed(); _o->sky_layer_1_speed = _e; }
  { auto _e = sky_layer_2_enabled(); _o->sky_layer_2_enabled = _e; }
  { auto _e = sky_layer_2_color(); _o->sky_layer_2_color = _e; }
  { auto _e = sky_layer_2_speed(); _o->sky_layer_2_speed = _e; }
  { auto _e = horizon1_enabled(); _o->horizon1_enabled = _e; }
  { auto _e = horizon1_object_id(); _o->horizon1_object_id = _e; }
  { auto _e = horizon1_position(); if (_e) _o->horizon1_position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = horizon1_orientation(); if (_e) _o->horizon1_orientation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = horizon1_transparency(); _o->horizon1_transparency = _e; }
  { auto _e = horizon2_enabled(); _o->horizon2_enabled = _e; }
  { auto _e = horizon2_object_id(); _o->horizon2_object_id = _e; }
  { auto _e = horizon2_position(); if (_e) _o->horizon2_position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = horizon2_orientation(); if (_e) _o->horizon2_orientation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = horizon2_transparency(); _o->horizon2_transparency = _e; }
  { auto _e = lensflare_sprite_id(); _o->lensflare_sprite_id = _e; }
  { auto _e = lensflare_pitch(); _o->lensflare_pitch = _e; }
  { auto _e = lensflare_yaw(); _o->lensflare_yaw = _e; }
  { auto _e = lensflare_color(); _o->lensflare_color = _e; }
  { auto _e = starfield_star_count(); _o->starfield_star_count = _e; }
  { auto _e = starfield_meteor_count(); _o->starfield_meteor_count = _e; }
  { auto _e = starfield_meteor_spawn_density(); _o->starfield_meteor_spawn_density = _e; }
  { auto _e = starfield_meteor_velocity(); _o->starfield_meteor_velocity = _e; }
}

inline flatbuffers::Offset<LevelData> LevelData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LevelDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLevelData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LevelData> CreateLevelData(flatbuffers::FlatBufferBuilder &_fbb, const LevelDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LevelDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level_far_view = _o->level_far_view;
  auto _storm_enabled = _o->storm_enabled;
  auto _rumble_enabled = _o->rumble_enabled;
  auto _weather_type = _o->weather_type;
  auto _weather_strength = _o->weather_strength;
  auto _fog_color = _o->fog_color;
  auto _fog_min_distance = _o->fog_min_distance;
  auto _fog_max_distance = _o->fog_max_distance;
  auto _sky_layer_1_enabled = _o->sky_layer_1_enabled;
  auto _sky_layer_1_color = _o->sky_layer_1_color;
  auto _sky_layer_1_speed = _o->sky_layer_1_speed;
  auto _sky_layer_2_enabled = _o->sky_layer_2_enabled;
  auto _sky_layer_2_color = _o->sky_layer_2_color;
  auto _sky_layer_2_speed = _o->sky_layer_2_speed;
  auto _horizon1_enabled = _o->horizon1_enabled;
  auto _horizon1_object_id = _o->horizon1_object_id;
  auto _horizon1_position = _o->horizon1_position ? _o->horizon1_position.get() : 0;
  auto _horizon1_orientation = _o->horizon1_orientation ? _o->horizon1_orientation.get() : 0;
  auto _horizon1_transparency = _o->horizon1_transparency;
  auto _horizon2_enabled = _o->horizon2_enabled;
  auto _horizon2_object_id = _o->horizon2_object_id;
  auto _horizon2_position = _o->horizon2_position ? _o->horizon2_position.get() : 0;
  auto _horizon2_orientation = _o->horizon2_orientation ? _o->horizon2_orientation.get() : 0;
  auto _horizon2_transparency = _o->horizon2_transparency;
  auto _lensflare_sprite_id = _o->lensflare_sprite_id;
  auto _lensflare_pitch = _o->lensflare_pitch;
  auto _lensflare_yaw = _o->lensflare_yaw;
  auto _lensflare_color = _o->lensflare_color;
  auto _starfield_star_count = _o->starfield_star_count;
  auto _starfield_meteor_count = _o->starfield_meteor_count;
  auto _starfield_meteor_spawn_density = _o->starfield_meteor_spawn_density;
  auto _starfield_meteor_velocity = _o->starfield_meteor_velocity;
  return TEN::Save::CreateLevelData(
      _fbb,
      _level_far_view,
      _storm_enabled,
      _rumble_enabled,
      _weather_type,
      _weather_strength,
      _fog_color,
      _fog_min_distance,
      _fog_max_distance,
      _sky_layer_1_enabled,
      _sky_layer_1_color,
      _sky_layer_1_speed,
      _sky_layer_2_enabled,
      _sky_layer_2_color,
      _sky_layer_2_speed,
      _horizon1_enabled,
      _horizon1_object_id,
      _horizon1_position,
      _horizon1_orientation,
      _horizon1_transparency,
      _horizon2_enabled,
      _horizon2_object_id,
      _horizon2_position,
      _horizon2_orientation,
      _horizon2_transparency,
      _lensflare_sprite_id,
      _lensflare_pitch,
      _lensflare_yaw,
      _lensflare_color,
      _starfield_star_count,
      _starfield_meteor_count,
      _starfield_meteor_spawn_density,
      _starfield_meteor_velocity);
}

inline RoomT *Room::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RoomT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Room::UnPackTo(RoomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = reverb_type(); _o->reverb_type = _e; }
}

inline flatbuffers::Offset<Room> Room::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Room> CreateRoom(flatbuffers::FlatBufferBuilder &_fbb, const RoomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _flags = _o->flags;
  auto _reverb_type = _o->reverb_type;
  return TEN::Save::CreateRoom(
      _fbb,
      _index,
      _name,
      _flags,
      _reverb_type);
}

inline ItemT *Item::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ItemT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = anim_object_id(); _o->anim_object_id = _e; }
  { auto _e = active_state(); _o->active_state = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = is_airborne(); _o->is_airborne = _e; }
  { auto _e = required_state(); _o->required_state = _e; }
  { auto _e = target_state(); _o->target_state = _e; }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = floor(); _o->floor = _e; }
  { auto _e = touch_bits(); _o->touch_bits = _e; }
  { auto _e = mesh_bits(); _o->mesh_bits = _e; }
  { auto _e = object_id(); _o->object_id = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = box_number(); _o->box_number = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = trigger_flags(); _o->trigger_flags = _e; }
  { auto _e = carried_item(); _o->carried_item = _e; }
  { auto _e = after_death(); _o->after_death = _e; }
  { auto _e = item_flags(); if (_e) { _o->item_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->item_flags[_i] = _e->Get(_i); } } }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
  { auto _e = next_item(); _o->next_item = _e; }
  { auto _e = next_item_active(); _o->next_item_active = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = status(); _o->status = _e; }
  { auto _e = hit_stauts(); _o->hit_stauts = _e; }
  { auto _e = collidable(); _o->collidable = _e; }
  { auto _e = looked_at(); _o->looked_at = _e; }
  { auto _e = ai_bits(); _o->ai_bits = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = TEN::Save::ItemDataUnion::UnPack(_e, data_type(), _resolver); }
  { auto _e = base_mesh(); _o->base_mesh = _e; }
  { auto _e = mesh_pointers(); if (_e) { _o->mesh_pointers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mesh_pointers[_i] = _e->Get(_i); } } }
  { auto _e = effect_type(); _o->effect_type = _e; }
  { auto _e = effect_light_colour(); if (_e) _o->effect_light_colour = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = effect_primary_colour(); if (_e) _o->effect_primary_colour = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = effect_secondary_colour(); if (_e) _o->effect_secondary_colour = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = effect_count(); _o->effect_count = _e; }
  { auto _e = lua_name(); if (_e) _o->lua_name = _e->str(); }
  { auto _e = lua_on_killed_name(); if (_e) _o->lua_on_killed_name = _e->str(); }
  { auto _e = lua_on_hit_name(); if (_e) _o->lua_on_hit_name = _e->str(); }
  { auto _e = lua_on_collided_with_object_name(); if (_e) _o->lua_on_collided_with_object_name = _e->str(); }
  { auto _e = lua_on_collided_with_room_name(); if (_e) _o->lua_on_collided_with_room_name = _e->str(); }
}

inline flatbuffers::Offset<Item> Item::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _anim_object_id = _o->anim_object_id;
  auto _active_state = _o->active_state;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _is_airborne = _o->is_airborne;
  auto _required_state = _o->required_state;
  auto _target_state = _o->target_state;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  auto _floor = _o->floor;
  auto _touch_bits = _o->touch_bits;
  auto _mesh_bits = _o->mesh_bits;
  auto _object_id = _o->object_id;
  auto _room_number = _o->room_number;
  auto _hit_points = _o->hit_points;
  auto _box_number = _o->box_number;
  auto _timer = _o->timer;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _flags = _o->flags;
  auto _trigger_flags = _o->trigger_flags;
  auto _carried_item = _o->carried_item;
  auto _after_death = _o->after_death;
  auto _item_flags = _fbb.CreateVector(_o->item_flags);
  auto _pose = _o->pose ? _o->pose.get() : 0;
  auto _next_item = _o->next_item;
  auto _next_item_active = _o->next_item_active;
  auto _active = _o->active;
  auto _status = _o->status;
  auto _hit_stauts = _o->hit_stauts;
  auto _collidable = _o->collidable;
  auto _looked_at = _o->looked_at;
  auto _ai_bits = _o->ai_bits;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  auto _base_mesh = _o->base_mesh;
  auto _mesh_pointers = _fbb.CreateVector(_o->mesh_pointers);
  auto _effect_type = _o->effect_type;
  auto _effect_light_colour = _o->effect_light_colour ? _o->effect_light_colour.get() : 0;
  auto _effect_primary_colour = _o->effect_primary_colour ? _o->effect_primary_colour.get() : 0;
  auto _effect_secondary_colour = _o->effect_secondary_colour ? _o->effect_secondary_colour.get() : 0;
  auto _effect_count = _o->effect_count;
  auto _lua_name = _o->lua_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_name);
  auto _lua_on_killed_name = _o->lua_on_killed_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_killed_name);
  auto _lua_on_hit_name = _o->lua_on_hit_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_hit_name);
  auto _lua_on_collided_with_object_name = _o->lua_on_collided_with_object_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_collided_with_object_name);
  auto _lua_on_collided_with_room_name = _o->lua_on_collided_with_room_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lua_on_collided_with_room_name);
  return TEN::Save::CreateItem(
      _fbb,
      _anim_object_id,
      _active_state,
      _anim_number,
      _frame_number,
      _is_airborne,
      _required_state,
      _target_state,
      _velocity,
      _floor,
      _touch_bits,
      _mesh_bits,
      _object_id,
      _room_number,
      _hit_points,
      _box_number,
      _timer,
      _color,
      _flags,
      _trigger_flags,
      _carried_item,
      _after_death,
      _item_flags,
      _pose,
      _next_item,
      _next_item_active,
      _active,
      _status,
      _hit_stauts,
      _collidable,
      _looked_at,
      _ai_bits,
      _data_type,
      _data,
      _base_mesh,
      _mesh_pointers,
      _effect_type,
      _effect_light_colour,
      _effect_primary_colour,
      _effect_secondary_colour,
      _effect_count,
      _lua_name,
      _lua_on_killed_name,
      _lua_on_hit_name,
      _lua_on_collided_with_object_name,
      _lua_on_collided_with_room_name);
}

inline FXInfoT *FXInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FXInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FXInfo::UnPackTo(FXInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = next_fx(); _o->next_fx = _e; }
  { auto _e = next_active(); _o->next_active = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = fall_speed(); _o->fall_speed = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = counter(); _o->counter = _e; }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = flag1(); _o->flag1 = _e; }
  { auto _e = flag2(); _o->flag2 = _e; }
}

inline flatbuffers::Offset<FXInfo> FXInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFXInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FXInfo> CreateFXInfo(flatbuffers::FlatBufferBuilder &_fbb, const FXInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FXInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pose = _o->pose ? _o->pose.get() : 0;
  auto _room_number = _o->room_number;
  auto _object_number = _o->object_number;
  auto _next_fx = _o->next_fx;
  auto _next_active = _o->next_active;
  auto _speed = _o->speed;
  auto _fall_speed = _o->fall_speed;
  auto _frame_number = _o->frame_number;
  auto _counter = _o->counter;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _flag1 = _o->flag1;
  auto _flag2 = _o->flag2;
  return TEN::Save::CreateFXInfo(
      _fbb,
      _pose,
      _room_number,
      _object_number,
      _next_fx,
      _next_active,
      _speed,
      _fall_speed,
      _frame_number,
      _counter,
      _color,
      _flag1,
      _flag2);
}

inline AmmoInfoT *AmmoInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AmmoInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AmmoInfo::UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; }
  { auto _e = is_infinite(); _o->is_infinite = _e; }
}

inline flatbuffers::Offset<AmmoInfo> AmmoInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAmmoInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AmmoInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _is_infinite = _o->is_infinite;
  return TEN::Save::CreateAmmoInfo(
      _fbb,
      _count,
      _is_infinite);
}

inline HolsterInfoT *HolsterInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<HolsterInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HolsterInfo::UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = left_holster(); _o->left_holster = _e; }
  { auto _e = right_holster(); _o->right_holster = _e; }
  { auto _e = back_holster(); _o->back_holster = _e; }
}

inline flatbuffers::Offset<HolsterInfo> HolsterInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHolsterInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HolsterInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _left_holster = _o->left_holster;
  auto _right_holster = _o->right_holster;
  auto _back_holster = _o->back_holster;
  return TEN::Save::CreateHolsterInfo(
      _fbb,
      _left_holster,
      _right_holster,
      _back_holster);
}

inline CarriedWeaponInfoT *CarriedWeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CarriedWeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CarriedWeaponInfo::UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = present(); _o->present = _e; }
  { auto _e = has_lasersight(); _o->has_lasersight = _e; }
  { auto _e = has_silencer(); _o->has_silencer = _e; }
  { auto _e = ammo(); if (_e) { _o->ammo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ammo[_i] = std::unique_ptr<TEN::Save::AmmoInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = selected_ammo(); _o->selected_ammo = _e; }
  { auto _e = weapon_mode(); _o->weapon_mode = _e; }
}

inline flatbuffers::Offset<CarriedWeaponInfo> CarriedWeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCarriedWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CarriedWeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _present = _o->present;
  auto _has_lasersight = _o->has_lasersight;
  auto _has_silencer = _o->has_silencer;
  auto _ammo = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>> (_o->ammo.size(), [](size_t i, _VectorArgs *__va) { return CreateAmmoInfo(*__va->__fbb, __va->__o->ammo[i].get(), __va->__rehasher); }, &_va );
  auto _selected_ammo = _o->selected_ammo;
  auto _weapon_mode = _o->weapon_mode;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      _present,
      _has_lasersight,
      _has_silencer,
      _ammo,
      _selected_ammo,
      _weapon_mode);
}

inline WeaponInfoT *WeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponInfo::UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = active_state(); _o->active_state = _e; }
  { auto _e = target_state(); _o->target_state = _e; }
}

inline flatbuffers::Offset<WeaponInfo> WeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_number = _o->object_number;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _active_state = _o->active_state;
  auto _target_state = _o->target_state;
  return TEN::Save::CreateWeaponInfo(
      _fbb,
      _object_number,
      _anim_number,
      _frame_number,
      _active_state,
      _target_state);
}

inline ArmInfoT *ArmInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ArmInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArmInfo::UnPackTo(ArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = frame_base(); _o->frame_base = _e; }
  { auto _e = locked(); _o->locked = _e; }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = gun_flash(); _o->gun_flash = _e; }
  { auto _e = gun_smoke(); _o->gun_smoke = _e; }
}

inline flatbuffers::Offset<ArmInfo> ArmInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArmInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArmInfo> CreateArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const ArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArmInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _frame_base = _o->frame_base;
  auto _locked = _o->locked;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _gun_flash = _o->gun_flash;
  auto _gun_smoke = _o->gun_smoke;
  return TEN::Save::CreateArmInfo(
      _fbb,
      _anim_number,
      _frame_number,
      _frame_base,
      _locked,
      _rotation,
      _gun_flash,
      _gun_smoke);
}

inline FlareDataT *FlareData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FlareDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlareData::UnPackTo(FlareDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = life(); _o->life = _e; }
  { auto _e = frame(); _o->frame = _e; }
  { auto _e = control_left(); _o->control_left = _e; }
}

inline flatbuffers::Offset<FlareData> FlareData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlareData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlareData> CreateFlareData(flatbuffers::FlatBufferBuilder &_fbb, const FlareDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlareDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _life = _o->life;
  auto _frame = _o->frame;
  auto _control_left = _o->control_left;
  return TEN::Save::CreateFlareData(
      _fbb,
      _life,
      _frame,
      _control_left);
}

inline TorchDataT *TorchData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TorchDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TorchData::UnPackTo(TorchDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
  { auto _e = is_lit(); _o->is_lit = _e; }
}

inline flatbuffers::Offset<TorchData> TorchData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTorchData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TorchData> CreateTorchData(flatbuffers::FlatBufferBuilder &_fbb, const TorchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TorchDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  auto _is_lit = _o->is_lit;
  return TEN::Save::CreateTorchData(
      _fbb,
      _state,
      _is_lit);
}

inline LaraInventoryDataT *LaraInventoryData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraInventoryDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraInventoryData::UnPackTo(LaraInventoryDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_busy(); _o->is_busy = _e; }
  { auto _e = old_busy(); _o->old_busy = _e; }
  { auto _e = beetle_life(); _o->beetle_life = _e; }
  { auto _e = beetle_components(); _o->beetle_components = _e; }
  { auto _e = small_waterskin(); _o->small_waterskin = _e; }
  { auto _e = big_waterskin(); _o->big_waterskin = _e; }
  { auto _e = has_binoculars(); _o->has_binoculars = _e; }
  { auto _e = has_compass(); _o->has_compass = _e; }
  { auto _e = has_stopwatch(); _o->has_stopwatch = _e; }
  { auto _e = has_diary(); _o->has_diary = _e; }
  { auto _e = has_load(); _o->has_load = _e; }
  { auto _e = has_save(); _o->has_save = _e; }
  { auto _e = has_crowbar(); _o->has_crowbar = _e; }
  { auto _e = has_torch(); _o->has_torch = _e; }
  { auto _e = has_lasersight(); _o->has_lasersight = _e; }
  { auto _e = has_silencer(); _o->has_silencer = _e; }
  { auto _e = total_small_medipacks(); _o->total_small_medipacks = _e; }
  { auto _e = total_large_medipacks(); _o->total_large_medipacks = _e; }
  { auto _e = total_flares(); _o->total_flares = _e; }
  { auto _e = total_secrets(); _o->total_secrets = _e; }
  { auto _e = puzzles(); if (_e) { _o->puzzles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles[_i] = _e->Get(_i); } } }
  { auto _e = keys(); if (_e) { _o->keys.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys[_i] = _e->Get(_i); } } }
  { auto _e = pickups(); if (_e) { _o->pickups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups[_i] = _e->Get(_i); } } }
  { auto _e = examines(); if (_e) { _o->examines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines[_i] = _e->Get(_i); } } }
  { auto _e = puzzles_combo(); if (_e) { _o->puzzles_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles_combo[_i] = _e->Get(_i); } } }
  { auto _e = keys_combo(); if (_e) { _o->keys_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_combo[_i] = _e->Get(_i); } } }
  { auto _e = pickups_combo(); if (_e) { _o->pickups_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups_combo[_i] = _e->Get(_i); } } }
  { auto _e = examines_combo(); if (_e) { _o->examines_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines_combo[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LaraInventoryData> LaraInventoryData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraInventoryData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraInventoryData> CreateLaraInventoryData(flatbuffers::FlatBufferBuilder &_fbb, const LaraInventoryDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraInventoryDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_busy = _o->is_busy;
  auto _old_busy = _o->old_busy;
  auto _beetle_life = _o->beetle_life;
  auto _beetle_components = _o->beetle_components;
  auto _small_waterskin = _o->small_waterskin;
  auto _big_waterskin = _o->big_waterskin;
  auto _has_binoculars = _o->has_binoculars;
  auto _has_compass = _o->has_compass;
  auto _has_stopwatch = _o->has_stopwatch;
  auto _has_diary = _o->has_diary;
  auto _has_load = _o->has_load;
  auto _has_save = _o->has_save;
  auto _has_crowbar = _o->has_crowbar;
  auto _has_torch = _o->has_torch;
  auto _has_lasersight = _o->has_lasersight;
  auto _has_silencer = _o->has_silencer;
  auto _total_small_medipacks = _o->total_small_medipacks;
  auto _total_large_medipacks = _o->total_large_medipacks;
  auto _total_flares = _o->total_flares;
  auto _total_secrets = _o->total_secrets;
  auto _puzzles = _fbb.CreateVector(_o->puzzles);
  auto _keys = _fbb.CreateVector(_o->keys);
  auto _pickups = _fbb.CreateVector(_o->pickups);
  auto _examines = _fbb.CreateVector(_o->examines);
  auto _puzzles_combo = _fbb.CreateVector(_o->puzzles_combo);
  auto _keys_combo = _fbb.CreateVector(_o->keys_combo);
  auto _pickups_combo = _fbb.CreateVector(_o->pickups_combo);
  auto _examines_combo = _fbb.CreateVector(_o->examines_combo);
  return TEN::Save::CreateLaraInventoryData(
      _fbb,
      _is_busy,
      _old_busy,
      _beetle_life,
      _beetle_components,
      _small_waterskin,
      _big_waterskin,
      _has_binoculars,
      _has_compass,
      _has_stopwatch,
      _has_diary,
      _has_load,
      _has_save,
      _has_crowbar,
      _has_torch,
      _has_lasersight,
      _has_silencer,
      _total_small_medipacks,
      _total_large_medipacks,
      _total_flares,
      _total_secrets,
      _puzzles,
      _keys,
      _pickups,
      _examines,
      _puzzles_combo,
      _keys_combo,
      _pickups_combo,
      _examines_combo);
}

inline LaraCountDataT *LaraCountData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraCountDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraCountData::UnPackTo(LaraCountDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = run_jump(); _o->run_jump = _e; }
  { auto _e = position_adjust(); _o->position_adjust = _e; }
  { auto _e = pose(); _o->pose = _e; }
  { auto _e = death(); _o->death = _e; }
  { auto _e = no_cheat(); _o->no_cheat = _e; }
}

inline flatbuffers::Offset<LaraCountData> LaraCountData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraCountData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraCountData> CreateLaraCountData(flatbuffers::FlatBufferBuilder &_fbb, const LaraCountDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraCountDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _run_jump = _o->run_jump;
  auto _position_adjust = _o->position_adjust;
  auto _pose = _o->pose;
  auto _death = _o->death;
  auto _no_cheat = _o->no_cheat;
  return TEN::Save::CreateLaraCountData(
      _fbb,
      _run_jump,
      _position_adjust,
      _pose,
      _death,
      _no_cheat);
}

inline LookControlDataT *LookControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LookControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookControlData::UnPackTo(LookControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_using_binoculars(); _o->is_using_binoculars = _e; }
  { auto _e = is_using_lasersight(); _o->is_using_lasersight = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = optic_range(); _o->optic_range = _e; }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = turn_rate(); if (_e) _o->turn_rate = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
}

inline flatbuffers::Offset<LookControlData> LookControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LookControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LookControlData> CreateLookControlData(flatbuffers::FlatBufferBuilder &_fbb, const LookControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LookControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_using_binoculars = _o->is_using_binoculars;
  auto _is_using_lasersight = _o->is_using_lasersight;
  auto _mode = _o->mode;
  auto _optic_range = _o->optic_range;
  auto _orientation = _o->orientation ? _o->orientation.get() : 0;
  auto _turn_rate = _o->turn_rate ? _o->turn_rate.get() : 0;
  return TEN::Save::CreateLookControlData(
      _fbb,
      _is_using_binoculars,
      _is_using_lasersight,
      _mode,
      _optic_range,
      _orientation,
      _turn_rate);
}

inline RopeControlDataT *RopeControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RopeControlData::UnPackTo(RopeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segment(); _o->segment = _e; }
  { auto _e = direction(); _o->direction = _e; }
  { auto _e = arc_front(); _o->arc_front = _e; }
  { auto _e = arc_back(); _o->arc_back = _e; }
  { auto _e = last_x(); _o->last_x = _e; }
  { auto _e = max_x_forward(); _o->max_x_forward = _e; }
  { auto _e = max_x_backward(); _o->max_x_backward = _e; }
  { auto _e = dframe(); _o->dframe = _e; }
  { auto _e = frame(); _o->frame = _e; }
  { auto _e = frame_rate(); _o->frame_rate = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = ptr(); _o->ptr = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = down_vel(); _o->down_vel = _e; }
  { auto _e = flag(); _o->flag = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<RopeControlData> RopeControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRopeControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RopeControlData> CreateRopeControlData(flatbuffers::FlatBufferBuilder &_fbb, const RopeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segment = _o->segment;
  auto _direction = _o->direction;
  auto _arc_front = _o->arc_front;
  auto _arc_back = _o->arc_back;
  auto _last_x = _o->last_x;
  auto _max_x_forward = _o->max_x_forward;
  auto _max_x_backward = _o->max_x_backward;
  auto _dframe = _o->dframe;
  auto _frame = _o->frame;
  auto _frame_rate = _o->frame_rate;
  auto _y = _o->y;
  auto _ptr = _o->ptr;
  auto _offset = _o->offset;
  auto _down_vel = _o->down_vel;
  auto _flag = _o->flag;
  auto _count = _o->count;
  return TEN::Save::CreateRopeControlData(
      _fbb,
      _segment,
      _direction,
      _arc_front,
      _arc_back,
      _last_x,
      _max_x_forward,
      _max_x_backward,
      _dframe,
      _frame,
      _frame_rate,
      _y,
      _ptr,
      _offset,
      _down_vel,
      _flag,
      _count);
}

inline SubsuitControlDataT *SubsuitControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SubsuitControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubsuitControlData::UnPackTo(SubsuitControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = d_x_rot(); _o->d_x_rot = _e; }
  { auto _e = velocity(); if (_e) { _o->velocity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->velocity[_i] = _e->Get(_i); } } }
  { auto _e = vertical_velocity(); _o->vertical_velocity = _e; }
  { auto _e = x_rot_vel(); _o->x_rot_vel = _e; }
  { auto _e = hit_count(); _o->hit_count = _e; }
}

inline flatbuffers::Offset<SubsuitControlData> SubsuitControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubsuitControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubsuitControlData> CreateSubsuitControlData(flatbuffers::FlatBufferBuilder &_fbb, const SubsuitControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubsuitControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x_rot = _o->x_rot;
  auto _d_x_rot = _o->d_x_rot;
  auto _velocity = _fbb.CreateVector(_o->velocity);
  auto _vertical_velocity = _o->vertical_velocity;
  auto _x_rot_vel = _o->x_rot_vel;
  auto _hit_count = _o->hit_count;
  return TEN::Save::CreateSubsuitControlData(
      _fbb,
      _x_rot,
      _d_x_rot,
      _velocity,
      _vertical_velocity,
      _x_rot_vel,
      _hit_count);
}

inline TightropeControlDataT *TightropeControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TightropeControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TightropeControlData::UnPackTo(TightropeControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = balance(); _o->balance = _e; }
  { auto _e = time_on_tightrope(); _o->time_on_tightrope = _e; }
  { auto _e = can_dismount(); _o->can_dismount = _e; }
  { auto _e = tightrope_item(); _o->tightrope_item = _e; }
}

inline flatbuffers::Offset<TightropeControlData> TightropeControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTightropeControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TightropeControlData> CreateTightropeControlData(flatbuffers::FlatBufferBuilder &_fbb, const TightropeControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TightropeControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _balance = _o->balance;
  auto _time_on_tightrope = _o->time_on_tightrope;
  auto _can_dismount = _o->can_dismount;
  auto _tightrope_item = _o->tightrope_item;
  return TEN::Save::CreateTightropeControlData(
      _fbb,
      _balance,
      _time_on_tightrope,
      _can_dismount,
      _tightrope_item);
}

inline WeaponControlDataT *WeaponControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WeaponControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponControlData::UnPackTo(WeaponControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weapon_item(); _o->weapon_item = _e; }
  { auto _e = has_fired(); _o->has_fired = _e; }
  { auto _e = fired(); _o->fired = _e; }
  { auto _e = uzi_left(); _o->uzi_left = _e; }
  { auto _e = uzi_right(); _o->uzi_right = _e; }
  { auto _e = gun_type(); _o->gun_type = _e; }
  { auto _e = request_gun_type(); _o->request_gun_type = _e; }
  { auto _e = last_gun_type(); _o->last_gun_type = _e; }
  { auto _e = holster_info(); if (_e) _o->holster_info = std::unique_ptr<TEN::Save::HolsterInfoT>(_e->UnPack(_resolver)); }
  { auto _e = num_shots_fired(); _o->num_shots_fired = _e; }
  { auto _e = interval(); _o->interval = _e; }
  { auto _e = timer(); _o->timer = _e; }
}

inline flatbuffers::Offset<WeaponControlData> WeaponControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWeaponControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WeaponControlData> CreateWeaponControlData(flatbuffers::FlatBufferBuilder &_fbb, const WeaponControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WeaponControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weapon_item = _o->weapon_item;
  auto _has_fired = _o->has_fired;
  auto _fired = _o->fired;
  auto _uzi_left = _o->uzi_left;
  auto _uzi_right = _o->uzi_right;
  auto _gun_type = _o->gun_type;
  auto _request_gun_type = _o->request_gun_type;
  auto _last_gun_type = _o->last_gun_type;
  auto _holster_info = _o->holster_info ? CreateHolsterInfo(_fbb, _o->holster_info.get(), _rehasher) : 0;
  auto _num_shots_fired = _o->num_shots_fired;
  auto _interval = _o->interval;
  auto _timer = _o->timer;
  return TEN::Save::CreateWeaponControlData(
      _fbb,
      _weapon_item,
      _has_fired,
      _fired,
      _uzi_left,
      _uzi_right,
      _gun_type,
      _request_gun_type,
      _last_gun_type,
      _holster_info,
      _num_shots_fired,
      _interval,
      _timer);
}

inline LaraControlDataT *LaraControlData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraControlDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraControlData::UnPackTo(LaraControlDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = can_climb_ladder(); _o->can_climb_ladder = _e; }
  { auto _e = can_monkey_swing(); _o->can_monkey_swing = _e; }
  { auto _e = count(); if (_e) _o->count = std::unique_ptr<TEN::Save::LaraCountDataT>(_e->UnPack(_resolver)); }
  { auto _e = hand_status(); _o->hand_status = _e; }
  { auto _e = is_climbing_ladder(); _o->is_climbing_ladder = _e; }
  { auto _e = is_locked(); _o->is_locked = _e; }
  { auto _e = is_low(); _o->is_low = _e; }
  { auto _e = is_moving(); _o->is_moving = _e; }
  { auto _e = is_run_jump_queued(); _o->is_run_jump_queued = _e; }
  { auto _e = jump_direction(); _o->jump_direction = _e; }
  { auto _e = keep_low(); _o->keep_low = _e; }
  { auto _e = look(); if (_e) _o->look = std::unique_ptr<TEN::Save::LookControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = move_angle(); _o->move_angle = _e; }
  { auto _e = rope(); if (_e) _o->rope = std::unique_ptr<TEN::Save::RopeControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = subsuit(); if (_e) _o->subsuit = std::unique_ptr<TEN::Save::SubsuitControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = tightrope(); if (_e) _o->tightrope = std::unique_ptr<TEN::Save::TightropeControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = turn_rate(); _o->turn_rate = _e; }
  { auto _e = water_status(); _o->water_status = _e; }
  { auto _e = weapon(); if (_e) _o->weapon = std::unique_ptr<TEN::Save::WeaponControlDataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<LaraControlData> LaraControlData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraControlData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraControlData> CreateLaraControlData(flatbuffers::FlatBufferBuilder &_fbb, const LaraControlDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraControlDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _can_climb_ladder = _o->can_climb_ladder;
  auto _can_monkey_swing = _o->can_monkey_swing;
  auto _count = _o->count ? CreateLaraCountData(_fbb, _o->count.get(), _rehasher) : 0;
  auto _hand_status = _o->hand_status;
  auto _is_climbing_ladder = _o->is_climbing_ladder;
  auto _is_locked = _o->is_locked;
  auto _is_low = _o->is_low;
  auto _is_moving = _o->is_moving;
  auto _is_run_jump_queued = _o->is_run_jump_queued;
  auto _jump_direction = _o->jump_direction;
  auto _keep_low = _o->keep_low;
  auto _look = _o->look ? CreateLookControlData(_fbb, _o->look.get(), _rehasher) : 0;
  auto _move_angle = _o->move_angle;
  auto _rope = _o->rope ? CreateRopeControlData(_fbb, _o->rope.get(), _rehasher) : 0;
  auto _subsuit = _o->subsuit ? CreateSubsuitControlData(_fbb, _o->subsuit.get(), _rehasher) : 0;
  auto _tightrope = _o->tightrope ? CreateTightropeControlData(_fbb, _o->tightrope.get(), _rehasher) : 0;
  auto _turn_rate = _o->turn_rate;
  auto _water_status = _o->water_status;
  auto _weapon = _o->weapon ? CreateWeaponControlData(_fbb, _o->weapon.get(), _rehasher) : 0;
  return TEN::Save::CreateLaraControlData(
      _fbb,
      _can_climb_ladder,
      _can_monkey_swing,
      _count,
      _hand_status,
      _is_climbing_ladder,
      _is_locked,
      _is_low,
      _is_moving,
      _is_run_jump_queued,
      _jump_direction,
      _keep_low,
      _look,
      _move_angle,
      _rope,
      _subsuit,
      _tightrope,
      _turn_rate,
      _water_status,
      _weapon);
}

inline PlayerEffectDataT *PlayerEffectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PlayerEffectDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerEffectData::UnPackTo(PlayerEffectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bubble_nodes(); if (_e) { _o->bubble_nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bubble_nodes[_i] = _e->Get(_i); } } }
  { auto _e = drip_nodes(); if (_e) { _o->drip_nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->drip_nodes[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PlayerEffectData> PlayerEffectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerEffectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerEffectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerEffectData> CreatePlayerEffectData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerEffectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerEffectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bubble_nodes = _fbb.CreateVector(_o->bubble_nodes);
  auto _drip_nodes = _fbb.CreateVector(_o->drip_nodes);
  return TEN::Save::CreatePlayerEffectData(
      _fbb,
      _bubble_nodes,
      _drip_nodes);
}

inline PlayerStatusDataT *PlayerStatusData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PlayerStatusDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerStatusData::UnPackTo(PlayerStatusDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = air(); _o->air = _e; }
  { auto _e = exposure(); _o->exposure = _e; }
  { auto _e = poison(); _o->poison = _e; }
  { auto _e = stamina(); _o->stamina = _e; }
}

inline flatbuffers::Offset<PlayerStatusData> PlayerStatusData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerStatusData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerStatusData> CreatePlayerStatusData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerStatusDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _air = _o->air;
  auto _exposure = _o->exposure;
  auto _poison = _o->poison;
  auto _stamina = _o->stamina;
  return TEN::Save::CreatePlayerStatusData(
      _fbb,
      _air,
      _exposure,
      _poison,
      _stamina);
}

inline PlayerContextDataT *PlayerContextData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PlayerContextDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerContextData::UnPackTo(PlayerContextDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calc_jump_velocity(); _o->calc_jump_velocity = _e; }
  { auto _e = interacted_item_number(); _o->interacted_item_number = _e; }
  { auto _e = next_corner_pose(); if (_e) _o->next_corner_pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
  { auto _e = projected_floor_height(); _o->projected_floor_height = _e; }
  { auto _e = target_orient(); if (_e) _o->target_orient = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = vehicle_item_number(); _o->vehicle_item_number = _e; }
  { auto _e = water_current_active(); _o->water_current_active = _e; }
  { auto _e = water_current_pull(); if (_e) _o->water_current_pull = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = water_surface_dist(); _o->water_surface_dist = _e; }
}

inline flatbuffers::Offset<PlayerContextData> PlayerContextData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerContextDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerContextData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerContextData> CreatePlayerContextData(flatbuffers::FlatBufferBuilder &_fbb, const PlayerContextDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerContextDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calc_jump_velocity = _o->calc_jump_velocity;
  auto _interacted_item_number = _o->interacted_item_number;
  auto _next_corner_pose = _o->next_corner_pose ? _o->next_corner_pose.get() : 0;
  auto _projected_floor_height = _o->projected_floor_height;
  auto _target_orient = _o->target_orient ? _o->target_orient.get() : 0;
  auto _vehicle_item_number = _o->vehicle_item_number;
  auto _water_current_active = _o->water_current_active;
  auto _water_current_pull = _o->water_current_pull ? _o->water_current_pull.get() : 0;
  auto _water_surface_dist = _o->water_surface_dist;
  return TEN::Save::CreatePlayerContextData(
      _fbb,
      _calc_jump_velocity,
      _interacted_item_number,
      _next_corner_pose,
      _projected_floor_height,
      _target_orient,
      _vehicle_item_number,
      _water_current_active,
      _water_current_pull,
      _water_surface_dist);
}

inline CollisionInfoDataT *CollisionInfoData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CollisionInfoDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CollisionInfoData::UnPackTo(CollisionInfoDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = last_bridge_item_number(); _o->last_bridge_item_number = _e; }
  { auto _e = last_bridge_item_pose(); if (_e) _o->last_bridge_item_pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
}

inline flatbuffers::Offset<CollisionInfoData> CollisionInfoData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollisionInfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollisionInfoData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CollisionInfoData> CreateCollisionInfoData(flatbuffers::FlatBufferBuilder &_fbb, const CollisionInfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CollisionInfoDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _last_bridge_item_number = _o->last_bridge_item_number;
  auto _last_bridge_item_pose = _o->last_bridge_item_pose ? _o->last_bridge_item_pose.get() : 0;
  return TEN::Save::CreateCollisionInfoData(
      _fbb,
      _last_bridge_item_number,
      _last_bridge_item_pose);
}

inline LaraT *Lara::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lara::UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = context(); if (_e) _o->context = std::unique_ptr<TEN::Save::PlayerContextDataT>(_e->UnPack(_resolver)); }
  { auto _e = control(); if (_e) _o->control = std::unique_ptr<TEN::Save::LaraControlDataT>(_e->UnPack(_resolver)); }
  { auto _e = effect(); if (_e) _o->effect = std::unique_ptr<TEN::Save::PlayerEffectDataT>(_e->UnPack(_resolver)); }
  { auto _e = collision(); if (_e) _o->collision = std::unique_ptr<TEN::Save::CollisionInfoDataT>(_e->UnPack(_resolver)); }
  { auto _e = extra_anim(); _o->extra_anim = _e; }
  { auto _e = extra_head_rot(); if (_e) _o->extra_head_rot = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = extra_torso_rot(); if (_e) _o->extra_torso_rot = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = flare(); if (_e) _o->flare = std::unique_ptr<TEN::Save::FlareDataT>(_e->UnPack(_resolver)); }
  { auto _e = highest_location(); _o->highest_location = _e; }
  { auto _e = hit_direction(); _o->hit_direction = _e; }
  { auto _e = hit_frame(); _o->hit_frame = _e; }
  { auto _e = inventory(); if (_e) _o->inventory = std::unique_ptr<TEN::Save::LaraInventoryDataT>(_e->UnPack(_resolver)); }
  { auto _e = left_arm(); if (_e) _o->left_arm = std::unique_ptr<TEN::Save::ArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = location(); _o->location = _e; }
  { auto _e = location_pad(); _o->location_pad = _e; }
  { auto _e = right_arm(); if (_e) _o->right_arm = std::unique_ptr<TEN::Save::ArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<TEN::Save::PlayerStatusDataT>(_e->UnPack(_resolver)); }
  { auto _e = target_arm_orient(); if (_e) _o->target_arm_orient = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = target_entity_number(); _o->target_entity_number = _e; }
  { auto _e = torch(); if (_e) _o->torch = std::unique_ptr<TEN::Save::TorchDataT>(_e->UnPack(_resolver)); }
  { auto _e = weapons(); if (_e) { _o->weapons.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weapons[_i] = std::unique_ptr<TEN::Save::CarriedWeaponInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Lara> Lara::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLara(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _context = _o->context ? CreatePlayerContextData(_fbb, _o->context.get(), _rehasher) : 0;
  auto _control = _o->control ? CreateLaraControlData(_fbb, _o->control.get(), _rehasher) : 0;
  auto _effect = _o->effect ? CreatePlayerEffectData(_fbb, _o->effect.get(), _rehasher) : 0;
  auto _collision = _o->collision ? CreateCollisionInfoData(_fbb, _o->collision.get(), _rehasher) : 0;
  auto _extra_anim = _o->extra_anim;
  auto _extra_head_rot = _o->extra_head_rot ? _o->extra_head_rot.get() : 0;
  auto _extra_torso_rot = _o->extra_torso_rot ? _o->extra_torso_rot.get() : 0;
  auto _flare = _o->flare ? CreateFlareData(_fbb, _o->flare.get(), _rehasher) : 0;
  auto _highest_location = _o->highest_location;
  auto _hit_direction = _o->hit_direction;
  auto _hit_frame = _o->hit_frame;
  auto _inventory = _o->inventory ? CreateLaraInventoryData(_fbb, _o->inventory.get(), _rehasher) : 0;
  auto _left_arm = _o->left_arm ? CreateArmInfo(_fbb, _o->left_arm.get(), _rehasher) : 0;
  auto _location = _o->location;
  auto _location_pad = _o->location_pad;
  auto _right_arm = _o->right_arm ? CreateArmInfo(_fbb, _o->right_arm.get(), _rehasher) : 0;
  auto _status = _o->status ? CreatePlayerStatusData(_fbb, _o->status.get(), _rehasher) : 0;
  auto _target_arm_orient = _o->target_arm_orient ? _o->target_arm_orient.get() : 0;
  auto _target_entity_number = _o->target_entity_number;
  auto _torch = _o->torch ? CreateTorchData(_fbb, _o->torch.get(), _rehasher) : 0;
  auto _weapons = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> (_o->weapons.size(), [](size_t i, _VectorArgs *__va) { return CreateCarriedWeaponInfo(*__va->__fbb, __va->__o->weapons[i].get(), __va->__rehasher); }, &_va );
  return TEN::Save::CreateLara(
      _fbb,
      _context,
      _control,
      _effect,
      _collision,
      _extra_anim,
      _extra_head_rot,
      _extra_torso_rot,
      _flare,
      _highest_location,
      _hit_direction,
      _hit_frame,
      _inventory,
      _left_arm,
      _location,
      _location_pad,
      _right_arm,
      _status,
      _target_arm_orient,
      _target_entity_number,
      _torch,
      _weapons);
}

inline CameraT *Camera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Camera::UnPackTo(CameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::GameVector>(new TEN::Save::GameVector(*_e)); }
  { auto _e = target(); if (_e) _o->target = std::unique_ptr<TEN::Save::GameVector>(new TEN::Save::GameVector(*_e)); }
}

inline flatbuffers::Offset<Camera> Camera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder &_fbb, const CameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _target = _o->target ? _o->target.get() : 0;
  return TEN::Save::CreateCamera(
      _fbb,
      _position,
      _target);
}

inline FixedCameraT *FixedCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FixedCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FixedCamera::UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FixedCamera> FixedCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixedCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FixedCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFixedCamera(
      _fbb,
      _flags);
}

inline FlyByCameraT *FlyByCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FlyByCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlyByCamera::UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FlyByCamera> FlyByCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlyByCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlyByCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFlyByCamera(
      _fbb,
      _flags);
}

inline SinkT *Sink::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SinkT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sink::UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<Sink> Sink::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateSink(
      _fbb,
      _flags);
}

inline StaticMeshInfoT *StaticMeshInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StaticMeshInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StaticMeshInfo::UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = number(); _o->number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = color(); if (_e) _o->color = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<StaticMeshInfo> StaticMeshInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStaticMeshInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StaticMeshInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _number = _o->number;
  auto _room_number = _o->room_number;
  auto _pose = _o->pose ? _o->pose.get() : 0;
  auto _scale = _o->scale;
  auto _color = _o->color ? _o->color.get() : 0;
  auto _hit_points = _o->hit_points;
  auto _flags = _o->flags;
  return TEN::Save::CreateStaticMeshInfo(
      _fbb,
      _number,
      _room_number,
      _pose,
      _scale,
      _color,
      _hit_points,
      _flags);
}

inline ParticleInfoT *ParticleInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ParticleInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ParticleInfo::UnPackTo(ParticleInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_vel(); _o->x_vel = _e; }
  { auto _e = y_vel(); _o->y_vel = _e; }
  { auto _e = z_vel(); _o->z_vel = _e; }
  { auto _e = gravity(); _o->gravity = _e; }
  { auto _e = rot_ang(); _o->rot_ang = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = s_size(); _o->s_size = _e; }
  { auto _e = d_size(); _o->d_size = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = friction(); _o->friction = _e; }
  { auto _e = scalar(); _o->scalar = _e; }
  { auto _e = sprite_index(); _o->sprite_index = _e; }
  { auto _e = rot_add(); _o->rot_add = _e; }
  { auto _e = max_y_vel(); _o->max_y_vel = _e; }
  { auto _e = on(); _o->on = _e; }
  { auto _e = s_r(); _o->s_r = _e; }
  { auto _e = s_g(); _o->s_g = _e; }
  { auto _e = s_b(); _o->s_b = _e; }
  { auto _e = d_r(); _o->d_r = _e; }
  { auto _e = d_g(); _o->d_g = _e; }
  { auto _e = d_b(); _o->d_b = _e; }
  { auto _e = r(); _o->r = _e; }
  { auto _e = g(); _o->g = _e; }
  { auto _e = b(); _o->b = _e; }
  { auto _e = col_fade_speed(); _o->col_fade_speed = _e; }
  { auto _e = fade_to_black(); _o->fade_to_black = _e; }
  { auto _e = s_life(); _o->s_life = _e; }
  { auto _e = life(); _o->life = _e; }
  { auto _e = blend_mode(); _o->blend_mode = _e; }
  { auto _e = extras(); _o->extras = _e; }
  { auto _e = dynamic(); _o->dynamic = _e; }
  { auto _e = fx_obj(); _o->fx_obj = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = node_number(); _o->node_number = _e; }
  { auto _e = target_pos(); if (_e) _o->target_pos = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = sprite_id(); _o->sprite_id = _e; }
  { auto _e = damage(); _o->damage = _e; }
  { auto _e = framerate(); _o->framerate = _e; }
  { auto _e = animation_type(); _o->animation_type = _e; }
  { auto _e = light_radius(); _o->light_radius = _e; }
  { auto _e = light_flicker(); _o->light_flicker = _e; }
  { auto _e = light_flicker_s(); _o->light_flicker_s = _e; }
  { auto _e = sound(); _o->sound = _e; }
}

inline flatbuffers::Offset<ParticleInfo> ParticleInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateParticleInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ParticleInfo> CreateParticleInfo(flatbuffers::FlatBufferBuilder &_fbb, const ParticleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ParticleInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_vel = _o->x_vel;
  auto _y_vel = _o->y_vel;
  auto _z_vel = _o->z_vel;
  auto _gravity = _o->gravity;
  auto _rot_ang = _o->rot_ang;
  auto _flags = _o->flags;
  auto _s_size = _o->s_size;
  auto _d_size = _o->d_size;
  auto _size = _o->size;
  auto _friction = _o->friction;
  auto _scalar = _o->scalar;
  auto _sprite_index = _o->sprite_index;
  auto _rot_add = _o->rot_add;
  auto _max_y_vel = _o->max_y_vel;
  auto _on = _o->on;
  auto _s_r = _o->s_r;
  auto _s_g = _o->s_g;
  auto _s_b = _o->s_b;
  auto _d_r = _o->d_r;
  auto _d_g = _o->d_g;
  auto _d_b = _o->d_b;
  auto _r = _o->r;
  auto _g = _o->g;
  auto _b = _o->b;
  auto _col_fade_speed = _o->col_fade_speed;
  auto _fade_to_black = _o->fade_to_black;
  auto _s_life = _o->s_life;
  auto _life = _o->life;
  auto _blend_mode = _o->blend_mode;
  auto _extras = _o->extras;
  auto _dynamic = _o->dynamic;
  auto _fx_obj = _o->fx_obj;
  auto _room_number = _o->room_number;
  auto _node_number = _o->node_number;
  auto _target_pos = _o->target_pos ? _o->target_pos.get() : 0;
  auto _sprite_id = _o->sprite_id;
  auto _damage = _o->damage;
  auto _framerate = _o->framerate;
  auto _animation_type = _o->animation_type;
  auto _light_radius = _o->light_radius;
  auto _light_flicker = _o->light_flicker;
  auto _light_flicker_s = _o->light_flicker_s;
  auto _sound = _o->sound;
  return TEN::Save::CreateParticleInfo(
      _fbb,
      _x,
      _y,
      _z,
      _x_vel,
      _y_vel,
      _z_vel,
      _gravity,
      _rot_ang,
      _flags,
      _s_size,
      _d_size,
      _size,
      _friction,
      _scalar,
      _sprite_index,
      _rot_add,
      _max_y_vel,
      _on,
      _s_r,
      _s_g,
      _s_b,
      _d_r,
      _d_g,
      _d_b,
      _r,
      _g,
      _b,
      _col_fade_speed,
      _fade_to_black,
      _s_life,
      _life,
      _blend_mode,
      _extras,
      _dynamic,
      _fx_obj,
      _room_number,
      _node_number,
      _target_pos,
      _sprite_id,
      _damage,
      _framerate,
      _animation_type,
      _light_radius,
      _light_flicker,
      _light_flicker_s,
      _sound);
}

inline SoundtrackT *Soundtrack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SoundtrackT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Soundtrack::UnPackTo(SoundtrackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = position(); _o->position = _e; }
}

inline flatbuffers::Offset<Soundtrack> Soundtrack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoundtrackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoundtrack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Soundtrack> CreateSoundtrack(flatbuffers::FlatBufferBuilder &_fbb, const SoundtrackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoundtrackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _position = _o->position;
  return TEN::Save::CreateSoundtrack(
      _fbb,
      _name,
      _position);
}

inline VideoInfoT *VideoInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VideoInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VideoInfo::UnPackTo(VideoInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = position(); _o->position = _e; }
  { auto _e = silent(); _o->silent = _e; }
  { auto _e = looped(); _o->looped = _e; }
}

inline flatbuffers::Offset<VideoInfo> VideoInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VideoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVideoInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VideoInfo> CreateVideoInfo(flatbuffers::FlatBufferBuilder &_fbb, const VideoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VideoInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _position = _o->position;
  auto _silent = _o->silent;
  auto _looped = _o->looped;
  return TEN::Save::CreateVideoInfo(
      _fbb,
      _name,
      _position,
      _silent,
      _looped);
}

inline SwarmObjectInfoT *SwarmObjectInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SwarmObjectInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwarmObjectInfo::UnPackTo(SwarmObjectInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<TEN::Save::Pose>(new TEN::Save::Pose(*_e)); }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<SwarmObjectInfo> SwarmObjectInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwarmObjectInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwarmObjectInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SwarmObjectInfo> CreateSwarmObjectInfo(flatbuffers::FlatBufferBuilder &_fbb, const SwarmObjectInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwarmObjectInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _pose = _o->pose ? _o->pose.get() : 0;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateSwarmObjectInfo(
      _fbb,
      _on,
      _pose,
      _room_number,
      _flags);
}

inline RopeSegmentT *RopeSegment::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeSegmentT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RopeSegment::UnPackTo(RopeSegmentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segment(); if (_e) _o->segment = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = normalised_segment(); if (_e) _o->normalised_segment = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = mesh_segment(); if (_e) _o->mesh_segment = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = coord(); if (_e) _o->coord = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
}

inline flatbuffers::Offset<RopeSegment> RopeSegment::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeSegmentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRopeSegment(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RopeSegment> CreateRopeSegment(flatbuffers::FlatBufferBuilder &_fbb, const RopeSegmentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeSegmentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segment = _o->segment ? _o->segment.get() : 0;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  auto _normalised_segment = _o->normalised_segment ? _o->normalised_segment.get() : 0;
  auto _mesh_segment = _o->mesh_segment ? _o->mesh_segment.get() : 0;
  auto _coord = _o->coord ? _o->coord.get() : 0;
  return TEN::Save::CreateRopeSegment(
      _fbb,
      _segment,
      _velocity,
      _normalised_segment,
      _mesh_segment,
      _coord);
}

inline RopeT *Rope::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rope::UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segments(); if (_e) { _o->segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->segments[_i] = std::unique_ptr<TEN::Save::RopeSegmentT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = segment_length(); _o->segment_length = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = coiled(); _o->coiled = _e; }
}

inline flatbuffers::Offset<Rope> Rope::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRope(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segments = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RopeSegment>> (_o->segments.size(), [](size_t i, _VectorArgs *__va) { return CreateRopeSegment(*__va->__fbb, __va->__o->segments[i].get(), __va->__rehasher); }, &_va );
  auto _position = _o->position ? _o->position.get() : 0;
  auto _segment_length = _o->segment_length;
  auto _active = _o->active;
  auto _coiled = _o->coiled;
  return TEN::Save::CreateRope(
      _fbb,
      _segments,
      _position,
      _segment_length,
      _active,
      _coiled);
}

inline PendulumT *Pendulum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PendulumT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pendulum::UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = node(); _o->node = _e; }
}

inline flatbuffers::Offset<Pendulum> Pendulum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePendulum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PendulumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  auto _node = _o->node;
  return TEN::Save::CreatePendulum(
      _fbb,
      _position,
      _velocity,
      _node);
}

inline EventSetT *EventSet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<EventSetT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EventSet::UnPackTo(EventSetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = statuses(); if (_e) { _o->statuses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->statuses[_i] = _e->Get(_i) != 0; } } }
  { auto _e = call_counters(); if (_e) { _o->call_counters.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->call_counters[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<EventSet> EventSet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventSet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventSet> CreateEventSet(flatbuffers::FlatBufferBuilder &_fbb, const EventSetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EventSetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _statuses = _fbb.CreateVector(_o->statuses);
  auto _call_counters = _fbb.CreateVector(_o->call_counters);
  return TEN::Save::CreateEventSet(
      _fbb,
      _index,
      _statuses,
      _call_counters);
}

inline VolumeStateT *VolumeState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VolumeStateT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VolumeState::UnPackTo(VolumeStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; }
  { auto _e = activator(); _o->activator = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
}

inline flatbuffers::Offset<VolumeState> VolumeState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolumeState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VolumeState> CreateVolumeState(flatbuffers::FlatBufferBuilder &_fbb, const VolumeStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VolumeStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  auto _activator = _o->activator;
  auto _timestamp = _o->timestamp;
  return TEN::Save::CreateVolumeState(
      _fbb,
      _status,
      _activator,
      _timestamp);
}

inline VolumeT *Volume::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VolumeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Volume::UnPackTo(VolumeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = number(); _o->number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = enabled(); _o->enabled = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<TEN::Save::Vector4>(new TEN::Save::Vector4(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = queue(); if (_e) { _o->queue.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->queue[_i] = std::unique_ptr<TEN::Save::VolumeStateT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Volume> Volume::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VolumeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolume(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Volume> CreateVolume(flatbuffers::FlatBufferBuilder &_fbb, const VolumeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VolumeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _number = _o->number;
  auto _room_number = _o->room_number;
  auto _enabled = _o->enabled;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _queue = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::VolumeState>> (_o->queue.size(), [](size_t i, _VectorArgs *__va) { return CreateVolumeState(*__va->__fbb, __va->__o->queue[i].get(), __va->__rehasher); }, &_va );
  return TEN::Save::CreateVolume(
      _fbb,
      _name,
      _number,
      _room_number,
      _enabled,
      _position,
      _rotation,
      _scale,
      _queue);
}

inline FishDataT *FishData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FishDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FishData::UnPackTo(FishDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_patrolling(); _o->is_patrolling = _e; }
  { auto _e = is_lethal(); _o->is_lethal = _e; }
  { auto _e = leader_item_number(); _o->leader_item_number = _e; }
  { auto _e = life(); _o->life = _e; }
  { auto _e = mesh_index(); _o->mesh_index = _e; }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = position_target(); if (_e) _o->position_target = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = target_item_number(); _o->target_item_number = _e; }
  { auto _e = undulation(); _o->undulation = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
}

inline flatbuffers::Offset<FishData> FishData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FishDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFishData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FishData> CreateFishData(flatbuffers::FlatBufferBuilder &_fbb, const FishDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FishDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_patrolling = _o->is_patrolling;
  auto _is_lethal = _o->is_lethal;
  auto _leader_item_number = _o->leader_item_number;
  auto _life = _o->life;
  auto _mesh_index = _o->mesh_index;
  auto _orientation = _o->orientation ? _o->orientation.get() : 0;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _position_target = _o->position_target ? _o->position_target.get() : 0;
  auto _room_number = _o->room_number;
  auto _target_item_number = _o->target_item_number;
  auto _undulation = _o->undulation;
  auto _velocity = _o->velocity;
  return TEN::Save::CreateFishData(
      _fbb,
      _is_patrolling,
      _is_lethal,
      _leader_item_number,
      _life,
      _mesh_index,
      _orientation,
      _position,
      _position_target,
      _room_number,
      _target_item_number,
      _undulation,
      _velocity);
}

inline FireflyDataT *FireflyData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FireflyDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FireflyData::UnPackTo(FireflyDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sprite_index(); _o->sprite_index = _e; }
  { auto _e = sprite_id(); _o->sprite_id = _e; }
  { auto _e = blend_mode(); _o->blend_mode = _e; }
  { auto _e = scalar(); _o->scalar = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = position_target(); if (_e) _o->position_target = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<TEN::Save::EulerAngles>(new TEN::Save::EulerAngles(*_e)); }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = target_item_number(); _o->target_item_number = _e; }
  { auto _e = z_vel(); _o->z_vel = _e; }
  { auto _e = life(); _o->life = _e; }
  { auto _e = number(); _o->number = _e; }
  { auto _e = d_r(); _o->d_r = _e; }
  { auto _e = d_g(); _o->d_g = _e; }
  { auto _e = d_b(); _o->d_b = _e; }
  { auto _e = r(); _o->r = _e; }
  { auto _e = g(); _o->g = _e; }
  { auto _e = b(); _o->b = _e; }
  { auto _e = on(); _o->on = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = rot_Ang(); _o->rot_Ang = _e; }
}

inline flatbuffers::Offset<FireflyData> FireflyData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FireflyDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFireflyData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FireflyData> CreateFireflyData(flatbuffers::FlatBufferBuilder &_fbb, const FireflyDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FireflyDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sprite_index = _o->sprite_index;
  auto _sprite_id = _o->sprite_id;
  auto _blend_mode = _o->blend_mode;
  auto _scalar = _o->scalar;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _room_number = _o->room_number;
  auto _position_target = _o->position_target ? _o->position_target.get() : 0;
  auto _orientation = _o->orientation ? _o->orientation.get() : 0;
  auto _velocity = _o->velocity;
  auto _target_item_number = _o->target_item_number;
  auto _z_vel = _o->z_vel;
  auto _life = _o->life;
  auto _number = _o->number;
  auto _d_r = _o->d_r;
  auto _d_g = _o->d_g;
  auto _d_b = _o->d_b;
  auto _r = _o->r;
  auto _g = _o->g;
  auto _b = _o->b;
  auto _on = _o->on;
  auto _size = _o->size;
  auto _rot_Ang = _o->rot_Ang;
  return TEN::Save::CreateFireflyData(
      _fbb,
      _sprite_index,
      _sprite_id,
      _blend_mode,
      _scalar,
      _position,
      _room_number,
      _position_target,
      _orientation,
      _velocity,
      _target_item_number,
      _z_vel,
      _life,
      _number,
      _d_r,
      _d_g,
      _d_b,
      _r,
      _g,
      _b,
      _on,
      _size,
      _rot_Ang);
}

inline ScriptTableT *ScriptTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ScriptTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScriptTable::UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keys_vals(); if (_e) { _o->keys_vals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_vals[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<ScriptTable> ScriptTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScriptTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScriptTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keys_vals = _fbb.CreateVectorOfStructs(_o->keys_vals);
  return TEN::Save::CreateScriptTable(
      _fbb,
      _keys_vals);
}

inline stringTableT *stringTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<stringTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void stringTable::UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = str(); if (_e) _o->str = _e->str(); }
}

inline flatbuffers::Offset<stringTable> stringTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatestringTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const stringTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _str = _o->str.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->str);
  return TEN::Save::CreatestringTable(
      _fbb,
      _str);
}

inline doubleTableT *doubleTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<doubleTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void doubleTable::UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<doubleTable> doubleTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatedoubleTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const doubleTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreatedoubleTable(
      _fbb,
      _scalar);
}

inline boolTableT *boolTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<boolTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void boolTable::UnPackTo(boolTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<boolTable> boolTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateboolTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<boolTable> CreateboolTable(flatbuffers::FlatBufferBuilder &_fbb, const boolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const boolTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateboolTable(
      _fbb,
      _scalar);
}

inline timeTableT *timeTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<timeTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void timeTable::UnPackTo(timeTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<timeTable> timeTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const timeTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetimeTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<timeTable> CreatetimeTable(flatbuffers::FlatBufferBuilder &_fbb, const timeTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const timeTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreatetimeTable(
      _fbb,
      _scalar);
}

inline vec2TableT *vec2Table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<vec2TableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void vec2Table::UnPackTo(vec2TableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vec(); if (_e) _o->vec = std::unique_ptr<TEN::Save::Vector2>(new TEN::Save::Vector2(*_e)); }
}

inline flatbuffers::Offset<vec2Table> vec2Table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const vec2TableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createvec2Table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<vec2Table> Createvec2Table(flatbuffers::FlatBufferBuilder &_fbb, const vec2TableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const vec2TableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vec = _o->vec ? _o->vec.get() : 0;
  return TEN::Save::Createvec2Table(
      _fbb,
      _vec);
}

inline vec3TableT *vec3Table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<vec3TableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void vec3Table::UnPackTo(vec3TableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vec(); if (_e) _o->vec = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
}

inline flatbuffers::Offset<vec3Table> vec3Table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const vec3TableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createvec3Table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<vec3Table> Createvec3Table(flatbuffers::FlatBufferBuilder &_fbb, const vec3TableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const vec3TableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vec = _o->vec ? _o->vec.get() : 0;
  return TEN::Save::Createvec3Table(
      _fbb,
      _vec);
}

inline rotationTableT *rotationTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<rotationTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void rotationTable::UnPackTo(rotationTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vec(); if (_e) _o->vec = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
}

inline flatbuffers::Offset<rotationTable> rotationTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const rotationTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreaterotationTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<rotationTable> CreaterotationTable(flatbuffers::FlatBufferBuilder &_fbb, const rotationTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const rotationTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vec = _o->vec ? _o->vec.get() : 0;
  return TEN::Save::CreaterotationTable(
      _fbb,
      _vec);
}

inline colorTableT *colorTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<colorTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void colorTable::UnPackTo(colorTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<colorTable> colorTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const colorTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatecolorTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<colorTable> CreatecolorTable(flatbuffers::FlatBufferBuilder &_fbb, const colorTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const colorTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _color = _o->color;
  return TEN::Save::CreatecolorTable(
      _fbb,
      _color);
}

inline funcNameTableT *funcNameTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<funcNameTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void funcNameTable::UnPackTo(funcNameTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = str(); if (_e) _o->str = _e->str(); }
}

inline flatbuffers::Offset<funcNameTable> funcNameTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const funcNameTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatefuncNameTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<funcNameTable> CreatefuncNameTable(flatbuffers::FlatBufferBuilder &_fbb, const funcNameTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const funcNameTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _str = _o->str.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->str);
  return TEN::Save::CreatefuncNameTable(
      _fbb,
      _str);
}

inline UnionTableT *UnionTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionTable::UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = u_type(); _o->u.type = _e; }
  { auto _e = u(); if (_e) _o->u.value = TEN::Save::VarUnionUnion::UnPack(_e, u_type(), _resolver); }
}

inline flatbuffers::Offset<UnionTable> UnionTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _u_type = _o->u.type;
  auto _u = _o->u.Pack(_fbb);
  return TEN::Save::CreateUnionTable(
      _fbb,
      _u_type,
      _u);
}

inline UnionVecT *UnionVec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionVecT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionVec::UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = members(); if (_e) { _o->members.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->members[_i] = std::unique_ptr<TEN::Save::UnionTableT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UnionVec> UnionVec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionVecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _members = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>> (_o->members.size(), [](size_t i, _VectorArgs *__va) { return CreateUnionTable(*__va->__fbb, __va->__o->members[i].get(), __va->__rehasher); }, &_va );
  return TEN::Save::CreateUnionVec(
      _fbb,
      _members);
}

inline SaveGameHeaderT *SaveGameHeader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameHeaderT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameHeader::UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level_name(); if (_e) _o->level_name = _e->str(); }
  { auto _e = level_hash(); _o->level_hash = _e; }
  { auto _e = hours(); _o->hours = _e; }
  { auto _e = minutes(); _o->minutes = _e; }
  { auto _e = seconds(); _o->seconds = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<SaveGameHeader> SaveGameHeader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameHeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level_name = _o->level_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->level_name);
  auto _level_hash = _o->level_hash;
  auto _hours = _o->hours;
  auto _minutes = _o->minutes;
  auto _seconds = _o->seconds;
  auto _level = _o->level;
  auto _timer = _o->timer;
  auto _count = _o->count;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      _level_name,
      _level_hash,
      _hours,
      _minutes,
      _seconds,
      _level,
      _timer,
      _count);
}

inline SaveGameStatisticsT *SaveGameStatistics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameStatisticsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameStatistics::UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ammo_hits(); _o->ammo_hits = _e; }
  { auto _e = ammo_used(); _o->ammo_used = _e; }
  { auto _e = medipacks_used(); _o->medipacks_used = _e; }
  { auto _e = damage_taken(); _o->damage_taken = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = pickups(); _o->pickups = _e; }
  { auto _e = secrets(); _o->secrets = _e; }
  { auto _e = timer(); _o->timer = _e; }
}

inline flatbuffers::Offset<SaveGameStatistics> SaveGameStatistics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameStatistics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameStatisticsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ammo_hits = _o->ammo_hits;
  auto _ammo_used = _o->ammo_used;
  auto _medipacks_used = _o->medipacks_used;
  auto _damage_taken = _o->damage_taken;
  auto _distance = _o->distance;
  auto _kills = _o->kills;
  auto _pickups = _o->pickups;
  auto _secrets = _o->secrets;
  auto _timer = _o->timer;
  return TEN::Save::CreateSaveGameStatistics(
      _fbb,
      _ammo_hits,
      _ammo_used,
      _medipacks_used,
      _damage_taken,
      _distance,
      _kills,
      _pickups,
      _secrets,
      _timer);
}

inline SaveGameT *SaveGame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGame::UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<TEN::Save::SaveGameHeaderT>(_e->UnPack(_resolver)); }
  { auto _e = game(); if (_e) _o->game = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = level(); if (_e) _o->level = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = level_data(); if (_e) _o->level_data = std::unique_ptr<TEN::Save::LevelDataT>(_e->UnPack(_resolver)); }
  { auto _e = secret_bits(); _o->secret_bits = _e; }
  { auto _e = camera(); if (_e) _o->camera = std::unique_ptr<TEN::Save::CameraT>(_e->UnPack(_resolver)); }
  { auto _e = lara(); if (_e) _o->lara = std::unique_ptr<TEN::Save::LaraT>(_e->UnPack(_resolver)); }
  { auto _e = rooms(); if (_e) { _o->rooms.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rooms[_i] = std::unique_ptr<TEN::Save::RoomT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<TEN::Save::ItemT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = next_item_free(); _o->next_item_free = _e; }
  { auto _e = next_item_active(); _o->next_item_active = _e; }
  { auto _e = room_items(); if (_e) { _o->room_items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->room_items[_i] = _e->Get(_i); } } }
  { auto _e = fish_swarm(); if (_e) { _o->fish_swarm.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fish_swarm[_i] = std::unique_ptr<TEN::Save::FishDataT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = firefly_swarm(); if (_e) { _o->firefly_swarm.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->firefly_swarm[_i] = std::unique_ptr<TEN::Save::FireflyDataT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = fxinfos(); if (_e) { _o->fxinfos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fxinfos[_i] = std::unique_ptr<TEN::Save::FXInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = next_fx_free(); _o->next_fx_free = _e; }
  { auto _e = next_fx_active(); _o->next_fx_active = _e; }
  { auto _e = fixed_cameras(); if (_e) { _o->fixed_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fixed_cameras[_i] = std::unique_ptr<TEN::Save::FixedCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = sinks(); if (_e) { _o->sinks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sinks[_i] = std::unique_ptr<TEN::Save::SinkT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = static_meshes(); if (_e) { _o->static_meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->static_meshes[_i] = std::unique_ptr<TEN::Save::StaticMeshInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flyby_cameras(); if (_e) { _o->flyby_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flyby_cameras[_i] = std::unique_ptr<TEN::Save::FlyByCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = particles(); if (_e) { _o->particles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->particles[_i] = std::unique_ptr<TEN::Save::ParticleInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = rats(); if (_e) { _o->rats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rats[_i] = std::unique_ptr<TEN::Save::SwarmObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = spiders(); if (_e) { _o->spiders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spiders[_i] = std::unique_ptr<TEN::Save::SwarmObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = scarabs(); if (_e) { _o->scarabs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scarabs[_i] = std::unique_ptr<TEN::Save::SwarmObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = bats(); if (_e) { _o->bats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bats[_i] = std::unique_ptr<TEN::Save::SwarmObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flip_maps(); if (_e) { _o->flip_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_maps[_i] = _e->Get(_i); } } }
  { auto _e = flip_stats(); if (_e) { _o->flip_stats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_stats[_i] = _e->Get(_i); } } }
  { auto _e = flip_effect(); _o->flip_effect = _e; }
  { auto _e = flip_timer(); _o->flip_timer = _e; }
  { auto _e = flip_status(); _o->flip_status = _e; }
  { auto _e = current_fov(); _o->current_fov = _e; }
  { auto _e = last_inv_item(); _o->last_inv_item = _e; }
  { auto _e = action_queue(); if (_e) { _o->action_queue.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action_queue[_i] = _e->Get(_i); } } }
  { auto _e = soundtracks(); if (_e) { _o->soundtracks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->soundtracks[_i] = std::unique_ptr<TEN::Save::SoundtrackT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = cd_flags(); if (_e) { _o->cd_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cd_flags[_i] = _e->Get(_i); } } }
  { auto _e = video(); if (_e) _o->video = std::unique_ptr<TEN::Save::VideoInfoT>(_e->UnPack(_resolver)); }
  { auto _e = postprocess_mode(); _o->postprocess_mode = _e; }
  { auto _e = postprocess_strength(); _o->postprocess_strength = _e; }
  { auto _e = postprocess_tint(); if (_e) _o->postprocess_tint = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = rope(); if (_e) _o->rope = std::unique_ptr<TEN::Save::RopeT>(_e->UnPack(_resolver)); }
  { auto _e = pendulum(); if (_e) _o->pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = alternate_pendulum(); if (_e) _o->alternate_pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = volumes(); if (_e) { _o->volumes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->volumes[_i] = std::unique_ptr<TEN::Save::VolumeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = global_event_sets(); if (_e) { _o->global_event_sets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->global_event_sets[_i] = std::unique_ptr<TEN::Save::EventSetT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = volume_event_sets(); if (_e) { _o->volume_event_sets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->volume_event_sets[_i] = std::unique_ptr<TEN::Save::EventSetT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = script_vars(); if (_e) _o->script_vars = std::unique_ptr<TEN::Save::UnionVecT>(_e->UnPack(_resolver)); }
  { auto _e = callbacks_pre_start(); if (_e) { _o->callbacks_pre_start.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_start[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_start(); if (_e) { _o->callbacks_post_start.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_start[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_end(); if (_e) { _o->callbacks_pre_end.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_end[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_end(); if (_e) { _o->callbacks_post_end.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_end[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_save(); if (_e) { _o->callbacks_pre_save.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_save[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_save(); if (_e) { _o->callbacks_post_save.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_save[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_load(); if (_e) { _o->callbacks_pre_load.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_load[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_load(); if (_e) { _o->callbacks_post_load.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_load[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_loop(); if (_e) { _o->callbacks_pre_loop.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_loop[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_loop(); if (_e) { _o->callbacks_post_loop.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_loop[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_useitem(); if (_e) { _o->callbacks_pre_useitem.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_useitem[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_useitem(); if (_e) { _o->callbacks_post_useitem.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_useitem[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_pre_freeze(); if (_e) { _o->callbacks_pre_freeze.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_pre_freeze[_i] = _e->Get(_i)->str(); } } }
  { auto _e = callbacks_post_freeze(); if (_e) { _o->callbacks_post_freeze.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callbacks_post_freeze[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<SaveGame> SaveGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _header = _o->header ? CreateSaveGameHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _game = _o->game ? CreateSaveGameStatistics(_fbb, _o->game.get(), _rehasher) : 0;
  auto _level = _o->level ? CreateSaveGameStatistics(_fbb, _o->level.get(), _rehasher) : 0;
  auto _level_data = _o->level_data ? CreateLevelData(_fbb, _o->level_data.get(), _rehasher) : 0;
  auto _secret_bits = _o->secret_bits;
  auto _camera = _o->camera ? CreateCamera(_fbb, _o->camera.get(), _rehasher) : 0;
  auto _lara = _o->lara ? CreateLara(_fbb, _o->lara.get(), _rehasher) : 0;
  auto _rooms = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Room>> (_o->rooms.size(), [](size_t i, _VectorArgs *__va) { return CreateRoom(*__va->__fbb, __va->__o->rooms[i].get(), __va->__rehasher); }, &_va );
  auto _items = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateItem(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va );
  auto _next_item_free = _o->next_item_free;
  auto _next_item_active = _o->next_item_active;
  auto _room_items = _fbb.CreateVector(_o->room_items);
  auto _fish_swarm = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FishData>> (_o->fish_swarm.size(), [](size_t i, _VectorArgs *__va) { return CreateFishData(*__va->__fbb, __va->__o->fish_swarm[i].get(), __va->__rehasher); }, &_va );
  auto _firefly_swarm = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FireflyData>> (_o->firefly_swarm.size(), [](size_t i, _VectorArgs *__va) { return CreateFireflyData(*__va->__fbb, __va->__o->firefly_swarm[i].get(), __va->__rehasher); }, &_va );
  auto _fxinfos = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FXInfo>> (_o->fxinfos.size(), [](size_t i, _VectorArgs *__va) { return CreateFXInfo(*__va->__fbb, __va->__o->fxinfos[i].get(), __va->__rehasher); }, &_va );
  auto _next_fx_free = _o->next_fx_free;
  auto _next_fx_active = _o->next_fx_active;
  auto _fixed_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>> (_o->fixed_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFixedCamera(*__va->__fbb, __va->__o->fixed_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _sinks = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>> (_o->sinks.size(), [](size_t i, _VectorArgs *__va) { return CreateSink(*__va->__fbb, __va->__o->sinks[i].get(), __va->__rehasher); }, &_va );
  auto _static_meshes = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> (_o->static_meshes.size(), [](size_t i, _VectorArgs *__va) { return CreateStaticMeshInfo(*__va->__fbb, __va->__o->static_meshes[i].get(), __va->__rehasher); }, &_va );
  auto _flyby_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>> (_o->flyby_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFlyByCamera(*__va->__fbb, __va->__o->flyby_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _particles = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ParticleInfo>> (_o->particles.size(), [](size_t i, _VectorArgs *__va) { return CreateParticleInfo(*__va->__fbb, __va->__o->particles[i].get(), __va->__rehasher); }, &_va );
  auto _rats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> (_o->rats.size(), [](size_t i, _VectorArgs *__va) { return CreateSwarmObjectInfo(*__va->__fbb, __va->__o->rats[i].get(), __va->__rehasher); }, &_va );
  auto _spiders = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> (_o->spiders.size(), [](size_t i, _VectorArgs *__va) { return CreateSwarmObjectInfo(*__va->__fbb, __va->__o->spiders[i].get(), __va->__rehasher); }, &_va );
  auto _scarabs = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> (_o->scarabs.size(), [](size_t i, _VectorArgs *__va) { return CreateSwarmObjectInfo(*__va->__fbb, __va->__o->scarabs[i].get(), __va->__rehasher); }, &_va );
  auto _bats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SwarmObjectInfo>> (_o->bats.size(), [](size_t i, _VectorArgs *__va) { return CreateSwarmObjectInfo(*__va->__fbb, __va->__o->bats[i].get(), __va->__rehasher); }, &_va );
  auto _flip_maps = _fbb.CreateVector(_o->flip_maps);
  auto _flip_stats = _fbb.CreateVector(_o->flip_stats);
  auto _flip_effect = _o->flip_effect;
  auto _flip_timer = _o->flip_timer;
  auto _flip_status = _o->flip_status;
  auto _current_fov = _o->current_fov;
  auto _last_inv_item = _o->last_inv_item;
  auto _action_queue = _fbb.CreateVector(_o->action_queue);
  auto _soundtracks = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Soundtrack>> (_o->soundtracks.size(), [](size_t i, _VectorArgs *__va) { return CreateSoundtrack(*__va->__fbb, __va->__o->soundtracks[i].get(), __va->__rehasher); }, &_va );
  auto _cd_flags = _fbb.CreateVector(_o->cd_flags);
  auto _video = _o->video ? CreateVideoInfo(_fbb, _o->video.get(), _rehasher) : 0;
  auto _postprocess_mode = _o->postprocess_mode;
  auto _postprocess_strength = _o->postprocess_strength;
  auto _postprocess_tint = _o->postprocess_tint ? _o->postprocess_tint.get() : 0;
  auto _rope = _o->rope ? CreateRope(_fbb, _o->rope.get(), _rehasher) : 0;
  auto _pendulum = _o->pendulum ? CreatePendulum(_fbb, _o->pendulum.get(), _rehasher) : 0;
  auto _alternate_pendulum = _o->alternate_pendulum ? CreatePendulum(_fbb, _o->alternate_pendulum.get(), _rehasher) : 0;
  auto _volumes = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Volume>> (_o->volumes.size(), [](size_t i, _VectorArgs *__va) { return CreateVolume(*__va->__fbb, __va->__o->volumes[i].get(), __va->__rehasher); }, &_va );
  auto _global_event_sets = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSet>> (_o->global_event_sets.size(), [](size_t i, _VectorArgs *__va) { return CreateEventSet(*__va->__fbb, __va->__o->global_event_sets[i].get(), __va->__rehasher); }, &_va );
  auto _volume_event_sets = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::EventSet>> (_o->volume_event_sets.size(), [](size_t i, _VectorArgs *__va) { return CreateEventSet(*__va->__fbb, __va->__o->volume_event_sets[i].get(), __va->__rehasher); }, &_va );
  auto _script_vars = _o->script_vars ? CreateUnionVec(_fbb, _o->script_vars.get(), _rehasher) : 0;
  auto _callbacks_pre_start = _fbb.CreateVectorOfStrings(_o->callbacks_pre_start);
  auto _callbacks_post_start = _fbb.CreateVectorOfStrings(_o->callbacks_post_start);
  auto _callbacks_pre_end = _fbb.CreateVectorOfStrings(_o->callbacks_pre_end);
  auto _callbacks_post_end = _fbb.CreateVectorOfStrings(_o->callbacks_post_end);
  auto _callbacks_pre_save = _fbb.CreateVectorOfStrings(_o->callbacks_pre_save);
  auto _callbacks_post_save = _fbb.CreateVectorOfStrings(_o->callbacks_post_save);
  auto _callbacks_pre_load = _fbb.CreateVectorOfStrings(_o->callbacks_pre_load);
  auto _callbacks_post_load = _fbb.CreateVectorOfStrings(_o->callbacks_post_load);
  auto _callbacks_pre_loop = _fbb.CreateVectorOfStrings(_o->callbacks_pre_loop);
  auto _callbacks_post_loop = _fbb.CreateVectorOfStrings(_o->callbacks_post_loop);
  auto _callbacks_pre_useitem = _fbb.CreateVectorOfStrings(_o->callbacks_pre_useitem);
  auto _callbacks_post_useitem = _fbb.CreateVectorOfStrings(_o->callbacks_post_useitem);
  auto _callbacks_pre_freeze = _fbb.CreateVectorOfStrings(_o->callbacks_pre_freeze);
  auto _callbacks_post_freeze = _fbb.CreateVectorOfStrings(_o->callbacks_post_freeze);
  return TEN::Save::CreateSaveGame(
      _fbb,
      _header,
      _game,
      _level,
      _level_data,
      _secret_bits,
      _camera,
      _lara,
      _rooms,
      _items,
      _next_item_free,
      _next_item_active,
      _room_items,
      _fish_swarm,
      _firefly_swarm,
      _fxinfos,
      _next_fx_free,
      _next_fx_active,
      _fixed_cameras,
      _sinks,
      _static_meshes,
      _flyby_cameras,
      _particles,
      _rats,
      _spiders,
      _scarabs,
      _bats,
      _flip_maps,
      _flip_stats,
      _flip_effect,
      _flip_timer,
      _flip_status,
      _current_fov,
      _last_inv_item,
      _action_queue,
      _soundtracks,
      _cd_flags,
      _video,
      _postprocess_mode,
      _postprocess_strength,
      _postprocess_tint,
      _rope,
      _pendulum,
      _alternate_pendulum,
      _volumes,
      _global_event_sets,
      _volume_event_sets,
      _script_vars,
      _callbacks_pre_start,
      _callbacks_post_start,
      _callbacks_pre_end,
      _callbacks_post_end,
      _callbacks_pre_save,
      _callbacks_post_save,
      _callbacks_pre_load,
      _callbacks_post_load,
      _callbacks_pre_loop,
      _callbacks_post_loop,
      _callbacks_pre_useitem,
      _callbacks_post_useitem,
      _callbacks_pre_freeze,
      _callbacks_post_freeze);
}

inline bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type) {
  switch (type) {
    case VarUnion::NONE: {
      return true;
    }
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::time: {
      auto ptr = reinterpret_cast<const TEN::Save::timeTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::vec2: {
      auto ptr = reinterpret_cast<const TEN::Save::vec2Table *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::vec3: {
      auto ptr = reinterpret_cast<const TEN::Save::vec3Table *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::rotation: {
      auto ptr = reinterpret_cast<const TEN::Save::rotationTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::color: {
      auto ptr = reinterpret_cast<const TEN::Save::colorTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::funcName: {
      auto ptr = reinterpret_cast<const TEN::Save::funcNameTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVarUnion(
        verifier,  values->Get(i), types->GetEnum<VarUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *VarUnionUnion::UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::time: {
      auto ptr = reinterpret_cast<const TEN::Save::timeTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::vec2: {
      auto ptr = reinterpret_cast<const TEN::Save::vec2Table *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::vec3: {
      auto ptr = reinterpret_cast<const TEN::Save::vec3Table *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::rotation: {
      auto ptr = reinterpret_cast<const TEN::Save::rotationTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::color: {
      auto ptr = reinterpret_cast<const TEN::Save::colorTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::funcName: {
      auto ptr = reinterpret_cast<const TEN::Save::funcNameTable *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> VarUnionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTableT *>(value);
      return CreatestringTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTableT *>(value);
      return CreateScriptTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTableT *>(value);
      return CreatedoubleTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<const TEN::Save::boolTableT *>(value);
      return CreateboolTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::time: {
      auto ptr = reinterpret_cast<const TEN::Save::timeTableT *>(value);
      return CreatetimeTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::vec2: {
      auto ptr = reinterpret_cast<const TEN::Save::vec2TableT *>(value);
      return Createvec2Table(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::vec3: {
      auto ptr = reinterpret_cast<const TEN::Save::vec3TableT *>(value);
      return Createvec3Table(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::rotation: {
      auto ptr = reinterpret_cast<const TEN::Save::rotationTableT *>(value);
      return CreaterotationTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::color: {
      auto ptr = reinterpret_cast<const TEN::Save::colorTableT *>(value);
      return CreatecolorTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::funcName: {
      auto ptr = reinterpret_cast<const TEN::Save::funcNameTableT *>(value);
      return CreatefuncNameTable(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline VarUnionUnion::VarUnionUnion(const VarUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case VarUnion::str: {
      value = new TEN::Save::stringTableT(*reinterpret_cast<TEN::Save::stringTableT *>(u.value));
      break;
    }
    case VarUnion::tab: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::ScriptTableT not copyable.
      break;
    }
    case VarUnion::num: {
      value = new TEN::Save::doubleTableT(*reinterpret_cast<TEN::Save::doubleTableT *>(u.value));
      break;
    }
    case VarUnion::boolean: {
      value = new TEN::Save::boolTableT(*reinterpret_cast<TEN::Save::boolTableT *>(u.value));
      break;
    }
    case VarUnion::time: {
      value = new TEN::Save::timeTableT(*reinterpret_cast<TEN::Save::timeTableT *>(u.value));
      break;
    }
    case VarUnion::vec2: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::vec2TableT not copyable.
      break;
    }
    case VarUnion::vec3: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::vec3TableT not copyable.
      break;
    }
    case VarUnion::rotation: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::rotationTableT not copyable.
      break;
    }
    case VarUnion::color: {
      value = new TEN::Save::colorTableT(*reinterpret_cast<TEN::Save::colorTableT *>(u.value));
      break;
    }
    case VarUnion::funcName: {
      value = new TEN::Save::funcNameTableT(*reinterpret_cast<TEN::Save::funcNameTableT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void VarUnionUnion::Reset() {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<TEN::Save::stringTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<TEN::Save::ScriptTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<TEN::Save::doubleTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::boolean: {
      auto ptr = reinterpret_cast<TEN::Save::boolTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::time: {
      auto ptr = reinterpret_cast<TEN::Save::timeTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::vec2: {
      auto ptr = reinterpret_cast<TEN::Save::vec2TableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::vec3: {
      auto ptr = reinterpret_cast<TEN::Save::vec3TableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::rotation: {
      auto ptr = reinterpret_cast<TEN::Save::rotationTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::color: {
      auto ptr = reinterpret_cast<TEN::Save::colorTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::funcName: {
      auto ptr = reinterpret_cast<TEN::Save::funcNameTableT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = VarUnion::NONE;
}

inline const TEN::Save::SaveGame *GetSaveGame(const void *buf) {
  return flatbuffers::GetRoot<TEN::Save::SaveGame>(buf);
}

inline const TEN::Save::SaveGame *GetSizePrefixedSaveGame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<TEN::Save::SaveGame>(buf);
}

inline bool VerifySaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TEN::Save::SaveGame>(nullptr);
}

inline bool VerifySizePrefixedSaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TEN::Save::SaveGame>(nullptr);
}

inline void FinishSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSaveGame(buf)->UnPack(res));
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSizePrefixedSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSizePrefixedSaveGame(buf)->UnPack(res));
}

}  // namespace Save
}  // namespace TEN

#endif  // FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
