// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
#define FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_

#include "flatbuffers/flatbuffers.h"

#include "ten_itemdata_generated.h"

namespace TEN {
namespace Save {

struct RoomVector;

struct Item;
struct ItemBuilder;
struct ItemT;

struct WeaponInfo;
struct WeaponInfoBuilder;
struct WeaponInfoT;

struct HolsterInfo;
struct HolsterInfoBuilder;
struct HolsterInfoT;

struct AmmoInfo;
struct AmmoInfoBuilder;
struct AmmoInfoT;

struct CarriedWeaponInfo;
struct CarriedWeaponInfoBuilder;
struct CarriedWeaponInfoT;

struct LaraArmInfo;
struct LaraArmInfoBuilder;
struct LaraArmInfoT;

struct LaraTightropeInfo;
struct LaraTightropeInfoBuilder;
struct LaraTightropeInfoT;

struct Lara;
struct LaraBuilder;
struct LaraT;

struct FixedCamera;
struct FixedCameraBuilder;
struct FixedCameraT;

struct FlyByCamera;
struct FlyByCameraBuilder;
struct FlyByCameraT;

struct Sink;
struct SinkBuilder;
struct SinkT;

struct StaticMeshInfo;
struct StaticMeshInfoBuilder;
struct StaticMeshInfoT;

struct RatInfo;
struct RatInfoBuilder;
struct RatInfoT;

struct SpiderInfo;
struct SpiderInfoBuilder;
struct SpiderInfoT;

struct ScarabInfo;
struct ScarabInfoBuilder;
struct ScarabInfoT;

struct BatInfo;
struct BatInfoBuilder;
struct BatInfoT;

struct Rope;
struct RopeBuilder;
struct RopeT;

struct Pendulum;
struct PendulumBuilder;
struct PendulumT;

struct KeyValPair;

struct ScriptTable;
struct ScriptTableBuilder;
struct ScriptTableT;

struct stringTable;
struct stringTableBuilder;
struct stringTableT;

struct doubleTable;
struct doubleTableBuilder;
struct doubleTableT;

struct UnionTable;
struct UnionTableBuilder;
struct UnionTableT;

struct UnionVec;
struct UnionVecBuilder;
struct UnionVecT;

struct SaveGameHeader;
struct SaveGameHeaderBuilder;
struct SaveGameHeaderT;

struct SaveGameStatistics;
struct SaveGameStatisticsBuilder;
struct SaveGameStatisticsT;

struct SaveGame;
struct SaveGameBuilder;
struct SaveGameT;

enum class VarUnion : uint8_t {
  NONE = 0,
  str = 1,
  tab = 2,
  num = 3,
  MIN = NONE,
  MAX = num
};

inline const VarUnion (&EnumValuesVarUnion())[4] {
  static const VarUnion values[] = {
    VarUnion::NONE,
    VarUnion::str,
    VarUnion::tab,
    VarUnion::num
  };
  return values;
}

inline const char * const *EnumNamesVarUnion() {
  static const char * const names[5] = {
    "NONE",
    "str",
    "tab",
    "num",
    nullptr
  };
  return names;
}

inline const char *EnumNameVarUnion(VarUnion e) {
  if (flatbuffers::IsOutRange(e, VarUnion::NONE, VarUnion::num)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarUnion()[index];
}

template<typename T> struct VarUnionTraits {
  static const VarUnion enum_value = VarUnion::NONE;
};

template<> struct VarUnionTraits<TEN::Save::stringTable> {
  static const VarUnion enum_value = VarUnion::str;
};

template<> struct VarUnionTraits<TEN::Save::ScriptTable> {
  static const VarUnion enum_value = VarUnion::tab;
};

template<> struct VarUnionTraits<TEN::Save::doubleTable> {
  static const VarUnion enum_value = VarUnion::num;
};

struct VarUnionUnion {
  VarUnion type;
  void *value;

  VarUnionUnion() : type(VarUnion::NONE), value(nullptr) {}
  VarUnionUnion(VarUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(VarUnion::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  VarUnionUnion(const VarUnionUnion &);
  VarUnionUnion &operator=(const VarUnionUnion &u)
    { VarUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  VarUnionUnion &operator=(VarUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~VarUnionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = VarUnionTraits<typename RT::TableType>::enum_value;
    if (type != VarUnion::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TEN::Save::stringTableT *Asstr() {
    return type == VarUnion::str ?
      reinterpret_cast<TEN::Save::stringTableT *>(value) : nullptr;
  }
  const TEN::Save::stringTableT *Asstr() const {
    return type == VarUnion::str ?
      reinterpret_cast<const TEN::Save::stringTableT *>(value) : nullptr;
  }
  TEN::Save::ScriptTableT *Astab() {
    return type == VarUnion::tab ?
      reinterpret_cast<TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  const TEN::Save::ScriptTableT *Astab() const {
    return type == VarUnion::tab ?
      reinterpret_cast<const TEN::Save::ScriptTableT *>(value) : nullptr;
  }
  TEN::Save::doubleTableT *Asnum() {
    return type == VarUnion::num ?
      reinterpret_cast<TEN::Save::doubleTableT *>(value) : nullptr;
  }
  const TEN::Save::doubleTableT *Asnum() const {
    return type == VarUnion::num ?
      reinterpret_cast<const TEN::Save::doubleTableT *>(value) : nullptr;
  }
};

bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type);
bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RoomVector FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t room_;
  uint32_t y_location_;

 public:
  struct Traits;
  RoomVector()
      : room_(0),
        y_location_(0) {
  }
  RoomVector(uint32_t _room, uint32_t _y_location)
      : room_(flatbuffers::EndianScalar(_room)),
        y_location_(flatbuffers::EndianScalar(_y_location)) {
  }
  uint32_t room() const {
    return flatbuffers::EndianScalar(room_);
  }
  uint32_t y_location() const {
    return flatbuffers::EndianScalar(y_location_);
  }
};
FLATBUFFERS_STRUCT_END(RoomVector, 8);

struct RoomVector::Traits {
  using type = RoomVector;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) KeyValPair FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t key_;
  uint32_t val_;

 public:
  struct Traits;
  KeyValPair()
      : key_(0),
        val_(0) {
  }
  KeyValPair(uint32_t _key, uint32_t _val)
      : key_(flatbuffers::EndianScalar(_key)),
        val_(flatbuffers::EndianScalar(_val)) {
  }
  uint32_t key() const {
    return flatbuffers::EndianScalar(key_);
  }
  uint32_t val() const {
    return flatbuffers::EndianScalar(val_);
  }
};
FLATBUFFERS_STRUCT_END(KeyValPair, 8);

struct KeyValPair::Traits {
  using type = KeyValPair;
};

struct ItemT : public flatbuffers::NativeTable {
  typedef Item TableType;
  int32_t floor = 0;
  int32_t touch_bits = 0;
  int32_t mesh_bits = 0;
  int32_t object_id = 0;
  int32_t current_anim_state = 0;
  int32_t goal_anim_state = 0;
  int32_t required_anim_state = 0;
  int32_t anim_number = 0;
  int32_t frame_number = 0;
  int32_t room_number = 0;
  int32_t speed = 0;
  int32_t fall_speed = 0;
  int32_t hit_points = 0;
  int32_t box_number = 0;
  int32_t timer = 0;
  int32_t flags = 0;
  int32_t trigger_flags = 0;
  int32_t carried_item = 0;
  int32_t after_death = 0;
  int32_t fired_weapon = 0;
  std::vector<int32_t> item_flags{};
  std::unique_ptr<TEN::Save::Position> position{};
  bool triggered = false;
  bool active = false;
  int32_t status = 0;
  bool gravity_status = false;
  bool hit_stauts = false;
  bool collidable = false;
  bool looked_at = false;
  bool poisoned = false;
  int32_t ai_bits = 0;
  int32_t swap_mesh_flags = 0;
  TEN::Save::ItemDataUnion data{};
};

struct Item FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOOR = 4,
    VT_TOUCH_BITS = 6,
    VT_MESH_BITS = 8,
    VT_OBJECT_ID = 10,
    VT_CURRENT_ANIM_STATE = 12,
    VT_GOAL_ANIM_STATE = 14,
    VT_REQUIRED_ANIM_STATE = 16,
    VT_ANIM_NUMBER = 18,
    VT_FRAME_NUMBER = 20,
    VT_ROOM_NUMBER = 22,
    VT_SPEED = 24,
    VT_FALL_SPEED = 26,
    VT_HIT_POINTS = 28,
    VT_BOX_NUMBER = 30,
    VT_TIMER = 32,
    VT_FLAGS = 34,
    VT_TRIGGER_FLAGS = 36,
    VT_CARRIED_ITEM = 38,
    VT_AFTER_DEATH = 40,
    VT_FIRED_WEAPON = 42,
    VT_ITEM_FLAGS = 44,
    VT_POSITION = 46,
    VT_TRIGGERED = 48,
    VT_ACTIVE = 50,
    VT_STATUS = 52,
    VT_GRAVITY_STATUS = 54,
    VT_HIT_STAUTS = 56,
    VT_COLLIDABLE = 58,
    VT_LOOKED_AT = 60,
    VT_POISONED = 62,
    VT_AI_BITS = 64,
    VT_SWAP_MESH_FLAGS = 66,
    VT_DATA_TYPE = 68,
    VT_DATA = 70
  };
  int32_t floor() const {
    return GetField<int32_t>(VT_FLOOR, 0);
  }
  int32_t touch_bits() const {
    return GetField<int32_t>(VT_TOUCH_BITS, 0);
  }
  int32_t mesh_bits() const {
    return GetField<int32_t>(VT_MESH_BITS, 0);
  }
  int32_t object_id() const {
    return GetField<int32_t>(VT_OBJECT_ID, 0);
  }
  int32_t current_anim_state() const {
    return GetField<int32_t>(VT_CURRENT_ANIM_STATE, 0);
  }
  int32_t goal_anim_state() const {
    return GetField<int32_t>(VT_GOAL_ANIM_STATE, 0);
  }
  int32_t required_anim_state() const {
    return GetField<int32_t>(VT_REQUIRED_ANIM_STATE, 0);
  }
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t speed() const {
    return GetField<int32_t>(VT_SPEED, 0);
  }
  int32_t fall_speed() const {
    return GetField<int32_t>(VT_FALL_SPEED, 0);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t box_number() const {
    return GetField<int32_t>(VT_BOX_NUMBER, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t trigger_flags() const {
    return GetField<int32_t>(VT_TRIGGER_FLAGS, 0);
  }
  int32_t carried_item() const {
    return GetField<int32_t>(VT_CARRIED_ITEM, 0);
  }
  int32_t after_death() const {
    return GetField<int32_t>(VT_AFTER_DEATH, 0);
  }
  int32_t fired_weapon() const {
    return GetField<int32_t>(VT_FIRED_WEAPON, 0);
  }
  const flatbuffers::Vector<int32_t> *item_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ITEM_FLAGS);
  }
  const TEN::Save::Position *position() const {
    return GetStruct<const TEN::Save::Position *>(VT_POSITION);
  }
  bool triggered() const {
    return GetField<uint8_t>(VT_TRIGGERED, 0) != 0;
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  bool gravity_status() const {
    return GetField<uint8_t>(VT_GRAVITY_STATUS, 0) != 0;
  }
  bool hit_stauts() const {
    return GetField<uint8_t>(VT_HIT_STAUTS, 0) != 0;
  }
  bool collidable() const {
    return GetField<uint8_t>(VT_COLLIDABLE, 0) != 0;
  }
  bool looked_at() const {
    return GetField<uint8_t>(VT_LOOKED_AT, 0) != 0;
  }
  bool poisoned() const {
    return GetField<uint8_t>(VT_POISONED, 0) != 0;
  }
  int32_t ai_bits() const {
    return GetField<int32_t>(VT_AI_BITS, 0);
  }
  int32_t swap_mesh_flags() const {
    return GetField<int32_t>(VT_SWAP_MESH_FLAGS, 0);
  }
  TEN::Save::ItemData data_type() const {
    return static_cast<TEN::Save::ItemData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const TEN::Save::Int *data_as_Int() const {
    return data_type() == TEN::Save::ItemData::Int ? static_cast<const TEN::Save::Int *>(data()) : nullptr;
  }
  const TEN::Save::Short *data_as_Short() const {
    return data_type() == TEN::Save::ItemData::Short ? static_cast<const TEN::Save::Short *>(data()) : nullptr;
  }
  const TEN::Save::Float *data_as_Float() const {
    return data_type() == TEN::Save::ItemData::Float ? static_cast<const TEN::Save::Float *>(data()) : nullptr;
  }
  const TEN::Save::ShortArray *data_as_ShortArray() const {
    return data_type() == TEN::Save::ItemData::ShortArray ? static_cast<const TEN::Save::ShortArray *>(data()) : nullptr;
  }
  const TEN::Save::ItemNumber *data_as_ItemNumber() const {
    return data_type() == TEN::Save::ItemData::ItemNumber ? static_cast<const TEN::Save::ItemNumber *>(data()) : nullptr;
  }
  const TEN::Save::Creature *data_as_Creature() const {
    return data_type() == TEN::Save::ItemData::Creature ? static_cast<const TEN::Save::Creature *>(data()) : nullptr;
  }
  const TEN::Save::LaserHead *data_as_LaserHead() const {
    return data_type() == TEN::Save::ItemData::LaserHead ? static_cast<const TEN::Save::LaserHead *>(data()) : nullptr;
  }
  const TEN::Save::QuadBike *data_as_QuadBike() const {
    return data_type() == TEN::Save::ItemData::QuadBike ? static_cast<const TEN::Save::QuadBike *>(data()) : nullptr;
  }
  const TEN::Save::BigGun *data_as_BigGun() const {
    return data_type() == TEN::Save::ItemData::BigGun ? static_cast<const TEN::Save::BigGun *>(data()) : nullptr;
  }
  const TEN::Save::Motorbike *data_as_Motorbike() const {
    return data_type() == TEN::Save::ItemData::Motorbike ? static_cast<const TEN::Save::Motorbike *>(data()) : nullptr;
  }
  const TEN::Save::Jeep *data_as_Jeep() const {
    return data_type() == TEN::Save::ItemData::Jeep ? static_cast<const TEN::Save::Jeep *>(data()) : nullptr;
  }
  const TEN::Save::LaraInfo *data_as_LaraInfo() const {
    return data_type() == TEN::Save::ItemData::LaraInfo ? static_cast<const TEN::Save::LaraInfo *>(data()) : nullptr;
  }
  const TEN::Save::Kayak *data_as_Kayak() const {
    return data_type() == TEN::Save::ItemData::Kayak ? static_cast<const TEN::Save::Kayak *>(data()) : nullptr;
  }
  const TEN::Save::Door *data_as_Door() const {
    return data_type() == TEN::Save::ItemData::Door ? static_cast<const TEN::Save::Door *>(data()) : nullptr;
  }
  const TEN::Save::Skidoo *data_as_Skidoo() const {
    return data_type() == TEN::Save::ItemData::Skidoo ? static_cast<const TEN::Save::Skidoo *>(data()) : nullptr;
  }
  const TEN::Save::UPV *data_as_UPV() const {
    return data_type() == TEN::Save::ItemData::UPV ? static_cast<const TEN::Save::UPV *>(data()) : nullptr;
  }
  const TEN::Save::Motorboat *data_as_Motorboat() const {
    return data_type() == TEN::Save::ItemData::Motorboat ? static_cast<const TEN::Save::Motorboat *>(data()) : nullptr;
  }
  const TEN::Save::GameVector *data_as_GameVector() const {
    return data_type() == TEN::Save::ItemData::GameVector ? static_cast<const TEN::Save::GameVector *>(data()) : nullptr;
  }
  const TEN::Save::Wraith *data_as_Wraith() const {
    return data_type() == TEN::Save::ItemData::Wraith ? static_cast<const TEN::Save::Wraith *>(data()) : nullptr;
  }
  const TEN::Save::Rubberboat *data_as_Rubberboat() const {
    return data_type() == TEN::Save::ItemData::Rubberboat ? static_cast<const TEN::Save::Rubberboat *>(data()) : nullptr;
  }
  const TEN::Save::Pushable *data_as_Pushable() const {
    return data_type() == TEN::Save::ItemData::Pushable ? static_cast<const TEN::Save::Pushable *>(data()) : nullptr;
  }
  const TEN::Save::Minecart *data_as_Minecart() const {
    return data_type() == TEN::Save::ItemData::Minecart ? static_cast<const TEN::Save::Minecart *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLOOR) &&
           VerifyField<int32_t>(verifier, VT_TOUCH_BITS) &&
           VerifyField<int32_t>(verifier, VT_MESH_BITS) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_ID) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_ANIM_STATE) &&
           VerifyField<int32_t>(verifier, VT_GOAL_ANIM_STATE) &&
           VerifyField<int32_t>(verifier, VT_REQUIRED_ANIM_STATE) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FALL_SPEED) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_BOX_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TRIGGER_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_CARRIED_ITEM) &&
           VerifyField<int32_t>(verifier, VT_AFTER_DEATH) &&
           VerifyField<int32_t>(verifier, VT_FIRED_WEAPON) &&
           VerifyOffset(verifier, VT_ITEM_FLAGS) &&
           verifier.VerifyVector(item_flags()) &&
           VerifyField<TEN::Save::Position>(verifier, VT_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGERED) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_GRAVITY_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_HIT_STAUTS) &&
           VerifyField<uint8_t>(verifier, VT_COLLIDABLE) &&
           VerifyField<uint8_t>(verifier, VT_LOOKED_AT) &&
           VerifyField<uint8_t>(verifier, VT_POISONED) &&
           VerifyField<int32_t>(verifier, VT_AI_BITS) &&
           VerifyField<int32_t>(verifier, VT_SWAP_MESH_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyItemData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Item> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::Int *Item::data_as<TEN::Save::Int>() const {
  return data_as_Int();
}

template<> inline const TEN::Save::Short *Item::data_as<TEN::Save::Short>() const {
  return data_as_Short();
}

template<> inline const TEN::Save::Float *Item::data_as<TEN::Save::Float>() const {
  return data_as_Float();
}

template<> inline const TEN::Save::ShortArray *Item::data_as<TEN::Save::ShortArray>() const {
  return data_as_ShortArray();
}

template<> inline const TEN::Save::ItemNumber *Item::data_as<TEN::Save::ItemNumber>() const {
  return data_as_ItemNumber();
}

template<> inline const TEN::Save::Creature *Item::data_as<TEN::Save::Creature>() const {
  return data_as_Creature();
}

template<> inline const TEN::Save::LaserHead *Item::data_as<TEN::Save::LaserHead>() const {
  return data_as_LaserHead();
}

template<> inline const TEN::Save::QuadBike *Item::data_as<TEN::Save::QuadBike>() const {
  return data_as_QuadBike();
}

template<> inline const TEN::Save::BigGun *Item::data_as<TEN::Save::BigGun>() const {
  return data_as_BigGun();
}

template<> inline const TEN::Save::Motorbike *Item::data_as<TEN::Save::Motorbike>() const {
  return data_as_Motorbike();
}

template<> inline const TEN::Save::Jeep *Item::data_as<TEN::Save::Jeep>() const {
  return data_as_Jeep();
}

template<> inline const TEN::Save::LaraInfo *Item::data_as<TEN::Save::LaraInfo>() const {
  return data_as_LaraInfo();
}

template<> inline const TEN::Save::Kayak *Item::data_as<TEN::Save::Kayak>() const {
  return data_as_Kayak();
}

template<> inline const TEN::Save::Door *Item::data_as<TEN::Save::Door>() const {
  return data_as_Door();
}

template<> inline const TEN::Save::Skidoo *Item::data_as<TEN::Save::Skidoo>() const {
  return data_as_Skidoo();
}

template<> inline const TEN::Save::UPV *Item::data_as<TEN::Save::UPV>() const {
  return data_as_UPV();
}

template<> inline const TEN::Save::Motorboat *Item::data_as<TEN::Save::Motorboat>() const {
  return data_as_Motorboat();
}

template<> inline const TEN::Save::GameVector *Item::data_as<TEN::Save::GameVector>() const {
  return data_as_GameVector();
}

template<> inline const TEN::Save::Wraith *Item::data_as<TEN::Save::Wraith>() const {
  return data_as_Wraith();
}

template<> inline const TEN::Save::Rubberboat *Item::data_as<TEN::Save::Rubberboat>() const {
  return data_as_Rubberboat();
}

template<> inline const TEN::Save::Pushable *Item::data_as<TEN::Save::Pushable>() const {
  return data_as_Pushable();
}

template<> inline const TEN::Save::Minecart *Item::data_as<TEN::Save::Minecart>() const {
  return data_as_Minecart();
}

struct ItemBuilder {
  typedef Item Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floor(int32_t floor) {
    fbb_.AddElement<int32_t>(Item::VT_FLOOR, floor, 0);
  }
  void add_touch_bits(int32_t touch_bits) {
    fbb_.AddElement<int32_t>(Item::VT_TOUCH_BITS, touch_bits, 0);
  }
  void add_mesh_bits(int32_t mesh_bits) {
    fbb_.AddElement<int32_t>(Item::VT_MESH_BITS, mesh_bits, 0);
  }
  void add_object_id(int32_t object_id) {
    fbb_.AddElement<int32_t>(Item::VT_OBJECT_ID, object_id, 0);
  }
  void add_current_anim_state(int32_t current_anim_state) {
    fbb_.AddElement<int32_t>(Item::VT_CURRENT_ANIM_STATE, current_anim_state, 0);
  }
  void add_goal_anim_state(int32_t goal_anim_state) {
    fbb_.AddElement<int32_t>(Item::VT_GOAL_ANIM_STATE, goal_anim_state, 0);
  }
  void add_required_anim_state(int32_t required_anim_state) {
    fbb_.AddElement<int32_t>(Item::VT_REQUIRED_ANIM_STATE, required_anim_state, 0);
  }
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(Item::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(Item::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(Item::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_speed(int32_t speed) {
    fbb_.AddElement<int32_t>(Item::VT_SPEED, speed, 0);
  }
  void add_fall_speed(int32_t fall_speed) {
    fbb_.AddElement<int32_t>(Item::VT_FALL_SPEED, fall_speed, 0);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(Item::VT_HIT_POINTS, hit_points, 0);
  }
  void add_box_number(int32_t box_number) {
    fbb_.AddElement<int32_t>(Item::VT_BOX_NUMBER, box_number, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(Item::VT_TIMER, timer, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Item::VT_FLAGS, flags, 0);
  }
  void add_trigger_flags(int32_t trigger_flags) {
    fbb_.AddElement<int32_t>(Item::VT_TRIGGER_FLAGS, trigger_flags, 0);
  }
  void add_carried_item(int32_t carried_item) {
    fbb_.AddElement<int32_t>(Item::VT_CARRIED_ITEM, carried_item, 0);
  }
  void add_after_death(int32_t after_death) {
    fbb_.AddElement<int32_t>(Item::VT_AFTER_DEATH, after_death, 0);
  }
  void add_fired_weapon(int32_t fired_weapon) {
    fbb_.AddElement<int32_t>(Item::VT_FIRED_WEAPON, fired_weapon, 0);
  }
  void add_item_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags) {
    fbb_.AddOffset(Item::VT_ITEM_FLAGS, item_flags);
  }
  void add_position(const TEN::Save::Position *position) {
    fbb_.AddStruct(Item::VT_POSITION, position);
  }
  void add_triggered(bool triggered) {
    fbb_.AddElement<uint8_t>(Item::VT_TRIGGERED, static_cast<uint8_t>(triggered), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Item::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(Item::VT_STATUS, status, 0);
  }
  void add_gravity_status(bool gravity_status) {
    fbb_.AddElement<uint8_t>(Item::VT_GRAVITY_STATUS, static_cast<uint8_t>(gravity_status), 0);
  }
  void add_hit_stauts(bool hit_stauts) {
    fbb_.AddElement<uint8_t>(Item::VT_HIT_STAUTS, static_cast<uint8_t>(hit_stauts), 0);
  }
  void add_collidable(bool collidable) {
    fbb_.AddElement<uint8_t>(Item::VT_COLLIDABLE, static_cast<uint8_t>(collidable), 0);
  }
  void add_looked_at(bool looked_at) {
    fbb_.AddElement<uint8_t>(Item::VT_LOOKED_AT, static_cast<uint8_t>(looked_at), 0);
  }
  void add_poisoned(bool poisoned) {
    fbb_.AddElement<uint8_t>(Item::VT_POISONED, static_cast<uint8_t>(poisoned), 0);
  }
  void add_ai_bits(int32_t ai_bits) {
    fbb_.AddElement<int32_t>(Item::VT_AI_BITS, ai_bits, 0);
  }
  void add_swap_mesh_flags(int32_t swap_mesh_flags) {
    fbb_.AddElement<int32_t>(Item::VT_SWAP_MESH_FLAGS, swap_mesh_flags, 0);
  }
  void add_data_type(TEN::Save::ItemData data_type) {
    fbb_.AddElement<uint8_t>(Item::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Item::VT_DATA, data);
  }
  explicit ItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline flatbuffers::Offset<Item> CreateItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t current_anim_state = 0,
    int32_t goal_anim_state = 0,
    int32_t required_anim_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t room_number = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    int32_t fired_weapon = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> item_flags = 0,
    const TEN::Save::Position *position = 0,
    bool triggered = false,
    bool active = false,
    int32_t status = 0,
    bool gravity_status = false,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    bool poisoned = false,
    int32_t ai_bits = 0,
    int32_t swap_mesh_flags = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_swap_mesh_flags(swap_mesh_flags);
  builder_.add_ai_bits(ai_bits);
  builder_.add_status(status);
  builder_.add_position(position);
  builder_.add_item_flags(item_flags);
  builder_.add_fired_weapon(fired_weapon);
  builder_.add_after_death(after_death);
  builder_.add_carried_item(carried_item);
  builder_.add_trigger_flags(trigger_flags);
  builder_.add_flags(flags);
  builder_.add_timer(timer);
  builder_.add_box_number(box_number);
  builder_.add_hit_points(hit_points);
  builder_.add_fall_speed(fall_speed);
  builder_.add_speed(speed);
  builder_.add_room_number(room_number);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_required_anim_state(required_anim_state);
  builder_.add_goal_anim_state(goal_anim_state);
  builder_.add_current_anim_state(current_anim_state);
  builder_.add_object_id(object_id);
  builder_.add_mesh_bits(mesh_bits);
  builder_.add_touch_bits(touch_bits);
  builder_.add_floor(floor);
  builder_.add_data_type(data_type);
  builder_.add_poisoned(poisoned);
  builder_.add_looked_at(looked_at);
  builder_.add_collidable(collidable);
  builder_.add_hit_stauts(hit_stauts);
  builder_.add_gravity_status(gravity_status);
  builder_.add_active(active);
  builder_.add_triggered(triggered);
  return builder_.Finish();
}

struct Item::Traits {
  using type = Item;
  static auto constexpr Create = CreateItem;
};

inline flatbuffers::Offset<Item> CreateItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    int32_t touch_bits = 0,
    int32_t mesh_bits = 0,
    int32_t object_id = 0,
    int32_t current_anim_state = 0,
    int32_t goal_anim_state = 0,
    int32_t required_anim_state = 0,
    int32_t anim_number = 0,
    int32_t frame_number = 0,
    int32_t room_number = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t hit_points = 0,
    int32_t box_number = 0,
    int32_t timer = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    int32_t carried_item = 0,
    int32_t after_death = 0,
    int32_t fired_weapon = 0,
    const std::vector<int32_t> *item_flags = nullptr,
    const TEN::Save::Position *position = 0,
    bool triggered = false,
    bool active = false,
    int32_t status = 0,
    bool gravity_status = false,
    bool hit_stauts = false,
    bool collidable = false,
    bool looked_at = false,
    bool poisoned = false,
    int32_t ai_bits = 0,
    int32_t swap_mesh_flags = 0,
    TEN::Save::ItemData data_type = TEN::Save::ItemData::NONE,
    flatbuffers::Offset<void> data = 0) {
  auto item_flags__ = item_flags ? _fbb.CreateVector<int32_t>(*item_flags) : 0;
  return TEN::Save::CreateItem(
      _fbb,
      floor,
      touch_bits,
      mesh_bits,
      object_id,
      current_anim_state,
      goal_anim_state,
      required_anim_state,
      anim_number,
      frame_number,
      room_number,
      speed,
      fall_speed,
      hit_points,
      box_number,
      timer,
      flags,
      trigger_flags,
      carried_item,
      after_death,
      fired_weapon,
      item_flags__,
      position,
      triggered,
      active,
      status,
      gravity_status,
      hit_stauts,
      collidable,
      looked_at,
      poisoned,
      ai_bits,
      swap_mesh_flags,
      data_type,
      data);
}

flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WeaponInfoT : public flatbuffers::NativeTable {
  typedef WeaponInfo TableType;
  uint32_t object_number = 0;
  uint32_t anim_number = 0;
  uint32_t frame_number = 0;
  uint32_t current_anim_state = 0;
  uint32_t goal_anim_state = 0;
};

struct WeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponInfoT NativeTableType;
  typedef WeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NUMBER = 4,
    VT_ANIM_NUMBER = 6,
    VT_FRAME_NUMBER = 8,
    VT_CURRENT_ANIM_STATE = 10,
    VT_GOAL_ANIM_STATE = 12
  };
  uint32_t object_number() const {
    return GetField<uint32_t>(VT_OBJECT_NUMBER, 0);
  }
  uint32_t anim_number() const {
    return GetField<uint32_t>(VT_ANIM_NUMBER, 0);
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  uint32_t current_anim_state() const {
    return GetField<uint32_t>(VT_CURRENT_ANIM_STATE, 0);
  }
  uint32_t goal_anim_state() const {
    return GetField<uint32_t>(VT_GOAL_ANIM_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT_ANIM_STATE) &&
           VerifyField<uint32_t>(verifier, VT_GOAL_ANIM_STATE) &&
           verifier.EndTable();
  }
  WeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WeaponInfoBuilder {
  typedef WeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_number(uint32_t object_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_anim_number(uint32_t anim_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_current_anim_state(uint32_t current_anim_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_CURRENT_ANIM_STATE, current_anim_state, 0);
  }
  void add_goal_anim_state(uint32_t goal_anim_state) {
    fbb_.AddElement<uint32_t>(WeaponInfo::VT_GOAL_ANIM_STATE, goal_anim_state, 0);
  }
  explicit WeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_number = 0,
    uint32_t anim_number = 0,
    uint32_t frame_number = 0,
    uint32_t current_anim_state = 0,
    uint32_t goal_anim_state = 0) {
  WeaponInfoBuilder builder_(_fbb);
  builder_.add_goal_anim_state(goal_anim_state);
  builder_.add_current_anim_state(current_anim_state);
  builder_.add_frame_number(frame_number);
  builder_.add_anim_number(anim_number);
  builder_.add_object_number(object_number);
  return builder_.Finish();
}

struct WeaponInfo::Traits {
  using type = WeaponInfo;
  static auto constexpr Create = CreateWeaponInfo;
};

flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HolsterInfoT : public flatbuffers::NativeTable {
  typedef HolsterInfo TableType;
  int32_t left_holster = 0;
  int32_t right_holster = 0;
  int32_t back_holster = 0;
};

struct HolsterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HolsterInfoT NativeTableType;
  typedef HolsterInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_HOLSTER = 4,
    VT_RIGHT_HOLSTER = 6,
    VT_BACK_HOLSTER = 8
  };
  int32_t left_holster() const {
    return GetField<int32_t>(VT_LEFT_HOLSTER, 0);
  }
  int32_t right_holster() const {
    return GetField<int32_t>(VT_RIGHT_HOLSTER, 0);
  }
  int32_t back_holster() const {
    return GetField<int32_t>(VT_BACK_HOLSTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEFT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_HOLSTER) &&
           VerifyField<int32_t>(verifier, VT_BACK_HOLSTER) &&
           verifier.EndTable();
  }
  HolsterInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HolsterInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HolsterInfoBuilder {
  typedef HolsterInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_holster(int32_t left_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_LEFT_HOLSTER, left_holster, 0);
  }
  void add_right_holster(int32_t right_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_RIGHT_HOLSTER, right_holster, 0);
  }
  void add_back_holster(int32_t back_holster) {
    fbb_.AddElement<int32_t>(HolsterInfo::VT_BACK_HOLSTER, back_holster, 0);
  }
  explicit HolsterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HolsterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HolsterInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t left_holster = 0,
    int32_t right_holster = 0,
    int32_t back_holster = 0) {
  HolsterInfoBuilder builder_(_fbb);
  builder_.add_back_holster(back_holster);
  builder_.add_right_holster(right_holster);
  builder_.add_left_holster(left_holster);
  return builder_.Finish();
}

struct HolsterInfo::Traits {
  using type = HolsterInfo;
  static auto constexpr Create = CreateHolsterInfo;
};

flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AmmoInfoT : public flatbuffers::NativeTable {
  typedef AmmoInfo TableType;
  int32_t count = 0;
  bool is_infinite = false;
};

struct AmmoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AmmoInfoT NativeTableType;
  typedef AmmoInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_IS_INFINITE = 6
  };
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool is_infinite() const {
    return GetField<uint8_t>(VT_IS_INFINITE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_IS_INFINITE) &&
           verifier.EndTable();
  }
  AmmoInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AmmoInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AmmoInfoBuilder {
  typedef AmmoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(AmmoInfo::VT_COUNT, count, 0);
  }
  void add_is_infinite(bool is_infinite) {
    fbb_.AddElement<uint8_t>(AmmoInfo::VT_IS_INFINITE, static_cast<uint8_t>(is_infinite), 0);
  }
  explicit AmmoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AmmoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AmmoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count = 0,
    bool is_infinite = false) {
  AmmoInfoBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_is_infinite(is_infinite);
  return builder_.Finish();
}

struct AmmoInfo::Traits {
  using type = AmmoInfo;
  static auto constexpr Create = CreateAmmoInfo;
};

flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CarriedWeaponInfoT : public flatbuffers::NativeTable {
  typedef CarriedWeaponInfo TableType;
  bool present = false;
  std::vector<std::unique_ptr<TEN::Save::AmmoInfoT>> ammo{};
  int32_t selected_ammo = 0;
  bool has_lasersight = false;
  bool has_silencer = false;
};

struct CarriedWeaponInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CarriedWeaponInfoT NativeTableType;
  typedef CarriedWeaponInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESENT = 4,
    VT_AMMO = 6,
    VT_SELECTED_AMMO = 8,
    VT_HAS_LASERSIGHT = 10,
    VT_HAS_SILENCER = 12
  };
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *>(VT_AMMO);
  }
  int32_t selected_ammo() const {
    return GetField<int32_t>(VT_SELECTED_AMMO, 0);
  }
  bool has_lasersight() const {
    return GetField<uint8_t>(VT_HAS_LASERSIGHT, 0) != 0;
  }
  bool has_silencer() const {
    return GetField<uint8_t>(VT_HAS_SILENCER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT) &&
           VerifyOffset(verifier, VT_AMMO) &&
           verifier.VerifyVector(ammo()) &&
           verifier.VerifyVectorOfTables(ammo()) &&
           VerifyField<int32_t>(verifier, VT_SELECTED_AMMO) &&
           VerifyField<uint8_t>(verifier, VT_HAS_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SILENCER) &&
           verifier.EndTable();
  }
  CarriedWeaponInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CarriedWeaponInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CarriedWeaponInfoBuilder {
  typedef CarriedWeaponInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  void add_ammo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo) {
    fbb_.AddOffset(CarriedWeaponInfo::VT_AMMO, ammo);
  }
  void add_selected_ammo(int32_t selected_ammo) {
    fbb_.AddElement<int32_t>(CarriedWeaponInfo::VT_SELECTED_AMMO, selected_ammo, 0);
  }
  void add_has_lasersight(bool has_lasersight) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_LASERSIGHT, static_cast<uint8_t>(has_lasersight), 0);
  }
  void add_has_silencer(bool has_silencer) {
    fbb_.AddElement<uint8_t>(CarriedWeaponInfo::VT_HAS_SILENCER, static_cast<uint8_t>(has_silencer), 0);
  }
  explicit CarriedWeaponInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CarriedWeaponInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CarriedWeaponInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::AmmoInfo>>> ammo = 0,
    int32_t selected_ammo = 0,
    bool has_lasersight = false,
    bool has_silencer = false) {
  CarriedWeaponInfoBuilder builder_(_fbb);
  builder_.add_selected_ammo(selected_ammo);
  builder_.add_ammo(ammo);
  builder_.add_has_silencer(has_silencer);
  builder_.add_has_lasersight(has_lasersight);
  builder_.add_present(present);
  return builder_.Finish();
}

struct CarriedWeaponInfo::Traits {
  using type = CarriedWeaponInfo;
  static auto constexpr Create = CreateCarriedWeaponInfo;
};

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool present = false,
    const std::vector<flatbuffers::Offset<TEN::Save::AmmoInfo>> *ammo = nullptr,
    int32_t selected_ammo = 0,
    bool has_lasersight = false,
    bool has_silencer = false) {
  auto ammo__ = ammo ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>>(*ammo) : 0;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      present,
      ammo__,
      selected_ammo,
      has_lasersight,
      has_silencer);
}

flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraArmInfoT : public flatbuffers::NativeTable {
  typedef LaraArmInfo TableType;
  int32_t frame_base = 0;
  int32_t frame_number = 0;
  int32_t anim_number = 0;
  bool lock = false;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t flash_gun = 0;
};

struct LaraArmInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraArmInfoT NativeTableType;
  typedef LaraArmInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_BASE = 4,
    VT_FRAME_NUMBER = 6,
    VT_ANIM_NUMBER = 8,
    VT_LOCK = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_FLASH_GUN = 18
  };
  int32_t frame_base() const {
    return GetField<int32_t>(VT_FRAME_BASE, 0);
  }
  int32_t frame_number() const {
    return GetField<int32_t>(VT_FRAME_NUMBER, 0);
  }
  int32_t anim_number() const {
    return GetField<int32_t>(VT_ANIM_NUMBER, 0);
  }
  bool lock() const {
    return GetField<uint8_t>(VT_LOCK, 0) != 0;
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t flash_gun() const {
    return GetField<int32_t>(VT_FLASH_GUN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME_BASE) &&
           VerifyField<int32_t>(verifier, VT_FRAME_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ANIM_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_LOCK) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_FLASH_GUN) &&
           verifier.EndTable();
  }
  LaraArmInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraArmInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraArmInfoBuilder {
  typedef LaraArmInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame_base(int32_t frame_base) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_FRAME_BASE, frame_base, 0);
  }
  void add_frame_number(int32_t frame_number) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_anim_number(int32_t anim_number) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_ANIM_NUMBER, anim_number, 0);
  }
  void add_lock(bool lock) {
    fbb_.AddElement<uint8_t>(LaraArmInfo::VT_LOCK, static_cast<uint8_t>(lock), 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_flash_gun(int32_t flash_gun) {
    fbb_.AddElement<int32_t>(LaraArmInfo::VT_FLASH_GUN, flash_gun, 0);
  }
  explicit LaraArmInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraArmInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraArmInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraArmInfo> CreateLaraArmInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame_base = 0,
    int32_t frame_number = 0,
    int32_t anim_number = 0,
    bool lock = false,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t flash_gun = 0) {
  LaraArmInfoBuilder builder_(_fbb);
  builder_.add_flash_gun(flash_gun);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_anim_number(anim_number);
  builder_.add_frame_number(frame_number);
  builder_.add_frame_base(frame_base);
  builder_.add_lock(lock);
  return builder_.Finish();
}

struct LaraArmInfo::Traits {
  using type = LaraArmInfo;
  static auto constexpr Create = CreateLaraArmInfo;
};

flatbuffers::Offset<LaraArmInfo> CreateLaraArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraTightropeInfoT : public flatbuffers::NativeTable {
  typedef LaraTightropeInfo TableType;
  float balance = 0.0f;
  int32_t time_on_tightrope = 0;
  bool can_go_off = false;
  int32_t tightrope_item = 0;
};

struct LaraTightropeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraTightropeInfoT NativeTableType;
  typedef LaraTightropeInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BALANCE = 4,
    VT_TIME_ON_TIGHTROPE = 6,
    VT_CAN_GO_OFF = 8,
    VT_TIGHTROPE_ITEM = 10
  };
  float balance() const {
    return GetField<float>(VT_BALANCE, 0.0f);
  }
  int32_t time_on_tightrope() const {
    return GetField<int32_t>(VT_TIME_ON_TIGHTROPE, 0);
  }
  bool can_go_off() const {
    return GetField<uint8_t>(VT_CAN_GO_OFF, 0) != 0;
  }
  int32_t tightrope_item() const {
    return GetField<int32_t>(VT_TIGHTROPE_ITEM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BALANCE) &&
           VerifyField<int32_t>(verifier, VT_TIME_ON_TIGHTROPE) &&
           VerifyField<uint8_t>(verifier, VT_CAN_GO_OFF) &&
           VerifyField<int32_t>(verifier, VT_TIGHTROPE_ITEM) &&
           verifier.EndTable();
  }
  LaraTightropeInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraTightropeInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraTightropeInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraTightropeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraTightropeInfoBuilder {
  typedef LaraTightropeInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_balance(float balance) {
    fbb_.AddElement<float>(LaraTightropeInfo::VT_BALANCE, balance, 0.0f);
  }
  void add_time_on_tightrope(int32_t time_on_tightrope) {
    fbb_.AddElement<int32_t>(LaraTightropeInfo::VT_TIME_ON_TIGHTROPE, time_on_tightrope, 0);
  }
  void add_can_go_off(bool can_go_off) {
    fbb_.AddElement<uint8_t>(LaraTightropeInfo::VT_CAN_GO_OFF, static_cast<uint8_t>(can_go_off), 0);
  }
  void add_tightrope_item(int32_t tightrope_item) {
    fbb_.AddElement<int32_t>(LaraTightropeInfo::VT_TIGHTROPE_ITEM, tightrope_item, 0);
  }
  explicit LaraTightropeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraTightropeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraTightropeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraTightropeInfo> CreateLaraTightropeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float balance = 0.0f,
    int32_t time_on_tightrope = 0,
    bool can_go_off = false,
    int32_t tightrope_item = 0) {
  LaraTightropeInfoBuilder builder_(_fbb);
  builder_.add_tightrope_item(tightrope_item);
  builder_.add_time_on_tightrope(time_on_tightrope);
  builder_.add_balance(balance);
  builder_.add_can_go_off(can_go_off);
  return builder_.Finish();
}

struct LaraTightropeInfo::Traits {
  using type = LaraTightropeInfo;
  static auto constexpr Create = CreateLaraTightropeInfo;
};

flatbuffers::Offset<LaraTightropeInfo> CreateLaraTightropeInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraTightropeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraT : public flatbuffers::NativeTable {
  typedef Lara TableType;
  int32_t item_number = 0;
  int32_t gun_status = 0;
  int32_t gun_type = 0;
  int32_t request_gun_type = 0;
  int32_t last_gun_type = 0;
  int32_t hit_points = 0;
  int32_t speed = 0;
  int32_t fall_speed = 0;
  int32_t calc_fall_speed = 0;
  int32_t water_status = 0;
  int32_t climb_status = 0;
  int32_t pose_count = 0;
  int32_t jump_count = 0;
  bool jump_queued = false;
  int32_t hit_frame = 0;
  int32_t hit_direction = 0;
  int32_t sprint_timer = 0;
  int32_t air = 0;
  int32_t dive_count = 0;
  int32_t death_count = 0;
  int32_t current_active = 0;
  int32_t current_x_vel = 0;
  int32_t current_y_vel = 0;
  int32_t current_z_vel = 0;
  int32_t spaz_effect_count = 0;
  int32_t flare_age = 0;
  int32_t burn_count = 0;
  int32_t weapon_item = 0;
  std::unique_ptr<TEN::Save::HolsterInfoT> holster_info{};
  int32_t flare_frame = 0;
  int32_t poisoned = 0;
  std::vector<bool> wet{};
  int32_t flare_control_left = 0;
  bool look = false;
  bool burn = false;
  bool keep_crouched = false;
  bool is_moving = false;
  bool can_monkey_swing = false;
  int32_t burn_blue = 0;
  bool burn_smoke = false;
  bool is_ducked = false;
  bool has_fired = false;
  bool busy = false;
  bool old_busy = false;
  bool uncontrollable = false;
  bool lit_torch = false;
  bool is_climbing = false;
  bool fired = false;
  int32_t water_surface_dist = 0;
  std::unique_ptr<TEN::Save::Vector3> last_position{};
  std::unique_ptr<TEN::Save::Vector3> next_corner_position{};
  std::unique_ptr<TEN::Save::Vector3> next_corner_rotation{};
  std::vector<int32_t> mesh_ptrs{};
  std::vector<int32_t> target_angles{};
  int32_t turn_rate = 0;
  int32_t move_angle = 0;
  int32_t head_x_rot = 0;
  int32_t head_y_rot = 0;
  int32_t head_z_rot = 0;
  int32_t torso_x_rot = 0;
  int32_t torso_y_rot = 0;
  int32_t torso_z_rot = 0;
  std::unique_ptr<TEN::Save::LaraArmInfoT> left_arm{};
  std::unique_ptr<TEN::Save::LaraArmInfoT> right_arm{};
  int32_t rope_segment = 0;
  int32_t rope_direction = 0;
  int32_t rope_arc_front = 0;
  int32_t rope_arc_back = 0;
  int32_t rope_last_x = 0;
  int32_t rope_max_x_forward = 0;
  int32_t rope_max_x_backward = 0;
  int32_t rope_dframe = 0;
  int32_t rope_frame = 0;
  int32_t rope_framerate = 0;
  int32_t rope_y = 0;
  int32_t rope_ptr = 0;
  int32_t interacted_item = 0;
  int32_t rope_offset = 0;
  int32_t rope_down_vel = 0;
  int32_t rope_flag = 0;
  int32_t rope_count = 0;
  int32_t move_count = 0;
  int32_t location = 0;
  int32_t highest_location = 0;
  int32_t location_pad = 0;
  std::unique_ptr<TEN::Save::LaraTightropeInfoT> tightrope{};
  int32_t beetle_life = 0;
  int32_t has_beetle_things = 0;
  int32_t small_waterskin = 0;
  int32_t big_waterskin = 0;
  int32_t vehicle = 0;
  int32_t extra_anim = 0;
  bool mine_l = false;
  bool mine_r = false;
  std::vector<std::unique_ptr<TEN::Save::CarriedWeaponInfoT>> weapons{};
  std::vector<int32_t> puzzles{};
  std::vector<int32_t> keys{};
  std::vector<int32_t> pickups{};
  std::vector<int32_t> examines{};
  std::vector<int32_t> puzzles_combo{};
  std::vector<int32_t> keys_combo{};
  std::vector<int32_t> pickups_combo{};
  std::vector<int32_t> examines_combo{};
  int32_t secrets = 0;
  bool lasersight = false;
  bool crowbar = false;
  bool torch = false;
  bool silencer = false;
  bool binoculars = false;
  int32_t num_large_medipacks = 0;
  int32_t num_small_medipacks = 0;
  int32_t num_flares = 0;
  int32_t target_item_number = 0;
};

struct Lara FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraT NativeTableType;
  typedef LaraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_NUMBER = 4,
    VT_GUN_STATUS = 6,
    VT_GUN_TYPE = 8,
    VT_REQUEST_GUN_TYPE = 10,
    VT_LAST_GUN_TYPE = 12,
    VT_HIT_POINTS = 14,
    VT_SPEED = 16,
    VT_FALL_SPEED = 18,
    VT_CALC_FALL_SPEED = 20,
    VT_WATER_STATUS = 22,
    VT_CLIMB_STATUS = 24,
    VT_POSE_COUNT = 26,
    VT_JUMP_COUNT = 28,
    VT_JUMP_QUEUED = 30,
    VT_HIT_FRAME = 32,
    VT_HIT_DIRECTION = 34,
    VT_SPRINT_TIMER = 36,
    VT_AIR = 38,
    VT_DIVE_COUNT = 40,
    VT_DEATH_COUNT = 42,
    VT_CURRENT_ACTIVE = 44,
    VT_CURRENT_X_VEL = 46,
    VT_CURRENT_Y_VEL = 48,
    VT_CURRENT_Z_VEL = 50,
    VT_SPAZ_EFFECT_COUNT = 52,
    VT_FLARE_AGE = 54,
    VT_BURN_COUNT = 56,
    VT_WEAPON_ITEM = 58,
    VT_HOLSTER_INFO = 60,
    VT_FLARE_FRAME = 62,
    VT_POISONED = 64,
    VT_WET = 66,
    VT_FLARE_CONTROL_LEFT = 68,
    VT_LOOK = 70,
    VT_BURN = 72,
    VT_KEEP_CROUCHED = 74,
    VT_IS_MOVING = 76,
    VT_CAN_MONKEY_SWING = 78,
    VT_BURN_BLUE = 80,
    VT_BURN_SMOKE = 82,
    VT_IS_DUCKED = 84,
    VT_HAS_FIRED = 86,
    VT_BUSY = 88,
    VT_OLD_BUSY = 90,
    VT_UNCONTROLLABLE = 92,
    VT_LIT_TORCH = 94,
    VT_IS_CLIMBING = 96,
    VT_FIRED = 98,
    VT_WATER_SURFACE_DIST = 100,
    VT_LAST_POSITION = 102,
    VT_NEXT_CORNER_POSITION = 104,
    VT_NEXT_CORNER_ROTATION = 106,
    VT_MESH_PTRS = 108,
    VT_TARGET_ANGLES = 110,
    VT_TURN_RATE = 112,
    VT_MOVE_ANGLE = 114,
    VT_HEAD_X_ROT = 116,
    VT_HEAD_Y_ROT = 118,
    VT_HEAD_Z_ROT = 120,
    VT_TORSO_X_ROT = 122,
    VT_TORSO_Y_ROT = 124,
    VT_TORSO_Z_ROT = 126,
    VT_LEFT_ARM = 128,
    VT_RIGHT_ARM = 130,
    VT_ROPE_SEGMENT = 132,
    VT_ROPE_DIRECTION = 134,
    VT_ROPE_ARC_FRONT = 136,
    VT_ROPE_ARC_BACK = 138,
    VT_ROPE_LAST_X = 140,
    VT_ROPE_MAX_X_FORWARD = 142,
    VT_ROPE_MAX_X_BACKWARD = 144,
    VT_ROPE_DFRAME = 146,
    VT_ROPE_FRAME = 148,
    VT_ROPE_FRAMERATE = 150,
    VT_ROPE_Y = 152,
    VT_ROPE_PTR = 154,
    VT_INTERACTED_ITEM = 156,
    VT_ROPE_OFFSET = 158,
    VT_ROPE_DOWN_VEL = 160,
    VT_ROPE_FLAG = 162,
    VT_ROPE_COUNT = 164,
    VT_MOVE_COUNT = 166,
    VT_LOCATION = 168,
    VT_HIGHEST_LOCATION = 170,
    VT_LOCATION_PAD = 172,
    VT_TIGHTROPE = 174,
    VT_BEETLE_LIFE = 176,
    VT_HAS_BEETLE_THINGS = 178,
    VT_SMALL_WATERSKIN = 180,
    VT_BIG_WATERSKIN = 182,
    VT_VEHICLE = 184,
    VT_EXTRA_ANIM = 186,
    VT_MINE_L = 188,
    VT_MINE_R = 190,
    VT_WEAPONS = 192,
    VT_PUZZLES = 194,
    VT_KEYS = 196,
    VT_PICKUPS = 198,
    VT_EXAMINES = 200,
    VT_PUZZLES_COMBO = 202,
    VT_KEYS_COMBO = 204,
    VT_PICKUPS_COMBO = 206,
    VT_EXAMINES_COMBO = 208,
    VT_SECRETS = 210,
    VT_LASERSIGHT = 212,
    VT_CROWBAR = 214,
    VT_TORCH = 216,
    VT_SILENCER = 218,
    VT_BINOCULARS = 220,
    VT_NUM_LARGE_MEDIPACKS = 222,
    VT_NUM_SMALL_MEDIPACKS = 224,
    VT_NUM_FLARES = 226,
    VT_TARGET_ITEM_NUMBER = 228
  };
  int32_t item_number() const {
    return GetField<int32_t>(VT_ITEM_NUMBER, 0);
  }
  int32_t gun_status() const {
    return GetField<int32_t>(VT_GUN_STATUS, 0);
  }
  int32_t gun_type() const {
    return GetField<int32_t>(VT_GUN_TYPE, 0);
  }
  int32_t request_gun_type() const {
    return GetField<int32_t>(VT_REQUEST_GUN_TYPE, 0);
  }
  int32_t last_gun_type() const {
    return GetField<int32_t>(VT_LAST_GUN_TYPE, 0);
  }
  int32_t hit_points() const {
    return GetField<int32_t>(VT_HIT_POINTS, 0);
  }
  int32_t speed() const {
    return GetField<int32_t>(VT_SPEED, 0);
  }
  int32_t fall_speed() const {
    return GetField<int32_t>(VT_FALL_SPEED, 0);
  }
  int32_t calc_fall_speed() const {
    return GetField<int32_t>(VT_CALC_FALL_SPEED, 0);
  }
  int32_t water_status() const {
    return GetField<int32_t>(VT_WATER_STATUS, 0);
  }
  int32_t climb_status() const {
    return GetField<int32_t>(VT_CLIMB_STATUS, 0);
  }
  int32_t pose_count() const {
    return GetField<int32_t>(VT_POSE_COUNT, 0);
  }
  int32_t jump_count() const {
    return GetField<int32_t>(VT_JUMP_COUNT, 0);
  }
  bool jump_queued() const {
    return GetField<uint8_t>(VT_JUMP_QUEUED, 0) != 0;
  }
  int32_t hit_frame() const {
    return GetField<int32_t>(VT_HIT_FRAME, 0);
  }
  int32_t hit_direction() const {
    return GetField<int32_t>(VT_HIT_DIRECTION, 0);
  }
  int32_t sprint_timer() const {
    return GetField<int32_t>(VT_SPRINT_TIMER, 0);
  }
  int32_t air() const {
    return GetField<int32_t>(VT_AIR, 0);
  }
  int32_t dive_count() const {
    return GetField<int32_t>(VT_DIVE_COUNT, 0);
  }
  int32_t death_count() const {
    return GetField<int32_t>(VT_DEATH_COUNT, 0);
  }
  int32_t current_active() const {
    return GetField<int32_t>(VT_CURRENT_ACTIVE, 0);
  }
  int32_t current_x_vel() const {
    return GetField<int32_t>(VT_CURRENT_X_VEL, 0);
  }
  int32_t current_y_vel() const {
    return GetField<int32_t>(VT_CURRENT_Y_VEL, 0);
  }
  int32_t current_z_vel() const {
    return GetField<int32_t>(VT_CURRENT_Z_VEL, 0);
  }
  int32_t spaz_effect_count() const {
    return GetField<int32_t>(VT_SPAZ_EFFECT_COUNT, 0);
  }
  int32_t flare_age() const {
    return GetField<int32_t>(VT_FLARE_AGE, 0);
  }
  int32_t burn_count() const {
    return GetField<int32_t>(VT_BURN_COUNT, 0);
  }
  int32_t weapon_item() const {
    return GetField<int32_t>(VT_WEAPON_ITEM, 0);
  }
  const TEN::Save::HolsterInfo *holster_info() const {
    return GetPointer<const TEN::Save::HolsterInfo *>(VT_HOLSTER_INFO);
  }
  int32_t flare_frame() const {
    return GetField<int32_t>(VT_FLARE_FRAME, 0);
  }
  int32_t poisoned() const {
    return GetField<int32_t>(VT_POISONED, 0);
  }
  const flatbuffers::Vector<uint8_t> *wet() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WET);
  }
  int32_t flare_control_left() const {
    return GetField<int32_t>(VT_FLARE_CONTROL_LEFT, 0);
  }
  bool look() const {
    return GetField<uint8_t>(VT_LOOK, 0) != 0;
  }
  bool burn() const {
    return GetField<uint8_t>(VT_BURN, 0) != 0;
  }
  bool keep_crouched() const {
    return GetField<uint8_t>(VT_KEEP_CROUCHED, 0) != 0;
  }
  bool is_moving() const {
    return GetField<uint8_t>(VT_IS_MOVING, 0) != 0;
  }
  bool can_monkey_swing() const {
    return GetField<uint8_t>(VT_CAN_MONKEY_SWING, 0) != 0;
  }
  int32_t burn_blue() const {
    return GetField<int32_t>(VT_BURN_BLUE, 0);
  }
  bool burn_smoke() const {
    return GetField<uint8_t>(VT_BURN_SMOKE, 0) != 0;
  }
  bool is_ducked() const {
    return GetField<uint8_t>(VT_IS_DUCKED, 0) != 0;
  }
  bool has_fired() const {
    return GetField<uint8_t>(VT_HAS_FIRED, 0) != 0;
  }
  bool busy() const {
    return GetField<uint8_t>(VT_BUSY, 0) != 0;
  }
  bool old_busy() const {
    return GetField<uint8_t>(VT_OLD_BUSY, 0) != 0;
  }
  bool uncontrollable() const {
    return GetField<uint8_t>(VT_UNCONTROLLABLE, 0) != 0;
  }
  bool lit_torch() const {
    return GetField<uint8_t>(VT_LIT_TORCH, 0) != 0;
  }
  bool is_climbing() const {
    return GetField<uint8_t>(VT_IS_CLIMBING, 0) != 0;
  }
  bool fired() const {
    return GetField<uint8_t>(VT_FIRED, 0) != 0;
  }
  int32_t water_surface_dist() const {
    return GetField<int32_t>(VT_WATER_SURFACE_DIST, 0);
  }
  const TEN::Save::Vector3 *last_position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_LAST_POSITION);
  }
  const TEN::Save::Vector3 *next_corner_position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_NEXT_CORNER_POSITION);
  }
  const TEN::Save::Vector3 *next_corner_rotation() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_NEXT_CORNER_ROTATION);
  }
  const flatbuffers::Vector<int32_t> *mesh_ptrs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MESH_PTRS);
  }
  const flatbuffers::Vector<int32_t> *target_angles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TARGET_ANGLES);
  }
  int32_t turn_rate() const {
    return GetField<int32_t>(VT_TURN_RATE, 0);
  }
  int32_t move_angle() const {
    return GetField<int32_t>(VT_MOVE_ANGLE, 0);
  }
  int32_t head_x_rot() const {
    return GetField<int32_t>(VT_HEAD_X_ROT, 0);
  }
  int32_t head_y_rot() const {
    return GetField<int32_t>(VT_HEAD_Y_ROT, 0);
  }
  int32_t head_z_rot() const {
    return GetField<int32_t>(VT_HEAD_Z_ROT, 0);
  }
  int32_t torso_x_rot() const {
    return GetField<int32_t>(VT_TORSO_X_ROT, 0);
  }
  int32_t torso_y_rot() const {
    return GetField<int32_t>(VT_TORSO_Y_ROT, 0);
  }
  int32_t torso_z_rot() const {
    return GetField<int32_t>(VT_TORSO_Z_ROT, 0);
  }
  const TEN::Save::LaraArmInfo *left_arm() const {
    return GetPointer<const TEN::Save::LaraArmInfo *>(VT_LEFT_ARM);
  }
  const TEN::Save::LaraArmInfo *right_arm() const {
    return GetPointer<const TEN::Save::LaraArmInfo *>(VT_RIGHT_ARM);
  }
  int32_t rope_segment() const {
    return GetField<int32_t>(VT_ROPE_SEGMENT, 0);
  }
  int32_t rope_direction() const {
    return GetField<int32_t>(VT_ROPE_DIRECTION, 0);
  }
  int32_t rope_arc_front() const {
    return GetField<int32_t>(VT_ROPE_ARC_FRONT, 0);
  }
  int32_t rope_arc_back() const {
    return GetField<int32_t>(VT_ROPE_ARC_BACK, 0);
  }
  int32_t rope_last_x() const {
    return GetField<int32_t>(VT_ROPE_LAST_X, 0);
  }
  int32_t rope_max_x_forward() const {
    return GetField<int32_t>(VT_ROPE_MAX_X_FORWARD, 0);
  }
  int32_t rope_max_x_backward() const {
    return GetField<int32_t>(VT_ROPE_MAX_X_BACKWARD, 0);
  }
  int32_t rope_dframe() const {
    return GetField<int32_t>(VT_ROPE_DFRAME, 0);
  }
  int32_t rope_frame() const {
    return GetField<int32_t>(VT_ROPE_FRAME, 0);
  }
  int32_t rope_framerate() const {
    return GetField<int32_t>(VT_ROPE_FRAMERATE, 0);
  }
  int32_t rope_y() const {
    return GetField<int32_t>(VT_ROPE_Y, 0);
  }
  int32_t rope_ptr() const {
    return GetField<int32_t>(VT_ROPE_PTR, 0);
  }
  int32_t interacted_item() const {
    return GetField<int32_t>(VT_INTERACTED_ITEM, 0);
  }
  int32_t rope_offset() const {
    return GetField<int32_t>(VT_ROPE_OFFSET, 0);
  }
  int32_t rope_down_vel() const {
    return GetField<int32_t>(VT_ROPE_DOWN_VEL, 0);
  }
  int32_t rope_flag() const {
    return GetField<int32_t>(VT_ROPE_FLAG, 0);
  }
  int32_t rope_count() const {
    return GetField<int32_t>(VT_ROPE_COUNT, 0);
  }
  int32_t move_count() const {
    return GetField<int32_t>(VT_MOVE_COUNT, 0);
  }
  int32_t location() const {
    return GetField<int32_t>(VT_LOCATION, 0);
  }
  int32_t highest_location() const {
    return GetField<int32_t>(VT_HIGHEST_LOCATION, 0);
  }
  int32_t location_pad() const {
    return GetField<int32_t>(VT_LOCATION_PAD, 0);
  }
  const TEN::Save::LaraTightropeInfo *tightrope() const {
    return GetPointer<const TEN::Save::LaraTightropeInfo *>(VT_TIGHTROPE);
  }
  int32_t beetle_life() const {
    return GetField<int32_t>(VT_BEETLE_LIFE, 0);
  }
  int32_t has_beetle_things() const {
    return GetField<int32_t>(VT_HAS_BEETLE_THINGS, 0);
  }
  int32_t small_waterskin() const {
    return GetField<int32_t>(VT_SMALL_WATERSKIN, 0);
  }
  int32_t big_waterskin() const {
    return GetField<int32_t>(VT_BIG_WATERSKIN, 0);
  }
  int32_t vehicle() const {
    return GetField<int32_t>(VT_VEHICLE, 0);
  }
  int32_t extra_anim() const {
    return GetField<int32_t>(VT_EXTRA_ANIM, 0);
  }
  bool mine_l() const {
    return GetField<uint8_t>(VT_MINE_L, 0) != 0;
  }
  bool mine_r() const {
    return GetField<uint8_t>(VT_MINE_R, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *>(VT_WEAPONS);
  }
  const flatbuffers::Vector<int32_t> *puzzles() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES);
  }
  const flatbuffers::Vector<int32_t> *keys() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS);
  }
  const flatbuffers::Vector<int32_t> *pickups() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS);
  }
  const flatbuffers::Vector<int32_t> *examines() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES);
  }
  const flatbuffers::Vector<int32_t> *puzzles_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PUZZLES_COMBO);
  }
  const flatbuffers::Vector<int32_t> *keys_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KEYS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *pickups_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PICKUPS_COMBO);
  }
  const flatbuffers::Vector<int32_t> *examines_combo() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EXAMINES_COMBO);
  }
  int32_t secrets() const {
    return GetField<int32_t>(VT_SECRETS, 0);
  }
  bool lasersight() const {
    return GetField<uint8_t>(VT_LASERSIGHT, 0) != 0;
  }
  bool crowbar() const {
    return GetField<uint8_t>(VT_CROWBAR, 0) != 0;
  }
  bool torch() const {
    return GetField<uint8_t>(VT_TORCH, 0) != 0;
  }
  bool silencer() const {
    return GetField<uint8_t>(VT_SILENCER, 0) != 0;
  }
  bool binoculars() const {
    return GetField<uint8_t>(VT_BINOCULARS, 0) != 0;
  }
  int32_t num_large_medipacks() const {
    return GetField<int32_t>(VT_NUM_LARGE_MEDIPACKS, 0);
  }
  int32_t num_small_medipacks() const {
    return GetField<int32_t>(VT_NUM_SMALL_MEDIPACKS, 0);
  }
  int32_t num_flares() const {
    return GetField<int32_t>(VT_NUM_FLARES, 0);
  }
  int32_t target_item_number() const {
    return GetField<int32_t>(VT_TARGET_ITEM_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_GUN_STATUS) &&
           VerifyField<int32_t>(verifier, VT_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LAST_GUN_TYPE) &&
           VerifyField<int32_t>(verifier, VT_HIT_POINTS) &&
           VerifyField<int32_t>(verifier, VT_SPEED) &&
           VerifyField<int32_t>(verifier, VT_FALL_SPEED) &&
           VerifyField<int32_t>(verifier, VT_CALC_FALL_SPEED) &&
           VerifyField<int32_t>(verifier, VT_WATER_STATUS) &&
           VerifyField<int32_t>(verifier, VT_CLIMB_STATUS) &&
           VerifyField<int32_t>(verifier, VT_POSE_COUNT) &&
           VerifyField<int32_t>(verifier, VT_JUMP_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_JUMP_QUEUED) &&
           VerifyField<int32_t>(verifier, VT_HIT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_HIT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_SPRINT_TIMER) &&
           VerifyField<int32_t>(verifier, VT_AIR) &&
           VerifyField<int32_t>(verifier, VT_DIVE_COUNT) &&
           VerifyField<int32_t>(verifier, VT_DEATH_COUNT) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_X_VEL) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_Y_VEL) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_Z_VEL) &&
           VerifyField<int32_t>(verifier, VT_SPAZ_EFFECT_COUNT) &&
           VerifyField<int32_t>(verifier, VT_FLARE_AGE) &&
           VerifyField<int32_t>(verifier, VT_BURN_COUNT) &&
           VerifyField<int32_t>(verifier, VT_WEAPON_ITEM) &&
           VerifyOffset(verifier, VT_HOLSTER_INFO) &&
           verifier.VerifyTable(holster_info()) &&
           VerifyField<int32_t>(verifier, VT_FLARE_FRAME) &&
           VerifyField<int32_t>(verifier, VT_POISONED) &&
           VerifyOffset(verifier, VT_WET) &&
           verifier.VerifyVector(wet()) &&
           VerifyField<int32_t>(verifier, VT_FLARE_CONTROL_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_LOOK) &&
           VerifyField<uint8_t>(verifier, VT_BURN) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_CROUCHED) &&
           VerifyField<uint8_t>(verifier, VT_IS_MOVING) &&
           VerifyField<uint8_t>(verifier, VT_CAN_MONKEY_SWING) &&
           VerifyField<int32_t>(verifier, VT_BURN_BLUE) &&
           VerifyField<uint8_t>(verifier, VT_BURN_SMOKE) &&
           VerifyField<uint8_t>(verifier, VT_IS_DUCKED) &&
           VerifyField<uint8_t>(verifier, VT_HAS_FIRED) &&
           VerifyField<uint8_t>(verifier, VT_BUSY) &&
           VerifyField<uint8_t>(verifier, VT_OLD_BUSY) &&
           VerifyField<uint8_t>(verifier, VT_UNCONTROLLABLE) &&
           VerifyField<uint8_t>(verifier, VT_LIT_TORCH) &&
           VerifyField<uint8_t>(verifier, VT_IS_CLIMBING) &&
           VerifyField<uint8_t>(verifier, VT_FIRED) &&
           VerifyField<int32_t>(verifier, VT_WATER_SURFACE_DIST) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_LAST_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_NEXT_CORNER_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_NEXT_CORNER_ROTATION) &&
           VerifyOffset(verifier, VT_MESH_PTRS) &&
           verifier.VerifyVector(mesh_ptrs()) &&
           VerifyOffset(verifier, VT_TARGET_ANGLES) &&
           verifier.VerifyVector(target_angles()) &&
           VerifyField<int32_t>(verifier, VT_TURN_RATE) &&
           VerifyField<int32_t>(verifier, VT_MOVE_ANGLE) &&
           VerifyField<int32_t>(verifier, VT_HEAD_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_HEAD_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_HEAD_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_TORSO_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_TORSO_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_TORSO_Z_ROT) &&
           VerifyOffset(verifier, VT_LEFT_ARM) &&
           verifier.VerifyTable(left_arm()) &&
           VerifyOffset(verifier, VT_RIGHT_ARM) &&
           verifier.VerifyTable(right_arm()) &&
           VerifyField<int32_t>(verifier, VT_ROPE_SEGMENT) &&
           VerifyField<int32_t>(verifier, VT_ROPE_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_ROPE_ARC_FRONT) &&
           VerifyField<int32_t>(verifier, VT_ROPE_ARC_BACK) &&
           VerifyField<int32_t>(verifier, VT_ROPE_LAST_X) &&
           VerifyField<int32_t>(verifier, VT_ROPE_MAX_X_FORWARD) &&
           VerifyField<int32_t>(verifier, VT_ROPE_MAX_X_BACKWARD) &&
           VerifyField<int32_t>(verifier, VT_ROPE_DFRAME) &&
           VerifyField<int32_t>(verifier, VT_ROPE_FRAME) &&
           VerifyField<int32_t>(verifier, VT_ROPE_FRAMERATE) &&
           VerifyField<int32_t>(verifier, VT_ROPE_Y) &&
           VerifyField<int32_t>(verifier, VT_ROPE_PTR) &&
           VerifyField<int32_t>(verifier, VT_INTERACTED_ITEM) &&
           VerifyField<int32_t>(verifier, VT_ROPE_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_ROPE_DOWN_VEL) &&
           VerifyField<int32_t>(verifier, VT_ROPE_FLAG) &&
           VerifyField<int32_t>(verifier, VT_ROPE_COUNT) &&
           VerifyField<int32_t>(verifier, VT_MOVE_COUNT) &&
           VerifyField<int32_t>(verifier, VT_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_HIGHEST_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_LOCATION_PAD) &&
           VerifyOffset(verifier, VT_TIGHTROPE) &&
           verifier.VerifyTable(tightrope()) &&
           VerifyField<int32_t>(verifier, VT_BEETLE_LIFE) &&
           VerifyField<int32_t>(verifier, VT_HAS_BEETLE_THINGS) &&
           VerifyField<int32_t>(verifier, VT_SMALL_WATERSKIN) &&
           VerifyField<int32_t>(verifier, VT_BIG_WATERSKIN) &&
           VerifyField<int32_t>(verifier, VT_VEHICLE) &&
           VerifyField<int32_t>(verifier, VT_EXTRA_ANIM) &&
           VerifyField<uint8_t>(verifier, VT_MINE_L) &&
           VerifyField<uint8_t>(verifier, VT_MINE_R) &&
           VerifyOffset(verifier, VT_WEAPONS) &&
           verifier.VerifyVector(weapons()) &&
           verifier.VerifyVectorOfTables(weapons()) &&
           VerifyOffset(verifier, VT_PUZZLES) &&
           verifier.VerifyVector(puzzles()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_PICKUPS) &&
           verifier.VerifyVector(pickups()) &&
           VerifyOffset(verifier, VT_EXAMINES) &&
           verifier.VerifyVector(examines()) &&
           VerifyOffset(verifier, VT_PUZZLES_COMBO) &&
           verifier.VerifyVector(puzzles_combo()) &&
           VerifyOffset(verifier, VT_KEYS_COMBO) &&
           verifier.VerifyVector(keys_combo()) &&
           VerifyOffset(verifier, VT_PICKUPS_COMBO) &&
           verifier.VerifyVector(pickups_combo()) &&
           VerifyOffset(verifier, VT_EXAMINES_COMBO) &&
           verifier.VerifyVector(examines_combo()) &&
           VerifyField<int32_t>(verifier, VT_SECRETS) &&
           VerifyField<uint8_t>(verifier, VT_LASERSIGHT) &&
           VerifyField<uint8_t>(verifier, VT_CROWBAR) &&
           VerifyField<uint8_t>(verifier, VT_TORCH) &&
           VerifyField<uint8_t>(verifier, VT_SILENCER) &&
           VerifyField<uint8_t>(verifier, VT_BINOCULARS) &&
           VerifyField<int32_t>(verifier, VT_NUM_LARGE_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_NUM_SMALL_MEDIPACKS) &&
           VerifyField<int32_t>(verifier, VT_NUM_FLARES) &&
           VerifyField<int32_t>(verifier, VT_TARGET_ITEM_NUMBER) &&
           verifier.EndTable();
  }
  LaraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lara> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraBuilder {
  typedef Lara Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_number(int32_t item_number) {
    fbb_.AddElement<int32_t>(Lara::VT_ITEM_NUMBER, item_number, 0);
  }
  void add_gun_status(int32_t gun_status) {
    fbb_.AddElement<int32_t>(Lara::VT_GUN_STATUS, gun_status, 0);
  }
  void add_gun_type(int32_t gun_type) {
    fbb_.AddElement<int32_t>(Lara::VT_GUN_TYPE, gun_type, 0);
  }
  void add_request_gun_type(int32_t request_gun_type) {
    fbb_.AddElement<int32_t>(Lara::VT_REQUEST_GUN_TYPE, request_gun_type, 0);
  }
  void add_last_gun_type(int32_t last_gun_type) {
    fbb_.AddElement<int32_t>(Lara::VT_LAST_GUN_TYPE, last_gun_type, 0);
  }
  void add_hit_points(int32_t hit_points) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_POINTS, hit_points, 0);
  }
  void add_speed(int32_t speed) {
    fbb_.AddElement<int32_t>(Lara::VT_SPEED, speed, 0);
  }
  void add_fall_speed(int32_t fall_speed) {
    fbb_.AddElement<int32_t>(Lara::VT_FALL_SPEED, fall_speed, 0);
  }
  void add_calc_fall_speed(int32_t calc_fall_speed) {
    fbb_.AddElement<int32_t>(Lara::VT_CALC_FALL_SPEED, calc_fall_speed, 0);
  }
  void add_water_status(int32_t water_status) {
    fbb_.AddElement<int32_t>(Lara::VT_WATER_STATUS, water_status, 0);
  }
  void add_climb_status(int32_t climb_status) {
    fbb_.AddElement<int32_t>(Lara::VT_CLIMB_STATUS, climb_status, 0);
  }
  void add_pose_count(int32_t pose_count) {
    fbb_.AddElement<int32_t>(Lara::VT_POSE_COUNT, pose_count, 0);
  }
  void add_jump_count(int32_t jump_count) {
    fbb_.AddElement<int32_t>(Lara::VT_JUMP_COUNT, jump_count, 0);
  }
  void add_jump_queued(bool jump_queued) {
    fbb_.AddElement<uint8_t>(Lara::VT_JUMP_QUEUED, static_cast<uint8_t>(jump_queued), 0);
  }
  void add_hit_frame(int32_t hit_frame) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_FRAME, hit_frame, 0);
  }
  void add_hit_direction(int32_t hit_direction) {
    fbb_.AddElement<int32_t>(Lara::VT_HIT_DIRECTION, hit_direction, 0);
  }
  void add_sprint_timer(int32_t sprint_timer) {
    fbb_.AddElement<int32_t>(Lara::VT_SPRINT_TIMER, sprint_timer, 0);
  }
  void add_air(int32_t air) {
    fbb_.AddElement<int32_t>(Lara::VT_AIR, air, 0);
  }
  void add_dive_count(int32_t dive_count) {
    fbb_.AddElement<int32_t>(Lara::VT_DIVE_COUNT, dive_count, 0);
  }
  void add_death_count(int32_t death_count) {
    fbb_.AddElement<int32_t>(Lara::VT_DEATH_COUNT, death_count, 0);
  }
  void add_current_active(int32_t current_active) {
    fbb_.AddElement<int32_t>(Lara::VT_CURRENT_ACTIVE, current_active, 0);
  }
  void add_current_x_vel(int32_t current_x_vel) {
    fbb_.AddElement<int32_t>(Lara::VT_CURRENT_X_VEL, current_x_vel, 0);
  }
  void add_current_y_vel(int32_t current_y_vel) {
    fbb_.AddElement<int32_t>(Lara::VT_CURRENT_Y_VEL, current_y_vel, 0);
  }
  void add_current_z_vel(int32_t current_z_vel) {
    fbb_.AddElement<int32_t>(Lara::VT_CURRENT_Z_VEL, current_z_vel, 0);
  }
  void add_spaz_effect_count(int32_t spaz_effect_count) {
    fbb_.AddElement<int32_t>(Lara::VT_SPAZ_EFFECT_COUNT, spaz_effect_count, 0);
  }
  void add_flare_age(int32_t flare_age) {
    fbb_.AddElement<int32_t>(Lara::VT_FLARE_AGE, flare_age, 0);
  }
  void add_burn_count(int32_t burn_count) {
    fbb_.AddElement<int32_t>(Lara::VT_BURN_COUNT, burn_count, 0);
  }
  void add_weapon_item(int32_t weapon_item) {
    fbb_.AddElement<int32_t>(Lara::VT_WEAPON_ITEM, weapon_item, 0);
  }
  void add_holster_info(flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info) {
    fbb_.AddOffset(Lara::VT_HOLSTER_INFO, holster_info);
  }
  void add_flare_frame(int32_t flare_frame) {
    fbb_.AddElement<int32_t>(Lara::VT_FLARE_FRAME, flare_frame, 0);
  }
  void add_poisoned(int32_t poisoned) {
    fbb_.AddElement<int32_t>(Lara::VT_POISONED, poisoned, 0);
  }
  void add_wet(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> wet) {
    fbb_.AddOffset(Lara::VT_WET, wet);
  }
  void add_flare_control_left(int32_t flare_control_left) {
    fbb_.AddElement<int32_t>(Lara::VT_FLARE_CONTROL_LEFT, flare_control_left, 0);
  }
  void add_look(bool look) {
    fbb_.AddElement<uint8_t>(Lara::VT_LOOK, static_cast<uint8_t>(look), 0);
  }
  void add_burn(bool burn) {
    fbb_.AddElement<uint8_t>(Lara::VT_BURN, static_cast<uint8_t>(burn), 0);
  }
  void add_keep_crouched(bool keep_crouched) {
    fbb_.AddElement<uint8_t>(Lara::VT_KEEP_CROUCHED, static_cast<uint8_t>(keep_crouched), 0);
  }
  void add_is_moving(bool is_moving) {
    fbb_.AddElement<uint8_t>(Lara::VT_IS_MOVING, static_cast<uint8_t>(is_moving), 0);
  }
  void add_can_monkey_swing(bool can_monkey_swing) {
    fbb_.AddElement<uint8_t>(Lara::VT_CAN_MONKEY_SWING, static_cast<uint8_t>(can_monkey_swing), 0);
  }
  void add_burn_blue(int32_t burn_blue) {
    fbb_.AddElement<int32_t>(Lara::VT_BURN_BLUE, burn_blue, 0);
  }
  void add_burn_smoke(bool burn_smoke) {
    fbb_.AddElement<uint8_t>(Lara::VT_BURN_SMOKE, static_cast<uint8_t>(burn_smoke), 0);
  }
  void add_is_ducked(bool is_ducked) {
    fbb_.AddElement<uint8_t>(Lara::VT_IS_DUCKED, static_cast<uint8_t>(is_ducked), 0);
  }
  void add_has_fired(bool has_fired) {
    fbb_.AddElement<uint8_t>(Lara::VT_HAS_FIRED, static_cast<uint8_t>(has_fired), 0);
  }
  void add_busy(bool busy) {
    fbb_.AddElement<uint8_t>(Lara::VT_BUSY, static_cast<uint8_t>(busy), 0);
  }
  void add_old_busy(bool old_busy) {
    fbb_.AddElement<uint8_t>(Lara::VT_OLD_BUSY, static_cast<uint8_t>(old_busy), 0);
  }
  void add_uncontrollable(bool uncontrollable) {
    fbb_.AddElement<uint8_t>(Lara::VT_UNCONTROLLABLE, static_cast<uint8_t>(uncontrollable), 0);
  }
  void add_lit_torch(bool lit_torch) {
    fbb_.AddElement<uint8_t>(Lara::VT_LIT_TORCH, static_cast<uint8_t>(lit_torch), 0);
  }
  void add_is_climbing(bool is_climbing) {
    fbb_.AddElement<uint8_t>(Lara::VT_IS_CLIMBING, static_cast<uint8_t>(is_climbing), 0);
  }
  void add_fired(bool fired) {
    fbb_.AddElement<uint8_t>(Lara::VT_FIRED, static_cast<uint8_t>(fired), 0);
  }
  void add_water_surface_dist(int32_t water_surface_dist) {
    fbb_.AddElement<int32_t>(Lara::VT_WATER_SURFACE_DIST, water_surface_dist, 0);
  }
  void add_last_position(const TEN::Save::Vector3 *last_position) {
    fbb_.AddStruct(Lara::VT_LAST_POSITION, last_position);
  }
  void add_next_corner_position(const TEN::Save::Vector3 *next_corner_position) {
    fbb_.AddStruct(Lara::VT_NEXT_CORNER_POSITION, next_corner_position);
  }
  void add_next_corner_rotation(const TEN::Save::Vector3 *next_corner_rotation) {
    fbb_.AddStruct(Lara::VT_NEXT_CORNER_ROTATION, next_corner_rotation);
  }
  void add_mesh_ptrs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_ptrs) {
    fbb_.AddOffset(Lara::VT_MESH_PTRS, mesh_ptrs);
  }
  void add_target_angles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_angles) {
    fbb_.AddOffset(Lara::VT_TARGET_ANGLES, target_angles);
  }
  void add_turn_rate(int32_t turn_rate) {
    fbb_.AddElement<int32_t>(Lara::VT_TURN_RATE, turn_rate, 0);
  }
  void add_move_angle(int32_t move_angle) {
    fbb_.AddElement<int32_t>(Lara::VT_MOVE_ANGLE, move_angle, 0);
  }
  void add_head_x_rot(int32_t head_x_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_HEAD_X_ROT, head_x_rot, 0);
  }
  void add_head_y_rot(int32_t head_y_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_HEAD_Y_ROT, head_y_rot, 0);
  }
  void add_head_z_rot(int32_t head_z_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_HEAD_Z_ROT, head_z_rot, 0);
  }
  void add_torso_x_rot(int32_t torso_x_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_TORSO_X_ROT, torso_x_rot, 0);
  }
  void add_torso_y_rot(int32_t torso_y_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_TORSO_Y_ROT, torso_y_rot, 0);
  }
  void add_torso_z_rot(int32_t torso_z_rot) {
    fbb_.AddElement<int32_t>(Lara::VT_TORSO_Z_ROT, torso_z_rot, 0);
  }
  void add_left_arm(flatbuffers::Offset<TEN::Save::LaraArmInfo> left_arm) {
    fbb_.AddOffset(Lara::VT_LEFT_ARM, left_arm);
  }
  void add_right_arm(flatbuffers::Offset<TEN::Save::LaraArmInfo> right_arm) {
    fbb_.AddOffset(Lara::VT_RIGHT_ARM, right_arm);
  }
  void add_rope_segment(int32_t rope_segment) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_SEGMENT, rope_segment, 0);
  }
  void add_rope_direction(int32_t rope_direction) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_DIRECTION, rope_direction, 0);
  }
  void add_rope_arc_front(int32_t rope_arc_front) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_ARC_FRONT, rope_arc_front, 0);
  }
  void add_rope_arc_back(int32_t rope_arc_back) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_ARC_BACK, rope_arc_back, 0);
  }
  void add_rope_last_x(int32_t rope_last_x) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_LAST_X, rope_last_x, 0);
  }
  void add_rope_max_x_forward(int32_t rope_max_x_forward) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_MAX_X_FORWARD, rope_max_x_forward, 0);
  }
  void add_rope_max_x_backward(int32_t rope_max_x_backward) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_MAX_X_BACKWARD, rope_max_x_backward, 0);
  }
  void add_rope_dframe(int32_t rope_dframe) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_DFRAME, rope_dframe, 0);
  }
  void add_rope_frame(int32_t rope_frame) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_FRAME, rope_frame, 0);
  }
  void add_rope_framerate(int32_t rope_framerate) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_FRAMERATE, rope_framerate, 0);
  }
  void add_rope_y(int32_t rope_y) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_Y, rope_y, 0);
  }
  void add_rope_ptr(int32_t rope_ptr) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_PTR, rope_ptr, 0);
  }
  void add_interacted_item(int32_t interacted_item) {
    fbb_.AddElement<int32_t>(Lara::VT_INTERACTED_ITEM, interacted_item, 0);
  }
  void add_rope_offset(int32_t rope_offset) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_OFFSET, rope_offset, 0);
  }
  void add_rope_down_vel(int32_t rope_down_vel) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_DOWN_VEL, rope_down_vel, 0);
  }
  void add_rope_flag(int32_t rope_flag) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_FLAG, rope_flag, 0);
  }
  void add_rope_count(int32_t rope_count) {
    fbb_.AddElement<int32_t>(Lara::VT_ROPE_COUNT, rope_count, 0);
  }
  void add_move_count(int32_t move_count) {
    fbb_.AddElement<int32_t>(Lara::VT_MOVE_COUNT, move_count, 0);
  }
  void add_location(int32_t location) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION, location, 0);
  }
  void add_highest_location(int32_t highest_location) {
    fbb_.AddElement<int32_t>(Lara::VT_HIGHEST_LOCATION, highest_location, 0);
  }
  void add_location_pad(int32_t location_pad) {
    fbb_.AddElement<int32_t>(Lara::VT_LOCATION_PAD, location_pad, 0);
  }
  void add_tightrope(flatbuffers::Offset<TEN::Save::LaraTightropeInfo> tightrope) {
    fbb_.AddOffset(Lara::VT_TIGHTROPE, tightrope);
  }
  void add_beetle_life(int32_t beetle_life) {
    fbb_.AddElement<int32_t>(Lara::VT_BEETLE_LIFE, beetle_life, 0);
  }
  void add_has_beetle_things(int32_t has_beetle_things) {
    fbb_.AddElement<int32_t>(Lara::VT_HAS_BEETLE_THINGS, has_beetle_things, 0);
  }
  void add_small_waterskin(int32_t small_waterskin) {
    fbb_.AddElement<int32_t>(Lara::VT_SMALL_WATERSKIN, small_waterskin, 0);
  }
  void add_big_waterskin(int32_t big_waterskin) {
    fbb_.AddElement<int32_t>(Lara::VT_BIG_WATERSKIN, big_waterskin, 0);
  }
  void add_vehicle(int32_t vehicle) {
    fbb_.AddElement<int32_t>(Lara::VT_VEHICLE, vehicle, 0);
  }
  void add_extra_anim(int32_t extra_anim) {
    fbb_.AddElement<int32_t>(Lara::VT_EXTRA_ANIM, extra_anim, 0);
  }
  void add_mine_l(bool mine_l) {
    fbb_.AddElement<uint8_t>(Lara::VT_MINE_L, static_cast<uint8_t>(mine_l), 0);
  }
  void add_mine_r(bool mine_r) {
    fbb_.AddElement<uint8_t>(Lara::VT_MINE_R, static_cast<uint8_t>(mine_r), 0);
  }
  void add_weapons(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons) {
    fbb_.AddOffset(Lara::VT_WEAPONS, weapons);
  }
  void add_puzzles(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles) {
    fbb_.AddOffset(Lara::VT_PUZZLES, puzzles);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys) {
    fbb_.AddOffset(Lara::VT_KEYS, keys);
  }
  void add_pickups(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups) {
    fbb_.AddOffset(Lara::VT_PICKUPS, pickups);
  }
  void add_examines(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines) {
    fbb_.AddOffset(Lara::VT_EXAMINES, examines);
  }
  void add_puzzles_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo) {
    fbb_.AddOffset(Lara::VT_PUZZLES_COMBO, puzzles_combo);
  }
  void add_keys_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo) {
    fbb_.AddOffset(Lara::VT_KEYS_COMBO, keys_combo);
  }
  void add_pickups_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo) {
    fbb_.AddOffset(Lara::VT_PICKUPS_COMBO, pickups_combo);
  }
  void add_examines_combo(flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo) {
    fbb_.AddOffset(Lara::VT_EXAMINES_COMBO, examines_combo);
  }
  void add_secrets(int32_t secrets) {
    fbb_.AddElement<int32_t>(Lara::VT_SECRETS, secrets, 0);
  }
  void add_lasersight(bool lasersight) {
    fbb_.AddElement<uint8_t>(Lara::VT_LASERSIGHT, static_cast<uint8_t>(lasersight), 0);
  }
  void add_crowbar(bool crowbar) {
    fbb_.AddElement<uint8_t>(Lara::VT_CROWBAR, static_cast<uint8_t>(crowbar), 0);
  }
  void add_torch(bool torch) {
    fbb_.AddElement<uint8_t>(Lara::VT_TORCH, static_cast<uint8_t>(torch), 0);
  }
  void add_silencer(bool silencer) {
    fbb_.AddElement<uint8_t>(Lara::VT_SILENCER, static_cast<uint8_t>(silencer), 0);
  }
  void add_binoculars(bool binoculars) {
    fbb_.AddElement<uint8_t>(Lara::VT_BINOCULARS, static_cast<uint8_t>(binoculars), 0);
  }
  void add_num_large_medipacks(int32_t num_large_medipacks) {
    fbb_.AddElement<int32_t>(Lara::VT_NUM_LARGE_MEDIPACKS, num_large_medipacks, 0);
  }
  void add_num_small_medipacks(int32_t num_small_medipacks) {
    fbb_.AddElement<int32_t>(Lara::VT_NUM_SMALL_MEDIPACKS, num_small_medipacks, 0);
  }
  void add_num_flares(int32_t num_flares) {
    fbb_.AddElement<int32_t>(Lara::VT_NUM_FLARES, num_flares, 0);
  }
  void add_target_item_number(int32_t target_item_number) {
    fbb_.AddElement<int32_t>(Lara::VT_TARGET_ITEM_NUMBER, target_item_number, 0);
  }
  explicit LaraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lara> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lara>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lara> CreateLara(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_number = 0,
    int32_t gun_status = 0,
    int32_t gun_type = 0,
    int32_t request_gun_type = 0,
    int32_t last_gun_type = 0,
    int32_t hit_points = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t calc_fall_speed = 0,
    int32_t water_status = 0,
    int32_t climb_status = 0,
    int32_t pose_count = 0,
    int32_t jump_count = 0,
    bool jump_queued = false,
    int32_t hit_frame = 0,
    int32_t hit_direction = 0,
    int32_t sprint_timer = 0,
    int32_t air = 0,
    int32_t dive_count = 0,
    int32_t death_count = 0,
    int32_t current_active = 0,
    int32_t current_x_vel = 0,
    int32_t current_y_vel = 0,
    int32_t current_z_vel = 0,
    int32_t spaz_effect_count = 0,
    int32_t flare_age = 0,
    int32_t burn_count = 0,
    int32_t weapon_item = 0,
    flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info = 0,
    int32_t flare_frame = 0,
    int32_t poisoned = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> wet = 0,
    int32_t flare_control_left = 0,
    bool look = false,
    bool burn = false,
    bool keep_crouched = false,
    bool is_moving = false,
    bool can_monkey_swing = false,
    int32_t burn_blue = 0,
    bool burn_smoke = false,
    bool is_ducked = false,
    bool has_fired = false,
    bool busy = false,
    bool old_busy = false,
    bool uncontrollable = false,
    bool lit_torch = false,
    bool is_climbing = false,
    bool fired = false,
    int32_t water_surface_dist = 0,
    const TEN::Save::Vector3 *last_position = 0,
    const TEN::Save::Vector3 *next_corner_position = 0,
    const TEN::Save::Vector3 *next_corner_rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mesh_ptrs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_angles = 0,
    int32_t turn_rate = 0,
    int32_t move_angle = 0,
    int32_t head_x_rot = 0,
    int32_t head_y_rot = 0,
    int32_t head_z_rot = 0,
    int32_t torso_x_rot = 0,
    int32_t torso_y_rot = 0,
    int32_t torso_z_rot = 0,
    flatbuffers::Offset<TEN::Save::LaraArmInfo> left_arm = 0,
    flatbuffers::Offset<TEN::Save::LaraArmInfo> right_arm = 0,
    int32_t rope_segment = 0,
    int32_t rope_direction = 0,
    int32_t rope_arc_front = 0,
    int32_t rope_arc_back = 0,
    int32_t rope_last_x = 0,
    int32_t rope_max_x_forward = 0,
    int32_t rope_max_x_backward = 0,
    int32_t rope_dframe = 0,
    int32_t rope_frame = 0,
    int32_t rope_framerate = 0,
    int32_t rope_y = 0,
    int32_t rope_ptr = 0,
    int32_t interacted_item = 0,
    int32_t rope_offset = 0,
    int32_t rope_down_vel = 0,
    int32_t rope_flag = 0,
    int32_t rope_count = 0,
    int32_t move_count = 0,
    int32_t location = 0,
    int32_t highest_location = 0,
    int32_t location_pad = 0,
    flatbuffers::Offset<TEN::Save::LaraTightropeInfo> tightrope = 0,
    int32_t beetle_life = 0,
    int32_t has_beetle_things = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    int32_t vehicle = 0,
    int32_t extra_anim = 0,
    bool mine_l = false,
    bool mine_r = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>> weapons = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> puzzles_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> keys_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pickups_combo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> examines_combo = 0,
    int32_t secrets = 0,
    bool lasersight = false,
    bool crowbar = false,
    bool torch = false,
    bool silencer = false,
    bool binoculars = false,
    int32_t num_large_medipacks = 0,
    int32_t num_small_medipacks = 0,
    int32_t num_flares = 0,
    int32_t target_item_number = 0) {
  LaraBuilder builder_(_fbb);
  builder_.add_target_item_number(target_item_number);
  builder_.add_num_flares(num_flares);
  builder_.add_num_small_medipacks(num_small_medipacks);
  builder_.add_num_large_medipacks(num_large_medipacks);
  builder_.add_secrets(secrets);
  builder_.add_examines_combo(examines_combo);
  builder_.add_pickups_combo(pickups_combo);
  builder_.add_keys_combo(keys_combo);
  builder_.add_puzzles_combo(puzzles_combo);
  builder_.add_examines(examines);
  builder_.add_pickups(pickups);
  builder_.add_keys(keys);
  builder_.add_puzzles(puzzles);
  builder_.add_weapons(weapons);
  builder_.add_extra_anim(extra_anim);
  builder_.add_vehicle(vehicle);
  builder_.add_big_waterskin(big_waterskin);
  builder_.add_small_waterskin(small_waterskin);
  builder_.add_has_beetle_things(has_beetle_things);
  builder_.add_beetle_life(beetle_life);
  builder_.add_tightrope(tightrope);
  builder_.add_location_pad(location_pad);
  builder_.add_highest_location(highest_location);
  builder_.add_location(location);
  builder_.add_move_count(move_count);
  builder_.add_rope_count(rope_count);
  builder_.add_rope_flag(rope_flag);
  builder_.add_rope_down_vel(rope_down_vel);
  builder_.add_rope_offset(rope_offset);
  builder_.add_interacted_item(interacted_item);
  builder_.add_rope_ptr(rope_ptr);
  builder_.add_rope_y(rope_y);
  builder_.add_rope_framerate(rope_framerate);
  builder_.add_rope_frame(rope_frame);
  builder_.add_rope_dframe(rope_dframe);
  builder_.add_rope_max_x_backward(rope_max_x_backward);
  builder_.add_rope_max_x_forward(rope_max_x_forward);
  builder_.add_rope_last_x(rope_last_x);
  builder_.add_rope_arc_back(rope_arc_back);
  builder_.add_rope_arc_front(rope_arc_front);
  builder_.add_rope_direction(rope_direction);
  builder_.add_rope_segment(rope_segment);
  builder_.add_right_arm(right_arm);
  builder_.add_left_arm(left_arm);
  builder_.add_torso_z_rot(torso_z_rot);
  builder_.add_torso_y_rot(torso_y_rot);
  builder_.add_torso_x_rot(torso_x_rot);
  builder_.add_head_z_rot(head_z_rot);
  builder_.add_head_y_rot(head_y_rot);
  builder_.add_head_x_rot(head_x_rot);
  builder_.add_move_angle(move_angle);
  builder_.add_turn_rate(turn_rate);
  builder_.add_target_angles(target_angles);
  builder_.add_mesh_ptrs(mesh_ptrs);
  builder_.add_next_corner_rotation(next_corner_rotation);
  builder_.add_next_corner_position(next_corner_position);
  builder_.add_last_position(last_position);
  builder_.add_water_surface_dist(water_surface_dist);
  builder_.add_burn_blue(burn_blue);
  builder_.add_flare_control_left(flare_control_left);
  builder_.add_wet(wet);
  builder_.add_poisoned(poisoned);
  builder_.add_flare_frame(flare_frame);
  builder_.add_holster_info(holster_info);
  builder_.add_weapon_item(weapon_item);
  builder_.add_burn_count(burn_count);
  builder_.add_flare_age(flare_age);
  builder_.add_spaz_effect_count(spaz_effect_count);
  builder_.add_current_z_vel(current_z_vel);
  builder_.add_current_y_vel(current_y_vel);
  builder_.add_current_x_vel(current_x_vel);
  builder_.add_current_active(current_active);
  builder_.add_death_count(death_count);
  builder_.add_dive_count(dive_count);
  builder_.add_air(air);
  builder_.add_sprint_timer(sprint_timer);
  builder_.add_hit_direction(hit_direction);
  builder_.add_hit_frame(hit_frame);
  builder_.add_jump_count(jump_count);
  builder_.add_pose_count(pose_count);
  builder_.add_climb_status(climb_status);
  builder_.add_water_status(water_status);
  builder_.add_calc_fall_speed(calc_fall_speed);
  builder_.add_fall_speed(fall_speed);
  builder_.add_speed(speed);
  builder_.add_hit_points(hit_points);
  builder_.add_last_gun_type(last_gun_type);
  builder_.add_request_gun_type(request_gun_type);
  builder_.add_gun_type(gun_type);
  builder_.add_gun_status(gun_status);
  builder_.add_item_number(item_number);
  builder_.add_binoculars(binoculars);
  builder_.add_silencer(silencer);
  builder_.add_torch(torch);
  builder_.add_crowbar(crowbar);
  builder_.add_lasersight(lasersight);
  builder_.add_mine_r(mine_r);
  builder_.add_mine_l(mine_l);
  builder_.add_fired(fired);
  builder_.add_is_climbing(is_climbing);
  builder_.add_lit_torch(lit_torch);
  builder_.add_uncontrollable(uncontrollable);
  builder_.add_old_busy(old_busy);
  builder_.add_busy(busy);
  builder_.add_has_fired(has_fired);
  builder_.add_is_ducked(is_ducked);
  builder_.add_burn_smoke(burn_smoke);
  builder_.add_can_monkey_swing(can_monkey_swing);
  builder_.add_is_moving(is_moving);
  builder_.add_keep_crouched(keep_crouched);
  builder_.add_burn(burn);
  builder_.add_look(look);
  builder_.add_jump_queued(jump_queued);
  return builder_.Finish();
}

struct Lara::Traits {
  using type = Lara;
  static auto constexpr Create = CreateLara;
};

inline flatbuffers::Offset<Lara> CreateLaraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item_number = 0,
    int32_t gun_status = 0,
    int32_t gun_type = 0,
    int32_t request_gun_type = 0,
    int32_t last_gun_type = 0,
    int32_t hit_points = 0,
    int32_t speed = 0,
    int32_t fall_speed = 0,
    int32_t calc_fall_speed = 0,
    int32_t water_status = 0,
    int32_t climb_status = 0,
    int32_t pose_count = 0,
    int32_t jump_count = 0,
    bool jump_queued = false,
    int32_t hit_frame = 0,
    int32_t hit_direction = 0,
    int32_t sprint_timer = 0,
    int32_t air = 0,
    int32_t dive_count = 0,
    int32_t death_count = 0,
    int32_t current_active = 0,
    int32_t current_x_vel = 0,
    int32_t current_y_vel = 0,
    int32_t current_z_vel = 0,
    int32_t spaz_effect_count = 0,
    int32_t flare_age = 0,
    int32_t burn_count = 0,
    int32_t weapon_item = 0,
    flatbuffers::Offset<TEN::Save::HolsterInfo> holster_info = 0,
    int32_t flare_frame = 0,
    int32_t poisoned = 0,
    const std::vector<uint8_t> *wet = nullptr,
    int32_t flare_control_left = 0,
    bool look = false,
    bool burn = false,
    bool keep_crouched = false,
    bool is_moving = false,
    bool can_monkey_swing = false,
    int32_t burn_blue = 0,
    bool burn_smoke = false,
    bool is_ducked = false,
    bool has_fired = false,
    bool busy = false,
    bool old_busy = false,
    bool uncontrollable = false,
    bool lit_torch = false,
    bool is_climbing = false,
    bool fired = false,
    int32_t water_surface_dist = 0,
    const TEN::Save::Vector3 *last_position = 0,
    const TEN::Save::Vector3 *next_corner_position = 0,
    const TEN::Save::Vector3 *next_corner_rotation = 0,
    const std::vector<int32_t> *mesh_ptrs = nullptr,
    const std::vector<int32_t> *target_angles = nullptr,
    int32_t turn_rate = 0,
    int32_t move_angle = 0,
    int32_t head_x_rot = 0,
    int32_t head_y_rot = 0,
    int32_t head_z_rot = 0,
    int32_t torso_x_rot = 0,
    int32_t torso_y_rot = 0,
    int32_t torso_z_rot = 0,
    flatbuffers::Offset<TEN::Save::LaraArmInfo> left_arm = 0,
    flatbuffers::Offset<TEN::Save::LaraArmInfo> right_arm = 0,
    int32_t rope_segment = 0,
    int32_t rope_direction = 0,
    int32_t rope_arc_front = 0,
    int32_t rope_arc_back = 0,
    int32_t rope_last_x = 0,
    int32_t rope_max_x_forward = 0,
    int32_t rope_max_x_backward = 0,
    int32_t rope_dframe = 0,
    int32_t rope_frame = 0,
    int32_t rope_framerate = 0,
    int32_t rope_y = 0,
    int32_t rope_ptr = 0,
    int32_t interacted_item = 0,
    int32_t rope_offset = 0,
    int32_t rope_down_vel = 0,
    int32_t rope_flag = 0,
    int32_t rope_count = 0,
    int32_t move_count = 0,
    int32_t location = 0,
    int32_t highest_location = 0,
    int32_t location_pad = 0,
    flatbuffers::Offset<TEN::Save::LaraTightropeInfo> tightrope = 0,
    int32_t beetle_life = 0,
    int32_t has_beetle_things = 0,
    int32_t small_waterskin = 0,
    int32_t big_waterskin = 0,
    int32_t vehicle = 0,
    int32_t extra_anim = 0,
    bool mine_l = false,
    bool mine_r = false,
    const std::vector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> *weapons = nullptr,
    const std::vector<int32_t> *puzzles = nullptr,
    const std::vector<int32_t> *keys = nullptr,
    const std::vector<int32_t> *pickups = nullptr,
    const std::vector<int32_t> *examines = nullptr,
    const std::vector<int32_t> *puzzles_combo = nullptr,
    const std::vector<int32_t> *keys_combo = nullptr,
    const std::vector<int32_t> *pickups_combo = nullptr,
    const std::vector<int32_t> *examines_combo = nullptr,
    int32_t secrets = 0,
    bool lasersight = false,
    bool crowbar = false,
    bool torch = false,
    bool silencer = false,
    bool binoculars = false,
    int32_t num_large_medipacks = 0,
    int32_t num_small_medipacks = 0,
    int32_t num_flares = 0,
    int32_t target_item_number = 0) {
  auto wet__ = wet ? _fbb.CreateVector<uint8_t>(*wet) : 0;
  auto mesh_ptrs__ = mesh_ptrs ? _fbb.CreateVector<int32_t>(*mesh_ptrs) : 0;
  auto target_angles__ = target_angles ? _fbb.CreateVector<int32_t>(*target_angles) : 0;
  auto weapons__ = weapons ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>>(*weapons) : 0;
  auto puzzles__ = puzzles ? _fbb.CreateVector<int32_t>(*puzzles) : 0;
  auto keys__ = keys ? _fbb.CreateVector<int32_t>(*keys) : 0;
  auto pickups__ = pickups ? _fbb.CreateVector<int32_t>(*pickups) : 0;
  auto examines__ = examines ? _fbb.CreateVector<int32_t>(*examines) : 0;
  auto puzzles_combo__ = puzzles_combo ? _fbb.CreateVector<int32_t>(*puzzles_combo) : 0;
  auto keys_combo__ = keys_combo ? _fbb.CreateVector<int32_t>(*keys_combo) : 0;
  auto pickups_combo__ = pickups_combo ? _fbb.CreateVector<int32_t>(*pickups_combo) : 0;
  auto examines_combo__ = examines_combo ? _fbb.CreateVector<int32_t>(*examines_combo) : 0;
  return TEN::Save::CreateLara(
      _fbb,
      item_number,
      gun_status,
      gun_type,
      request_gun_type,
      last_gun_type,
      hit_points,
      speed,
      fall_speed,
      calc_fall_speed,
      water_status,
      climb_status,
      pose_count,
      jump_count,
      jump_queued,
      hit_frame,
      hit_direction,
      sprint_timer,
      air,
      dive_count,
      death_count,
      current_active,
      current_x_vel,
      current_y_vel,
      current_z_vel,
      spaz_effect_count,
      flare_age,
      burn_count,
      weapon_item,
      holster_info,
      flare_frame,
      poisoned,
      wet__,
      flare_control_left,
      look,
      burn,
      keep_crouched,
      is_moving,
      can_monkey_swing,
      burn_blue,
      burn_smoke,
      is_ducked,
      has_fired,
      busy,
      old_busy,
      uncontrollable,
      lit_torch,
      is_climbing,
      fired,
      water_surface_dist,
      last_position,
      next_corner_position,
      next_corner_rotation,
      mesh_ptrs__,
      target_angles__,
      turn_rate,
      move_angle,
      head_x_rot,
      head_y_rot,
      head_z_rot,
      torso_x_rot,
      torso_y_rot,
      torso_z_rot,
      left_arm,
      right_arm,
      rope_segment,
      rope_direction,
      rope_arc_front,
      rope_arc_back,
      rope_last_x,
      rope_max_x_forward,
      rope_max_x_backward,
      rope_dframe,
      rope_frame,
      rope_framerate,
      rope_y,
      rope_ptr,
      interacted_item,
      rope_offset,
      rope_down_vel,
      rope_flag,
      rope_count,
      move_count,
      location,
      highest_location,
      location_pad,
      tightrope,
      beetle_life,
      has_beetle_things,
      small_waterskin,
      big_waterskin,
      vehicle,
      extra_anim,
      mine_l,
      mine_r,
      weapons__,
      puzzles__,
      keys__,
      pickups__,
      examines__,
      puzzles_combo__,
      keys_combo__,
      pickups_combo__,
      examines_combo__,
      secrets,
      lasersight,
      crowbar,
      torch,
      silencer,
      binoculars,
      num_large_medipacks,
      num_small_medipacks,
      num_flares,
      target_item_number);
}

flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FixedCameraT : public flatbuffers::NativeTable {
  typedef FixedCamera TableType;
  int32_t flags = 0;
};

struct FixedCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixedCameraT NativeTableType;
  typedef FixedCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FixedCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FixedCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixedCameraBuilder {
  typedef FixedCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FixedCamera::VT_FLAGS, flags, 0);
  }
  explicit FixedCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FixedCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FixedCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FixedCamera::Traits {
  using type = FixedCamera;
  static auto constexpr Create = CreateFixedCamera;
};

flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlyByCameraT : public flatbuffers::NativeTable {
  typedef FlyByCamera TableType;
  int32_t flags = 0;
};

struct FlyByCamera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlyByCameraT NativeTableType;
  typedef FlyByCameraBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  FlyByCameraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlyByCamera> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlyByCameraBuilder {
  typedef FlyByCamera Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(FlyByCamera::VT_FLAGS, flags, 0);
  }
  explicit FlyByCameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlyByCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlyByCamera>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  FlyByCameraBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct FlyByCamera::Traits {
  using type = FlyByCamera;
  static auto constexpr Create = CreateFlyByCamera;
};

flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SinkT : public flatbuffers::NativeTable {
  typedef Sink TableType;
  int32_t flags = 0;
};

struct Sink FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinkT NativeTableType;
  typedef SinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sink> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SinkBuilder {
  typedef Sink Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Sink::VT_FLAGS, flags, 0);
  }
  explicit SinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sink>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sink> CreateSink(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flags = 0) {
  SinkBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct Sink::Traits {
  using type = Sink;
  static auto constexpr Create = CreateSink;
};

flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StaticMeshInfoT : public flatbuffers::NativeTable {
  typedef StaticMeshInfo TableType;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct StaticMeshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StaticMeshInfoT NativeTableType;
  typedef StaticMeshInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOM_NUMBER = 4,
    VT_FLAGS = 6
  };
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  StaticMeshInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StaticMeshInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StaticMeshInfoBuilder {
  typedef StaticMeshInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(StaticMeshInfo::VT_FLAGS, flags, 0);
  }
  explicit StaticMeshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StaticMeshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StaticMeshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t room_number = 0,
    int32_t flags = 0) {
  StaticMeshInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  return builder_.Finish();
}

struct StaticMeshInfo::Traits {
  using type = StaticMeshInfo;
  static auto constexpr Create = CreateStaticMeshInfo;
};

flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RatInfoT : public flatbuffers::NativeTable {
  typedef RatInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct RatInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RatInfoT NativeTableType;
  typedef RatInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  RatInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RatInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RatInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RatInfoBuilder {
  typedef RatInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(RatInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(RatInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(RatInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(RatInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(RatInfo::VT_FLAGS, flags, 0);
  }
  explicit RatInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RatInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RatInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RatInfo> CreateRatInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  RatInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct RatInfo::Traits {
  using type = RatInfo;
  static auto constexpr Create = CreateRatInfo;
};

flatbuffers::Offset<RatInfo> CreateRatInfo(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpiderInfoT : public flatbuffers::NativeTable {
  typedef SpiderInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct SpiderInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpiderInfoT NativeTableType;
  typedef SpiderInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  SpiderInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpiderInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpiderInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpiderInfoBuilder {
  typedef SpiderInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(SpiderInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(SpiderInfo::VT_FLAGS, flags, 0);
  }
  explicit SpiderInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpiderInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpiderInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  SpiderInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct SpiderInfo::Traits {
  using type = SpiderInfo;
  static auto constexpr Create = CreateSpiderInfo;
};

flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScarabInfoT : public flatbuffers::NativeTable {
  typedef ScarabInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t flags = 0;
};

struct ScarabInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScarabInfoT NativeTableType;
  typedef ScarabInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_FLAGS = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  ScarabInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScarabInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScarabInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScarabInfoBuilder {
  typedef ScarabInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(ScarabInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ScarabInfo::VT_FLAGS, flags, 0);
  }
  explicit ScarabInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScarabInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScarabInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScarabInfo> CreateScarabInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t flags = 0) {
  ScarabInfoBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct ScarabInfo::Traits {
  using type = ScarabInfo;
  static auto constexpr Create = CreateScarabInfo;
};

flatbuffers::Offset<ScarabInfo> CreateScarabInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatInfoT : public flatbuffers::NativeTable {
  typedef BatInfo TableType;
  bool on = false;
  int32_t x = 0;
  int32_t y = 0;
  int32_t z = 0;
  int32_t x_rot = 0;
  int32_t y_rot = 0;
  int32_t z_rot = 0;
  int32_t room_number = 0;
  int32_t counter = 0;
};

struct BatInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatInfoT NativeTableType;
  typedef BatInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_ROT = 12,
    VT_Y_ROT = 14,
    VT_Z_ROT = 16,
    VT_ROOM_NUMBER = 18,
    VT_COUNTER = 20
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t z() const {
    return GetField<int32_t>(VT_Z, 0);
  }
  int32_t x_rot() const {
    return GetField<int32_t>(VT_X_ROT, 0);
  }
  int32_t y_rot() const {
    return GetField<int32_t>(VT_Y_ROT, 0);
  }
  int32_t z_rot() const {
    return GetField<int32_t>(VT_Z_ROT, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t counter() const {
    return GetField<int32_t>(VT_COUNTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_Z) &&
           VerifyField<int32_t>(verifier, VT_X_ROT) &&
           VerifyField<int32_t>(verifier, VT_Y_ROT) &&
           VerifyField<int32_t>(verifier, VT_Z_ROT) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_COUNTER) &&
           verifier.EndTable();
  }
  BatInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatInfoBuilder {
  typedef BatInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(BatInfo::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(BatInfo::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Y, y, 0);
  }
  void add_z(int32_t z) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Z, z, 0);
  }
  void add_x_rot(int32_t x_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_X_ROT, x_rot, 0);
  }
  void add_y_rot(int32_t y_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Y_ROT, y_rot, 0);
  }
  void add_z_rot(int32_t z_rot) {
    fbb_.AddElement<int32_t>(BatInfo::VT_Z_ROT, z_rot, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(BatInfo::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_counter(int32_t counter) {
    fbb_.AddElement<int32_t>(BatInfo::VT_COUNTER, counter, 0);
  }
  explicit BatInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatInfo> CreateBatInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false,
    int32_t x = 0,
    int32_t y = 0,
    int32_t z = 0,
    int32_t x_rot = 0,
    int32_t y_rot = 0,
    int32_t z_rot = 0,
    int32_t room_number = 0,
    int32_t counter = 0) {
  BatInfoBuilder builder_(_fbb);
  builder_.add_counter(counter);
  builder_.add_room_number(room_number);
  builder_.add_z_rot(z_rot);
  builder_.add_y_rot(y_rot);
  builder_.add_x_rot(x_rot);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_on(on);
  return builder_.Finish();
}

struct BatInfo::Traits {
  using type = BatInfo;
  static auto constexpr Create = CreateBatInfo;
};

flatbuffers::Offset<BatInfo> CreateBatInfo(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RopeT : public flatbuffers::NativeTable {
  typedef Rope TableType;
  std::vector<TEN::Save::Vector3> segments{};
  std::vector<TEN::Save::Vector3> velocities{};
  std::vector<TEN::Save::Vector3> normalised_segments{};
  std::vector<TEN::Save::Vector3> mesh_segments{};
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::vector<TEN::Save::Vector3> coords{};
  int32_t segment_length = 0;
  int32_t active = 0;
  int32_t coiled = 0;
};

struct Rope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RopeT NativeTableType;
  typedef RopeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENTS = 4,
    VT_VELOCITIES = 6,
    VT_NORMALISED_SEGMENTS = 8,
    VT_MESH_SEGMENTS = 10,
    VT_POSITION = 12,
    VT_COORDS = 14,
    VT_SEGMENT_LENGTH = 16,
    VT_ACTIVE = 18,
    VT_COILED = 20
  };
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_SEGMENTS);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *velocities() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_VELOCITIES);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *normalised_segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_NORMALISED_SEGMENTS);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *mesh_segments() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_MESH_SEGMENTS);
  }
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const flatbuffers::Vector<const TEN::Save::Vector3 *> *coords() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::Vector3 *> *>(VT_COORDS);
  }
  int32_t segment_length() const {
    return GetField<int32_t>(VT_SEGMENT_LENGTH, 0);
  }
  int32_t active() const {
    return GetField<int32_t>(VT_ACTIVE, 0);
  }
  int32_t coiled() const {
    return GetField<int32_t>(VT_COILED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           VerifyOffset(verifier, VT_VELOCITIES) &&
           verifier.VerifyVector(velocities()) &&
           VerifyOffset(verifier, VT_NORMALISED_SEGMENTS) &&
           verifier.VerifyVector(normalised_segments()) &&
           VerifyOffset(verifier, VT_MESH_SEGMENTS) &&
           verifier.VerifyVector(mesh_segments()) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_COORDS) &&
           verifier.VerifyVector(coords()) &&
           VerifyField<int32_t>(verifier, VT_SEGMENT_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE) &&
           VerifyField<int32_t>(verifier, VT_COILED) &&
           verifier.EndTable();
  }
  RopeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rope> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RopeBuilder {
  typedef Rope Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> segments) {
    fbb_.AddOffset(Rope::VT_SEGMENTS, segments);
  }
  void add_velocities(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> velocities) {
    fbb_.AddOffset(Rope::VT_VELOCITIES, velocities);
  }
  void add_normalised_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> normalised_segments) {
    fbb_.AddOffset(Rope::VT_NORMALISED_SEGMENTS, normalised_segments);
  }
  void add_mesh_segments(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> mesh_segments) {
    fbb_.AddOffset(Rope::VT_MESH_SEGMENTS, mesh_segments);
  }
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Rope::VT_POSITION, position);
  }
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> coords) {
    fbb_.AddOffset(Rope::VT_COORDS, coords);
  }
  void add_segment_length(int32_t segment_length) {
    fbb_.AddElement<int32_t>(Rope::VT_SEGMENT_LENGTH, segment_length, 0);
  }
  void add_active(int32_t active) {
    fbb_.AddElement<int32_t>(Rope::VT_ACTIVE, active, 0);
  }
  void add_coiled(int32_t coiled) {
    fbb_.AddElement<int32_t>(Rope::VT_COILED, coiled, 0);
  }
  explicit RopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rope>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rope> CreateRope(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> segments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> velocities = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> normalised_segments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> mesh_segments = 0,
    const TEN::Save::Vector3 *position = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::Vector3 *>> coords = 0,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  RopeBuilder builder_(_fbb);
  builder_.add_coiled(coiled);
  builder_.add_active(active);
  builder_.add_segment_length(segment_length);
  builder_.add_coords(coords);
  builder_.add_position(position);
  builder_.add_mesh_segments(mesh_segments);
  builder_.add_normalised_segments(normalised_segments);
  builder_.add_velocities(velocities);
  builder_.add_segments(segments);
  return builder_.Finish();
}

struct Rope::Traits {
  using type = Rope;
  static auto constexpr Create = CreateRope;
};

inline flatbuffers::Offset<Rope> CreateRopeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<TEN::Save::Vector3> *segments = nullptr,
    const std::vector<TEN::Save::Vector3> *velocities = nullptr,
    const std::vector<TEN::Save::Vector3> *normalised_segments = nullptr,
    const std::vector<TEN::Save::Vector3> *mesh_segments = nullptr,
    const TEN::Save::Vector3 *position = 0,
    const std::vector<TEN::Save::Vector3> *coords = nullptr,
    int32_t segment_length = 0,
    int32_t active = 0,
    int32_t coiled = 0) {
  auto segments__ = segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*segments) : 0;
  auto velocities__ = velocities ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*velocities) : 0;
  auto normalised_segments__ = normalised_segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*normalised_segments) : 0;
  auto mesh_segments__ = mesh_segments ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*mesh_segments) : 0;
  auto coords__ = coords ? _fbb.CreateVectorOfStructs<TEN::Save::Vector3>(*coords) : 0;
  return TEN::Save::CreateRope(
      _fbb,
      segments__,
      velocities__,
      normalised_segments__,
      mesh_segments__,
      position,
      coords__,
      segment_length,
      active,
      coiled);
}

flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PendulumT : public flatbuffers::NativeTable {
  typedef Pendulum TableType;
  std::unique_ptr<TEN::Save::Vector3> position{};
  std::unique_ptr<TEN::Save::Vector3> velocity{};
  int32_t node = 0;
};

struct Pendulum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PendulumT NativeTableType;
  typedef PendulumBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6,
    VT_NODE = 8
  };
  const TEN::Save::Vector3 *position() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_POSITION);
  }
  const TEN::Save::Vector3 *velocity() const {
    return GetStruct<const TEN::Save::Vector3 *>(VT_VELOCITY);
  }
  int32_t node() const {
    return GetField<int32_t>(VT_NODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_POSITION) &&
           VerifyField<TEN::Save::Vector3>(verifier, VT_VELOCITY) &&
           VerifyField<int32_t>(verifier, VT_NODE) &&
           verifier.EndTable();
  }
  PendulumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pendulum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PendulumBuilder {
  typedef Pendulum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const TEN::Save::Vector3 *position) {
    fbb_.AddStruct(Pendulum::VT_POSITION, position);
  }
  void add_velocity(const TEN::Save::Vector3 *velocity) {
    fbb_.AddStruct(Pendulum::VT_VELOCITY, velocity);
  }
  void add_node(int32_t node) {
    fbb_.AddElement<int32_t>(Pendulum::VT_NODE, node, 0);
  }
  explicit PendulumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pendulum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pendulum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pendulum> CreatePendulum(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TEN::Save::Vector3 *position = 0,
    const TEN::Save::Vector3 *velocity = 0,
    int32_t node = 0) {
  PendulumBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Pendulum::Traits {
  using type = Pendulum;
  static auto constexpr Create = CreatePendulum;
};

flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScriptTableT : public flatbuffers::NativeTable {
  typedef ScriptTable TableType;
  std::vector<TEN::Save::KeyValPair> keys_vals{};
};

struct ScriptTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScriptTableT NativeTableType;
  typedef ScriptTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS_VALS = 4
  };
  const flatbuffers::Vector<const TEN::Save::KeyValPair *> *keys_vals() const {
    return GetPointer<const flatbuffers::Vector<const TEN::Save::KeyValPair *> *>(VT_KEYS_VALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS_VALS) &&
           verifier.VerifyVector(keys_vals()) &&
           verifier.EndTable();
  }
  ScriptTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScriptTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScriptTableBuilder {
  typedef ScriptTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys_vals(flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals) {
    fbb_.AddOffset(ScriptTable::VT_KEYS_VALS, keys_vals);
  }
  explicit ScriptTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScriptTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScriptTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TEN::Save::KeyValPair *>> keys_vals = 0) {
  ScriptTableBuilder builder_(_fbb);
  builder_.add_keys_vals(keys_vals);
  return builder_.Finish();
}

struct ScriptTable::Traits {
  using type = ScriptTable;
  static auto constexpr Create = CreateScriptTable;
};

inline flatbuffers::Offset<ScriptTable> CreateScriptTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<TEN::Save::KeyValPair> *keys_vals = nullptr) {
  auto keys_vals__ = keys_vals ? _fbb.CreateVectorOfStructs<TEN::Save::KeyValPair>(*keys_vals) : 0;
  return TEN::Save::CreateScriptTable(
      _fbb,
      keys_vals__);
}

flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct stringTableT : public flatbuffers::NativeTable {
  typedef stringTable TableType;
  std::string str{};
};

struct stringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef stringTableT NativeTableType;
  typedef stringTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4
  };
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           verifier.EndTable();
  }
  stringTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<stringTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct stringTableBuilder {
  typedef stringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(stringTable::VT_STR, str);
  }
  explicit stringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<stringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<stringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<stringTable> CreatestringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  stringTableBuilder builder_(_fbb);
  builder_.add_str(str);
  return builder_.Finish();
}

struct stringTable::Traits {
  using type = stringTable;
  static auto constexpr Create = CreatestringTable;
};

inline flatbuffers::Offset<stringTable> CreatestringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return TEN::Save::CreatestringTable(
      _fbb,
      str__);
}

flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct doubleTableT : public flatbuffers::NativeTable {
  typedef doubleTable TableType;
  double scalar = 0.0;
};

struct doubleTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef doubleTableT NativeTableType;
  typedef doubleTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  double scalar() const {
    return GetField<double>(VT_SCALAR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  doubleTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<doubleTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct doubleTableBuilder {
  typedef doubleTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(double scalar) {
    fbb_.AddElement<double>(doubleTable::VT_SCALAR, scalar, 0.0);
  }
  explicit doubleTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<doubleTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<doubleTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scalar = 0.0) {
  doubleTableBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct doubleTable::Traits {
  using type = doubleTable;
  static auto constexpr Create = CreatedoubleTable;
};

flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionTableT : public flatbuffers::NativeTable {
  typedef UnionTable TableType;
  TEN::Save::VarUnionUnion u{};
};

struct UnionTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionTableT NativeTableType;
  typedef UnionTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U_TYPE = 4,
    VT_U = 6
  };
  TEN::Save::VarUnion u_type() const {
    return static_cast<TEN::Save::VarUnion>(GetField<uint8_t>(VT_U_TYPE, 0));
  }
  const void *u() const {
    return GetPointer<const void *>(VT_U);
  }
  template<typename T> const T *u_as() const;
  const TEN::Save::stringTable *u_as_str() const {
    return u_type() == TEN::Save::VarUnion::str ? static_cast<const TEN::Save::stringTable *>(u()) : nullptr;
  }
  const TEN::Save::ScriptTable *u_as_tab() const {
    return u_type() == TEN::Save::VarUnion::tab ? static_cast<const TEN::Save::ScriptTable *>(u()) : nullptr;
  }
  const TEN::Save::doubleTable *u_as_num() const {
    return u_type() == TEN::Save::VarUnion::num ? static_cast<const TEN::Save::doubleTable *>(u()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_U_TYPE) &&
           VerifyOffset(verifier, VT_U) &&
           VerifyVarUnion(verifier, u(), u_type()) &&
           verifier.EndTable();
  }
  UnionTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TEN::Save::stringTable *UnionTable::u_as<TEN::Save::stringTable>() const {
  return u_as_str();
}

template<> inline const TEN::Save::ScriptTable *UnionTable::u_as<TEN::Save::ScriptTable>() const {
  return u_as_tab();
}

template<> inline const TEN::Save::doubleTable *UnionTable::u_as<TEN::Save::doubleTable>() const {
  return u_as_num();
}

struct UnionTableBuilder {
  typedef UnionTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_u_type(TEN::Save::VarUnion u_type) {
    fbb_.AddElement<uint8_t>(UnionTable::VT_U_TYPE, static_cast<uint8_t>(u_type), 0);
  }
  void add_u(flatbuffers::Offset<void> u) {
    fbb_.AddOffset(UnionTable::VT_U, u);
  }
  explicit UnionTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionTable> CreateUnionTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    TEN::Save::VarUnion u_type = TEN::Save::VarUnion::NONE,
    flatbuffers::Offset<void> u = 0) {
  UnionTableBuilder builder_(_fbb);
  builder_.add_u(u);
  builder_.add_u_type(u_type);
  return builder_.Finish();
}

struct UnionTable::Traits {
  using type = UnionTable;
  static auto constexpr Create = CreateUnionTable;
};

flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionVecT : public flatbuffers::NativeTable {
  typedef UnionVec TableType;
  std::vector<std::unique_ptr<TEN::Save::UnionTableT>> members{};
};

struct UnionVec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionVecT NativeTableType;
  typedef UnionVecBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEMBERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
  UnionVecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionVec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnionVecBuilder {
  typedef UnionVec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members) {
    fbb_.AddOffset(UnionVec::VT_MEMBERS, members);
  }
  explicit UnionVecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnionVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionVec>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionVec> CreateUnionVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::UnionTable>>> members = 0) {
  UnionVecBuilder builder_(_fbb);
  builder_.add_members(members);
  return builder_.Finish();
}

struct UnionVec::Traits {
  using type = UnionVec;
  static auto constexpr Create = CreateUnionVec;
};

inline flatbuffers::Offset<UnionVec> CreateUnionVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TEN::Save::UnionTable>> *members = nullptr) {
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>>(*members) : 0;
  return TEN::Save::CreateUnionVec(
      _fbb,
      members__);
}

flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameHeaderT : public flatbuffers::NativeTable {
  typedef SaveGameHeader TableType;
  std::string level_name{};
  int32_t days = 0;
  int32_t hours = 0;
  int32_t minutes = 0;
  int32_t seconds = 0;
  int32_t level = 0;
  int32_t timer = 0;
  int32_t count = 0;
};

struct SaveGameHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameHeaderT NativeTableType;
  typedef SaveGameHeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL_NAME = 4,
    VT_DAYS = 6,
    VT_HOURS = 8,
    VT_MINUTES = 10,
    VT_SECONDS = 12,
    VT_LEVEL = 14,
    VT_TIMER = 16,
    VT_COUNT = 18
  };
  const flatbuffers::String *level_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEVEL_NAME);
  }
  int32_t days() const {
    return GetField<int32_t>(VT_DAYS, 0);
  }
  int32_t hours() const {
    return GetField<int32_t>(VT_HOURS, 0);
  }
  int32_t minutes() const {
    return GetField<int32_t>(VT_MINUTES, 0);
  }
  int32_t seconds() const {
    return GetField<int32_t>(VT_SECONDS, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEVEL_NAME) &&
           verifier.VerifyString(level_name()) &&
           VerifyField<int32_t>(verifier, VT_DAYS) &&
           VerifyField<int32_t>(verifier, VT_HOURS) &&
           VerifyField<int32_t>(verifier, VT_MINUTES) &&
           VerifyField<int32_t>(verifier, VT_SECONDS) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  SaveGameHeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameHeader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameHeaderBuilder {
  typedef SaveGameHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level_name(flatbuffers::Offset<flatbuffers::String> level_name) {
    fbb_.AddOffset(SaveGameHeader::VT_LEVEL_NAME, level_name);
  }
  void add_days(int32_t days) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_DAYS, days, 0);
  }
  void add_hours(int32_t hours) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_HOURS, hours, 0);
  }
  void add_minutes(int32_t minutes) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_MINUTES, minutes, 0);
  }
  void add_seconds(int32_t seconds) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_SECONDS, seconds, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_LEVEL, level, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_TIMER, timer, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(SaveGameHeader::VT_COUNT, count, 0);
  }
  explicit SaveGameHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> level_name = 0,
    int32_t days = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  SaveGameHeaderBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_timer(timer);
  builder_.add_level(level);
  builder_.add_seconds(seconds);
  builder_.add_minutes(minutes);
  builder_.add_hours(hours);
  builder_.add_days(days);
  builder_.add_level_name(level_name);
  return builder_.Finish();
}

struct SaveGameHeader::Traits {
  using type = SaveGameHeader;
  static auto constexpr Create = CreateSaveGameHeader;
};

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *level_name = nullptr,
    int32_t days = 0,
    int32_t hours = 0,
    int32_t minutes = 0,
    int32_t seconds = 0,
    int32_t level = 0,
    int32_t timer = 0,
    int32_t count = 0) {
  auto level_name__ = level_name ? _fbb.CreateString(level_name) : 0;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      level_name__,
      days,
      hours,
      minutes,
      seconds,
      level,
      timer,
      count);
}

flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameStatisticsT : public flatbuffers::NativeTable {
  typedef SaveGameStatistics TableType;
  int32_t ammo_hits = 0;
  int32_t ammo_used = 0;
  int32_t medipacks_used = 0;
  int32_t distance = 0;
  int32_t kills = 0;
  int32_t secrets = 0;
  int32_t timer = 0;
};

struct SaveGameStatistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameStatisticsT NativeTableType;
  typedef SaveGameStatisticsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMMO_HITS = 4,
    VT_AMMO_USED = 6,
    VT_MEDIPACKS_USED = 8,
    VT_DISTANCE = 10,
    VT_KILLS = 12,
    VT_SECRETS = 14,
    VT_TIMER = 16
  };
  int32_t ammo_hits() const {
    return GetField<int32_t>(VT_AMMO_HITS, 0);
  }
  int32_t ammo_used() const {
    return GetField<int32_t>(VT_AMMO_USED, 0);
  }
  int32_t medipacks_used() const {
    return GetField<int32_t>(VT_MEDIPACKS_USED, 0);
  }
  int32_t distance() const {
    return GetField<int32_t>(VT_DISTANCE, 0);
  }
  int32_t kills() const {
    return GetField<int32_t>(VT_KILLS, 0);
  }
  int32_t secrets() const {
    return GetField<int32_t>(VT_SECRETS, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AMMO_HITS) &&
           VerifyField<int32_t>(verifier, VT_AMMO_USED) &&
           VerifyField<int32_t>(verifier, VT_MEDIPACKS_USED) &&
           VerifyField<int32_t>(verifier, VT_DISTANCE) &&
           VerifyField<int32_t>(verifier, VT_KILLS) &&
           VerifyField<int32_t>(verifier, VT_SECRETS) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           verifier.EndTable();
  }
  SaveGameStatisticsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGameStatistics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameStatisticsBuilder {
  typedef SaveGameStatistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ammo_hits(int32_t ammo_hits) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_HITS, ammo_hits, 0);
  }
  void add_ammo_used(int32_t ammo_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_AMMO_USED, ammo_used, 0);
  }
  void add_medipacks_used(int32_t medipacks_used) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_MEDIPACKS_USED, medipacks_used, 0);
  }
  void add_distance(int32_t distance) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_DISTANCE, distance, 0);
  }
  void add_kills(int32_t kills) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_KILLS, kills, 0);
  }
  void add_secrets(int32_t secrets) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_SECRETS, secrets, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(SaveGameStatistics::VT_TIMER, timer, 0);
  }
  explicit SaveGameStatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGameStatistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGameStatistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ammo_hits = 0,
    int32_t ammo_used = 0,
    int32_t medipacks_used = 0,
    int32_t distance = 0,
    int32_t kills = 0,
    int32_t secrets = 0,
    int32_t timer = 0) {
  SaveGameStatisticsBuilder builder_(_fbb);
  builder_.add_timer(timer);
  builder_.add_secrets(secrets);
  builder_.add_kills(kills);
  builder_.add_distance(distance);
  builder_.add_medipacks_used(medipacks_used);
  builder_.add_ammo_used(ammo_used);
  builder_.add_ammo_hits(ammo_hits);
  return builder_.Finish();
}

struct SaveGameStatistics::Traits {
  using type = SaveGameStatistics;
  static auto constexpr Create = CreateSaveGameStatistics;
};

flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveGameT : public flatbuffers::NativeTable {
  typedef SaveGame TableType;
  std::unique_ptr<TEN::Save::SaveGameHeaderT> header{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> game{};
  std::unique_ptr<TEN::Save::SaveGameStatisticsT> level{};
  std::unique_ptr<TEN::Save::LaraT> lara{};
  std::unique_ptr<TEN::Save::WeaponInfoT> active_weapon{};
  std::vector<std::unique_ptr<TEN::Save::ItemT>> items{};
  std::vector<std::unique_ptr<TEN::Save::FixedCameraT>> fixed_cameras{};
  std::vector<std::unique_ptr<TEN::Save::SinkT>> sinks{};
  std::vector<std::unique_ptr<TEN::Save::StaticMeshInfoT>> static_meshes{};
  std::vector<std::unique_ptr<TEN::Save::FlyByCameraT>> flyby_cameras{};
  std::vector<std::unique_ptr<TEN::Save::RatInfoT>> rats{};
  std::vector<std::unique_ptr<TEN::Save::SpiderInfoT>> spiders{};
  std::vector<std::unique_ptr<TEN::Save::ScarabInfoT>> scarabs{};
  std::vector<std::unique_ptr<TEN::Save::BatInfoT>> bats{};
  std::vector<int32_t> flip_maps{};
  std::vector<int32_t> flip_stats{};
  int32_t flip_effect = 0;
  int32_t flip_timer = 0;
  int32_t flip_status = 0;
  std::string ambient_track{};
  uint64_t ambient_position = 0;
  std::string oneshot_track{};
  uint64_t oneshot_position = 0;
  std::vector<int32_t> cd_flags{};
  std::unique_ptr<TEN::Save::RopeT> rope{};
  std::unique_ptr<TEN::Save::PendulumT> pendulum{};
  std::unique_ptr<TEN::Save::PendulumT> alternate_pendulum{};
  std::unique_ptr<TEN::Save::UnionVecT> script_vars{};
};

struct SaveGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveGameT NativeTableType;
  typedef SaveGameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GAME = 6,
    VT_LEVEL = 8,
    VT_LARA = 10,
    VT_ACTIVE_WEAPON = 12,
    VT_ITEMS = 14,
    VT_FIXED_CAMERAS = 16,
    VT_SINKS = 18,
    VT_STATIC_MESHES = 20,
    VT_FLYBY_CAMERAS = 22,
    VT_RATS = 24,
    VT_SPIDERS = 26,
    VT_SCARABS = 28,
    VT_BATS = 30,
    VT_FLIP_MAPS = 32,
    VT_FLIP_STATS = 34,
    VT_FLIP_EFFECT = 36,
    VT_FLIP_TIMER = 38,
    VT_FLIP_STATUS = 40,
    VT_AMBIENT_TRACK = 42,
    VT_AMBIENT_POSITION = 44,
    VT_ONESHOT_TRACK = 46,
    VT_ONESHOT_POSITION = 48,
    VT_CD_FLAGS = 50,
    VT_ROPE = 52,
    VT_PENDULUM = 54,
    VT_ALTERNATE_PENDULUM = 56,
    VT_SCRIPT_VARS = 58
  };
  const TEN::Save::SaveGameHeader *header() const {
    return GetPointer<const TEN::Save::SaveGameHeader *>(VT_HEADER);
  }
  const TEN::Save::SaveGameStatistics *game() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_GAME);
  }
  const TEN::Save::SaveGameStatistics *level() const {
    return GetPointer<const TEN::Save::SaveGameStatistics *>(VT_LEVEL);
  }
  const TEN::Save::Lara *lara() const {
    return GetPointer<const TEN::Save::Lara *>(VT_LARA);
  }
  const TEN::Save::WeaponInfo *active_weapon() const {
    return GetPointer<const TEN::Save::WeaponInfo *>(VT_ACTIVE_WEAPON);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *>(VT_FIXED_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>> *>(VT_SINKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *>(VT_STATIC_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *>(VT_FLYBY_CAMERAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>> *rats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>> *>(VT_RATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *spiders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *>(VT_SPIDERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *scarabs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *>(VT_SCARABS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>> *bats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>> *>(VT_BATS);
  }
  const flatbuffers::Vector<int32_t> *flip_maps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_MAPS);
  }
  const flatbuffers::Vector<int32_t> *flip_stats() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLIP_STATS);
  }
  int32_t flip_effect() const {
    return GetField<int32_t>(VT_FLIP_EFFECT, 0);
  }
  int32_t flip_timer() const {
    return GetField<int32_t>(VT_FLIP_TIMER, 0);
  }
  int32_t flip_status() const {
    return GetField<int32_t>(VT_FLIP_STATUS, 0);
  }
  const flatbuffers::String *ambient_track() const {
    return GetPointer<const flatbuffers::String *>(VT_AMBIENT_TRACK);
  }
  uint64_t ambient_position() const {
    return GetField<uint64_t>(VT_AMBIENT_POSITION, 0);
  }
  const flatbuffers::String *oneshot_track() const {
    return GetPointer<const flatbuffers::String *>(VT_ONESHOT_TRACK);
  }
  uint64_t oneshot_position() const {
    return GetField<uint64_t>(VT_ONESHOT_POSITION, 0);
  }
  const flatbuffers::Vector<int32_t> *cd_flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CD_FLAGS);
  }
  const TEN::Save::Rope *rope() const {
    return GetPointer<const TEN::Save::Rope *>(VT_ROPE);
  }
  const TEN::Save::Pendulum *pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_PENDULUM);
  }
  const TEN::Save::Pendulum *alternate_pendulum() const {
    return GetPointer<const TEN::Save::Pendulum *>(VT_ALTERNATE_PENDULUM);
  }
  const TEN::Save::UnionVec *script_vars() const {
    return GetPointer<const TEN::Save::UnionVec *>(VT_SCRIPT_VARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_GAME) &&
           verifier.VerifyTable(game()) &&
           VerifyOffset(verifier, VT_LEVEL) &&
           verifier.VerifyTable(level()) &&
           VerifyOffset(verifier, VT_LARA) &&
           verifier.VerifyTable(lara()) &&
           VerifyOffset(verifier, VT_ACTIVE_WEAPON) &&
           verifier.VerifyTable(active_weapon()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_FIXED_CAMERAS) &&
           verifier.VerifyVector(fixed_cameras()) &&
           verifier.VerifyVectorOfTables(fixed_cameras()) &&
           VerifyOffset(verifier, VT_SINKS) &&
           verifier.VerifyVector(sinks()) &&
           verifier.VerifyVectorOfTables(sinks()) &&
           VerifyOffset(verifier, VT_STATIC_MESHES) &&
           verifier.VerifyVector(static_meshes()) &&
           verifier.VerifyVectorOfTables(static_meshes()) &&
           VerifyOffset(verifier, VT_FLYBY_CAMERAS) &&
           verifier.VerifyVector(flyby_cameras()) &&
           verifier.VerifyVectorOfTables(flyby_cameras()) &&
           VerifyOffset(verifier, VT_RATS) &&
           verifier.VerifyVector(rats()) &&
           verifier.VerifyVectorOfTables(rats()) &&
           VerifyOffset(verifier, VT_SPIDERS) &&
           verifier.VerifyVector(spiders()) &&
           verifier.VerifyVectorOfTables(spiders()) &&
           VerifyOffset(verifier, VT_SCARABS) &&
           verifier.VerifyVector(scarabs()) &&
           verifier.VerifyVectorOfTables(scarabs()) &&
           VerifyOffset(verifier, VT_BATS) &&
           verifier.VerifyVector(bats()) &&
           verifier.VerifyVectorOfTables(bats()) &&
           VerifyOffset(verifier, VT_FLIP_MAPS) &&
           verifier.VerifyVector(flip_maps()) &&
           VerifyOffset(verifier, VT_FLIP_STATS) &&
           verifier.VerifyVector(flip_stats()) &&
           VerifyField<int32_t>(verifier, VT_FLIP_EFFECT) &&
           VerifyField<int32_t>(verifier, VT_FLIP_TIMER) &&
           VerifyField<int32_t>(verifier, VT_FLIP_STATUS) &&
           VerifyOffset(verifier, VT_AMBIENT_TRACK) &&
           verifier.VerifyString(ambient_track()) &&
           VerifyField<uint64_t>(verifier, VT_AMBIENT_POSITION) &&
           VerifyOffset(verifier, VT_ONESHOT_TRACK) &&
           verifier.VerifyString(oneshot_track()) &&
           VerifyField<uint64_t>(verifier, VT_ONESHOT_POSITION) &&
           VerifyOffset(verifier, VT_CD_FLAGS) &&
           verifier.VerifyVector(cd_flags()) &&
           VerifyOffset(verifier, VT_ROPE) &&
           verifier.VerifyTable(rope()) &&
           VerifyOffset(verifier, VT_PENDULUM) &&
           verifier.VerifyTable(pendulum()) &&
           VerifyOffset(verifier, VT_ALTERNATE_PENDULUM) &&
           verifier.VerifyTable(alternate_pendulum()) &&
           VerifyOffset(verifier, VT_SCRIPT_VARS) &&
           verifier.VerifyTable(script_vars()) &&
           verifier.EndTable();
  }
  SaveGameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SaveGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveGameBuilder {
  typedef SaveGame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<TEN::Save::SaveGameHeader> header) {
    fbb_.AddOffset(SaveGame::VT_HEADER, header);
  }
  void add_game(flatbuffers::Offset<TEN::Save::SaveGameStatistics> game) {
    fbb_.AddOffset(SaveGame::VT_GAME, game);
  }
  void add_level(flatbuffers::Offset<TEN::Save::SaveGameStatistics> level) {
    fbb_.AddOffset(SaveGame::VT_LEVEL, level);
  }
  void add_lara(flatbuffers::Offset<TEN::Save::Lara> lara) {
    fbb_.AddOffset(SaveGame::VT_LARA, lara);
  }
  void add_active_weapon(flatbuffers::Offset<TEN::Save::WeaponInfo> active_weapon) {
    fbb_.AddOffset(SaveGame::VT_ACTIVE_WEAPON, active_weapon);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items) {
    fbb_.AddOffset(SaveGame::VT_ITEMS, items);
  }
  void add_fixed_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras) {
    fbb_.AddOffset(SaveGame::VT_FIXED_CAMERAS, fixed_cameras);
  }
  void add_sinks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks) {
    fbb_.AddOffset(SaveGame::VT_SINKS, sinks);
  }
  void add_static_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes) {
    fbb_.AddOffset(SaveGame::VT_STATIC_MESHES, static_meshes);
  }
  void add_flyby_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras) {
    fbb_.AddOffset(SaveGame::VT_FLYBY_CAMERAS, flyby_cameras);
  }
  void add_rats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>>> rats) {
    fbb_.AddOffset(SaveGame::VT_RATS, rats);
  }
  void add_spiders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>>> spiders) {
    fbb_.AddOffset(SaveGame::VT_SPIDERS, spiders);
  }
  void add_scarabs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>>> scarabs) {
    fbb_.AddOffset(SaveGame::VT_SCARABS, scarabs);
  }
  void add_bats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>>> bats) {
    fbb_.AddOffset(SaveGame::VT_BATS, bats);
  }
  void add_flip_maps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps) {
    fbb_.AddOffset(SaveGame::VT_FLIP_MAPS, flip_maps);
  }
  void add_flip_stats(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats) {
    fbb_.AddOffset(SaveGame::VT_FLIP_STATS, flip_stats);
  }
  void add_flip_effect(int32_t flip_effect) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_EFFECT, flip_effect, 0);
  }
  void add_flip_timer(int32_t flip_timer) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_TIMER, flip_timer, 0);
  }
  void add_flip_status(int32_t flip_status) {
    fbb_.AddElement<int32_t>(SaveGame::VT_FLIP_STATUS, flip_status, 0);
  }
  void add_ambient_track(flatbuffers::Offset<flatbuffers::String> ambient_track) {
    fbb_.AddOffset(SaveGame::VT_AMBIENT_TRACK, ambient_track);
  }
  void add_ambient_position(uint64_t ambient_position) {
    fbb_.AddElement<uint64_t>(SaveGame::VT_AMBIENT_POSITION, ambient_position, 0);
  }
  void add_oneshot_track(flatbuffers::Offset<flatbuffers::String> oneshot_track) {
    fbb_.AddOffset(SaveGame::VT_ONESHOT_TRACK, oneshot_track);
  }
  void add_oneshot_position(uint64_t oneshot_position) {
    fbb_.AddElement<uint64_t>(SaveGame::VT_ONESHOT_POSITION, oneshot_position, 0);
  }
  void add_cd_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags) {
    fbb_.AddOffset(SaveGame::VT_CD_FLAGS, cd_flags);
  }
  void add_rope(flatbuffers::Offset<TEN::Save::Rope> rope) {
    fbb_.AddOffset(SaveGame::VT_ROPE, rope);
  }
  void add_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> pendulum) {
    fbb_.AddOffset(SaveGame::VT_PENDULUM, pendulum);
  }
  void add_alternate_pendulum(flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum) {
    fbb_.AddOffset(SaveGame::VT_ALTERNATE_PENDULUM, alternate_pendulum);
  }
  void add_script_vars(flatbuffers::Offset<TEN::Save::UnionVec> script_vars) {
    fbb_.AddOffset(SaveGame::VT_SCRIPT_VARS, script_vars);
  }
  explicit SaveGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<SaveGame> CreateSaveGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    flatbuffers::Offset<TEN::Save::WeaponInfo> active_weapon = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Item>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FixedCamera>>> fixed_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::Sink>>> sinks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>> static_meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::FlyByCamera>>> flyby_cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::RatInfo>>> rats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::SpiderInfo>>> spiders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::ScarabInfo>>> scarabs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TEN::Save::BatInfo>>> bats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_maps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flip_stats = 0,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    flatbuffers::Offset<flatbuffers::String> ambient_track = 0,
    uint64_t ambient_position = 0,
    flatbuffers::Offset<flatbuffers::String> oneshot_track = 0,
    uint64_t oneshot_position = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> cd_flags = 0,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0) {
  SaveGameBuilder builder_(_fbb);
  builder_.add_oneshot_position(oneshot_position);
  builder_.add_ambient_position(ambient_position);
  builder_.add_script_vars(script_vars);
  builder_.add_alternate_pendulum(alternate_pendulum);
  builder_.add_pendulum(pendulum);
  builder_.add_rope(rope);
  builder_.add_cd_flags(cd_flags);
  builder_.add_oneshot_track(oneshot_track);
  builder_.add_ambient_track(ambient_track);
  builder_.add_flip_status(flip_status);
  builder_.add_flip_timer(flip_timer);
  builder_.add_flip_effect(flip_effect);
  builder_.add_flip_stats(flip_stats);
  builder_.add_flip_maps(flip_maps);
  builder_.add_bats(bats);
  builder_.add_scarabs(scarabs);
  builder_.add_spiders(spiders);
  builder_.add_rats(rats);
  builder_.add_flyby_cameras(flyby_cameras);
  builder_.add_static_meshes(static_meshes);
  builder_.add_sinks(sinks);
  builder_.add_fixed_cameras(fixed_cameras);
  builder_.add_items(items);
  builder_.add_active_weapon(active_weapon);
  builder_.add_lara(lara);
  builder_.add_level(level);
  builder_.add_game(game);
  builder_.add_header(header);
  return builder_.Finish();
}

struct SaveGame::Traits {
  using type = SaveGame;
  static auto constexpr Create = CreateSaveGame;
};

inline flatbuffers::Offset<SaveGame> CreateSaveGameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TEN::Save::SaveGameHeader> header = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> game = 0,
    flatbuffers::Offset<TEN::Save::SaveGameStatistics> level = 0,
    flatbuffers::Offset<TEN::Save::Lara> lara = 0,
    flatbuffers::Offset<TEN::Save::WeaponInfo> active_weapon = 0,
    const std::vector<flatbuffers::Offset<TEN::Save::Item>> *items = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FixedCamera>> *fixed_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::Sink>> *sinks = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> *static_meshes = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::FlyByCamera>> *flyby_cameras = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::RatInfo>> *rats = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::SpiderInfo>> *spiders = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::ScarabInfo>> *scarabs = nullptr,
    const std::vector<flatbuffers::Offset<TEN::Save::BatInfo>> *bats = nullptr,
    const std::vector<int32_t> *flip_maps = nullptr,
    const std::vector<int32_t> *flip_stats = nullptr,
    int32_t flip_effect = 0,
    int32_t flip_timer = 0,
    int32_t flip_status = 0,
    const char *ambient_track = nullptr,
    uint64_t ambient_position = 0,
    const char *oneshot_track = nullptr,
    uint64_t oneshot_position = 0,
    const std::vector<int32_t> *cd_flags = nullptr,
    flatbuffers::Offset<TEN::Save::Rope> rope = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> pendulum = 0,
    flatbuffers::Offset<TEN::Save::Pendulum> alternate_pendulum = 0,
    flatbuffers::Offset<TEN::Save::UnionVec> script_vars = 0) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>>(*items) : 0;
  auto fixed_cameras__ = fixed_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>>(*fixed_cameras) : 0;
  auto sinks__ = sinks ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>>(*sinks) : 0;
  auto static_meshes__ = static_meshes ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>>(*static_meshes) : 0;
  auto flyby_cameras__ = flyby_cameras ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>>(*flyby_cameras) : 0;
  auto rats__ = rats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RatInfo>>(*rats) : 0;
  auto spiders__ = spiders ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SpiderInfo>>(*spiders) : 0;
  auto scarabs__ = scarabs ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ScarabInfo>>(*scarabs) : 0;
  auto bats__ = bats ? _fbb.CreateVector<flatbuffers::Offset<TEN::Save::BatInfo>>(*bats) : 0;
  auto flip_maps__ = flip_maps ? _fbb.CreateVector<int32_t>(*flip_maps) : 0;
  auto flip_stats__ = flip_stats ? _fbb.CreateVector<int32_t>(*flip_stats) : 0;
  auto ambient_track__ = ambient_track ? _fbb.CreateString(ambient_track) : 0;
  auto oneshot_track__ = oneshot_track ? _fbb.CreateString(oneshot_track) : 0;
  auto cd_flags__ = cd_flags ? _fbb.CreateVector<int32_t>(*cd_flags) : 0;
  return TEN::Save::CreateSaveGame(
      _fbb,
      header,
      game,
      level,
      lara,
      active_weapon,
      items__,
      fixed_cameras__,
      sinks__,
      static_meshes__,
      flyby_cameras__,
      rats__,
      spiders__,
      scarabs__,
      bats__,
      flip_maps__,
      flip_stats__,
      flip_effect,
      flip_timer,
      flip_status,
      ambient_track__,
      ambient_position,
      oneshot_track__,
      oneshot_position,
      cd_flags__,
      rope,
      pendulum,
      alternate_pendulum,
      script_vars);
}

flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ItemT *Item::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ItemT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = floor(); _o->floor = _e; }
  { auto _e = touch_bits(); _o->touch_bits = _e; }
  { auto _e = mesh_bits(); _o->mesh_bits = _e; }
  { auto _e = object_id(); _o->object_id = _e; }
  { auto _e = current_anim_state(); _o->current_anim_state = _e; }
  { auto _e = goal_anim_state(); _o->goal_anim_state = _e; }
  { auto _e = required_anim_state(); _o->required_anim_state = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = fall_speed(); _o->fall_speed = _e; }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = box_number(); _o->box_number = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = trigger_flags(); _o->trigger_flags = _e; }
  { auto _e = carried_item(); _o->carried_item = _e; }
  { auto _e = after_death(); _o->after_death = _e; }
  { auto _e = fired_weapon(); _o->fired_weapon = _e; }
  { auto _e = item_flags(); if (_e) { _o->item_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->item_flags[_i] = _e->Get(_i); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
  { auto _e = triggered(); _o->triggered = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = status(); _o->status = _e; }
  { auto _e = gravity_status(); _o->gravity_status = _e; }
  { auto _e = hit_stauts(); _o->hit_stauts = _e; }
  { auto _e = collidable(); _o->collidable = _e; }
  { auto _e = looked_at(); _o->looked_at = _e; }
  { auto _e = poisoned(); _o->poisoned = _e; }
  { auto _e = ai_bits(); _o->ai_bits = _e; }
  { auto _e = swap_mesh_flags(); _o->swap_mesh_flags = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = TEN::Save::ItemDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<Item> Item::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Item> CreateItem(flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _floor = _o->floor;
  auto _touch_bits = _o->touch_bits;
  auto _mesh_bits = _o->mesh_bits;
  auto _object_id = _o->object_id;
  auto _current_anim_state = _o->current_anim_state;
  auto _goal_anim_state = _o->goal_anim_state;
  auto _required_anim_state = _o->required_anim_state;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _room_number = _o->room_number;
  auto _speed = _o->speed;
  auto _fall_speed = _o->fall_speed;
  auto _hit_points = _o->hit_points;
  auto _box_number = _o->box_number;
  auto _timer = _o->timer;
  auto _flags = _o->flags;
  auto _trigger_flags = _o->trigger_flags;
  auto _carried_item = _o->carried_item;
  auto _after_death = _o->after_death;
  auto _fired_weapon = _o->fired_weapon;
  auto _item_flags = _fbb.CreateVector(_o->item_flags);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _triggered = _o->triggered;
  auto _active = _o->active;
  auto _status = _o->status;
  auto _gravity_status = _o->gravity_status;
  auto _hit_stauts = _o->hit_stauts;
  auto _collidable = _o->collidable;
  auto _looked_at = _o->looked_at;
  auto _poisoned = _o->poisoned;
  auto _ai_bits = _o->ai_bits;
  auto _swap_mesh_flags = _o->swap_mesh_flags;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return TEN::Save::CreateItem(
      _fbb,
      _floor,
      _touch_bits,
      _mesh_bits,
      _object_id,
      _current_anim_state,
      _goal_anim_state,
      _required_anim_state,
      _anim_number,
      _frame_number,
      _room_number,
      _speed,
      _fall_speed,
      _hit_points,
      _box_number,
      _timer,
      _flags,
      _trigger_flags,
      _carried_item,
      _after_death,
      _fired_weapon,
      _item_flags,
      _position,
      _triggered,
      _active,
      _status,
      _gravity_status,
      _hit_stauts,
      _collidable,
      _looked_at,
      _poisoned,
      _ai_bits,
      _swap_mesh_flags,
      _data_type,
      _data);
}

inline WeaponInfoT *WeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WeaponInfo::UnPackTo(WeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = current_anim_state(); _o->current_anim_state = _e; }
  { auto _e = goal_anim_state(); _o->goal_anim_state = _e; }
}

inline flatbuffers::Offset<WeaponInfo> WeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WeaponInfo> CreateWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const WeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_number = _o->object_number;
  auto _anim_number = _o->anim_number;
  auto _frame_number = _o->frame_number;
  auto _current_anim_state = _o->current_anim_state;
  auto _goal_anim_state = _o->goal_anim_state;
  return TEN::Save::CreateWeaponInfo(
      _fbb,
      _object_number,
      _anim_number,
      _frame_number,
      _current_anim_state,
      _goal_anim_state);
}

inline HolsterInfoT *HolsterInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<HolsterInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HolsterInfo::UnPackTo(HolsterInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = left_holster(); _o->left_holster = _e; }
  { auto _e = right_holster(); _o->right_holster = _e; }
  { auto _e = back_holster(); _o->back_holster = _e; }
}

inline flatbuffers::Offset<HolsterInfo> HolsterInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHolsterInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HolsterInfo> CreateHolsterInfo(flatbuffers::FlatBufferBuilder &_fbb, const HolsterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HolsterInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _left_holster = _o->left_holster;
  auto _right_holster = _o->right_holster;
  auto _back_holster = _o->back_holster;
  return TEN::Save::CreateHolsterInfo(
      _fbb,
      _left_holster,
      _right_holster,
      _back_holster);
}

inline AmmoInfoT *AmmoInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AmmoInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AmmoInfo::UnPackTo(AmmoInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; }
  { auto _e = is_infinite(); _o->is_infinite = _e; }
}

inline flatbuffers::Offset<AmmoInfo> AmmoInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAmmoInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AmmoInfo> CreateAmmoInfo(flatbuffers::FlatBufferBuilder &_fbb, const AmmoInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AmmoInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _is_infinite = _o->is_infinite;
  return TEN::Save::CreateAmmoInfo(
      _fbb,
      _count,
      _is_infinite);
}

inline CarriedWeaponInfoT *CarriedWeaponInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CarriedWeaponInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CarriedWeaponInfo::UnPackTo(CarriedWeaponInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = present(); _o->present = _e; }
  { auto _e = ammo(); if (_e) { _o->ammo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ammo[_i] = std::unique_ptr<TEN::Save::AmmoInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = selected_ammo(); _o->selected_ammo = _e; }
  { auto _e = has_lasersight(); _o->has_lasersight = _e; }
  { auto _e = has_silencer(); _o->has_silencer = _e; }
}

inline flatbuffers::Offset<CarriedWeaponInfo> CarriedWeaponInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCarriedWeaponInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CarriedWeaponInfo> CreateCarriedWeaponInfo(flatbuffers::FlatBufferBuilder &_fbb, const CarriedWeaponInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CarriedWeaponInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _present = _o->present;
  auto _ammo = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::AmmoInfo>> (_o->ammo.size(), [](size_t i, _VectorArgs *__va) { return CreateAmmoInfo(*__va->__fbb, __va->__o->ammo[i].get(), __va->__rehasher); }, &_va );
  auto _selected_ammo = _o->selected_ammo;
  auto _has_lasersight = _o->has_lasersight;
  auto _has_silencer = _o->has_silencer;
  return TEN::Save::CreateCarriedWeaponInfo(
      _fbb,
      _present,
      _ammo,
      _selected_ammo,
      _has_lasersight,
      _has_silencer);
}

inline LaraArmInfoT *LaraArmInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraArmInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraArmInfo::UnPackTo(LaraArmInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_base(); _o->frame_base = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = anim_number(); _o->anim_number = _e; }
  { auto _e = lock(); _o->lock = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = flash_gun(); _o->flash_gun = _e; }
}

inline flatbuffers::Offset<LaraArmInfo> LaraArmInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraArmInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraArmInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraArmInfo> CreateLaraArmInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraArmInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraArmInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_base = _o->frame_base;
  auto _frame_number = _o->frame_number;
  auto _anim_number = _o->anim_number;
  auto _lock = _o->lock;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _flash_gun = _o->flash_gun;
  return TEN::Save::CreateLaraArmInfo(
      _fbb,
      _frame_base,
      _frame_number,
      _anim_number,
      _lock,
      _x_rot,
      _y_rot,
      _z_rot,
      _flash_gun);
}

inline LaraTightropeInfoT *LaraTightropeInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraTightropeInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraTightropeInfo::UnPackTo(LaraTightropeInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = balance(); _o->balance = _e; }
  { auto _e = time_on_tightrope(); _o->time_on_tightrope = _e; }
  { auto _e = can_go_off(); _o->can_go_off = _e; }
  { auto _e = tightrope_item(); _o->tightrope_item = _e; }
}

inline flatbuffers::Offset<LaraTightropeInfo> LaraTightropeInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraTightropeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraTightropeInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraTightropeInfo> CreateLaraTightropeInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraTightropeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraTightropeInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _balance = _o->balance;
  auto _time_on_tightrope = _o->time_on_tightrope;
  auto _can_go_off = _o->can_go_off;
  auto _tightrope_item = _o->tightrope_item;
  return TEN::Save::CreateLaraTightropeInfo(
      _fbb,
      _balance,
      _time_on_tightrope,
      _can_go_off,
      _tightrope_item);
}

inline LaraT *Lara::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lara::UnPackTo(LaraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item_number(); _o->item_number = _e; }
  { auto _e = gun_status(); _o->gun_status = _e; }
  { auto _e = gun_type(); _o->gun_type = _e; }
  { auto _e = request_gun_type(); _o->request_gun_type = _e; }
  { auto _e = last_gun_type(); _o->last_gun_type = _e; }
  { auto _e = hit_points(); _o->hit_points = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = fall_speed(); _o->fall_speed = _e; }
  { auto _e = calc_fall_speed(); _o->calc_fall_speed = _e; }
  { auto _e = water_status(); _o->water_status = _e; }
  { auto _e = climb_status(); _o->climb_status = _e; }
  { auto _e = pose_count(); _o->pose_count = _e; }
  { auto _e = jump_count(); _o->jump_count = _e; }
  { auto _e = jump_queued(); _o->jump_queued = _e; }
  { auto _e = hit_frame(); _o->hit_frame = _e; }
  { auto _e = hit_direction(); _o->hit_direction = _e; }
  { auto _e = sprint_timer(); _o->sprint_timer = _e; }
  { auto _e = air(); _o->air = _e; }
  { auto _e = dive_count(); _o->dive_count = _e; }
  { auto _e = death_count(); _o->death_count = _e; }
  { auto _e = current_active(); _o->current_active = _e; }
  { auto _e = current_x_vel(); _o->current_x_vel = _e; }
  { auto _e = current_y_vel(); _o->current_y_vel = _e; }
  { auto _e = current_z_vel(); _o->current_z_vel = _e; }
  { auto _e = spaz_effect_count(); _o->spaz_effect_count = _e; }
  { auto _e = flare_age(); _o->flare_age = _e; }
  { auto _e = burn_count(); _o->burn_count = _e; }
  { auto _e = weapon_item(); _o->weapon_item = _e; }
  { auto _e = holster_info(); if (_e) _o->holster_info = std::unique_ptr<TEN::Save::HolsterInfoT>(_e->UnPack(_resolver)); }
  { auto _e = flare_frame(); _o->flare_frame = _e; }
  { auto _e = poisoned(); _o->poisoned = _e; }
  { auto _e = wet(); if (_e) { _o->wet.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->wet[_i] = _e->Get(_i) != 0; } } }
  { auto _e = flare_control_left(); _o->flare_control_left = _e; }
  { auto _e = look(); _o->look = _e; }
  { auto _e = burn(); _o->burn = _e; }
  { auto _e = keep_crouched(); _o->keep_crouched = _e; }
  { auto _e = is_moving(); _o->is_moving = _e; }
  { auto _e = can_monkey_swing(); _o->can_monkey_swing = _e; }
  { auto _e = burn_blue(); _o->burn_blue = _e; }
  { auto _e = burn_smoke(); _o->burn_smoke = _e; }
  { auto _e = is_ducked(); _o->is_ducked = _e; }
  { auto _e = has_fired(); _o->has_fired = _e; }
  { auto _e = busy(); _o->busy = _e; }
  { auto _e = old_busy(); _o->old_busy = _e; }
  { auto _e = uncontrollable(); _o->uncontrollable = _e; }
  { auto _e = lit_torch(); _o->lit_torch = _e; }
  { auto _e = is_climbing(); _o->is_climbing = _e; }
  { auto _e = fired(); _o->fired = _e; }
  { auto _e = water_surface_dist(); _o->water_surface_dist = _e; }
  { auto _e = last_position(); if (_e) _o->last_position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = next_corner_position(); if (_e) _o->next_corner_position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = next_corner_rotation(); if (_e) _o->next_corner_rotation = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = mesh_ptrs(); if (_e) { _o->mesh_ptrs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mesh_ptrs[_i] = _e->Get(_i); } } }
  { auto _e = target_angles(); if (_e) { _o->target_angles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->target_angles[_i] = _e->Get(_i); } } }
  { auto _e = turn_rate(); _o->turn_rate = _e; }
  { auto _e = move_angle(); _o->move_angle = _e; }
  { auto _e = head_x_rot(); _o->head_x_rot = _e; }
  { auto _e = head_y_rot(); _o->head_y_rot = _e; }
  { auto _e = head_z_rot(); _o->head_z_rot = _e; }
  { auto _e = torso_x_rot(); _o->torso_x_rot = _e; }
  { auto _e = torso_y_rot(); _o->torso_y_rot = _e; }
  { auto _e = torso_z_rot(); _o->torso_z_rot = _e; }
  { auto _e = left_arm(); if (_e) _o->left_arm = std::unique_ptr<TEN::Save::LaraArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = right_arm(); if (_e) _o->right_arm = std::unique_ptr<TEN::Save::LaraArmInfoT>(_e->UnPack(_resolver)); }
  { auto _e = rope_segment(); _o->rope_segment = _e; }
  { auto _e = rope_direction(); _o->rope_direction = _e; }
  { auto _e = rope_arc_front(); _o->rope_arc_front = _e; }
  { auto _e = rope_arc_back(); _o->rope_arc_back = _e; }
  { auto _e = rope_last_x(); _o->rope_last_x = _e; }
  { auto _e = rope_max_x_forward(); _o->rope_max_x_forward = _e; }
  { auto _e = rope_max_x_backward(); _o->rope_max_x_backward = _e; }
  { auto _e = rope_dframe(); _o->rope_dframe = _e; }
  { auto _e = rope_frame(); _o->rope_frame = _e; }
  { auto _e = rope_framerate(); _o->rope_framerate = _e; }
  { auto _e = rope_y(); _o->rope_y = _e; }
  { auto _e = rope_ptr(); _o->rope_ptr = _e; }
  { auto _e = interacted_item(); _o->interacted_item = _e; }
  { auto _e = rope_offset(); _o->rope_offset = _e; }
  { auto _e = rope_down_vel(); _o->rope_down_vel = _e; }
  { auto _e = rope_flag(); _o->rope_flag = _e; }
  { auto _e = rope_count(); _o->rope_count = _e; }
  { auto _e = move_count(); _o->move_count = _e; }
  { auto _e = location(); _o->location = _e; }
  { auto _e = highest_location(); _o->highest_location = _e; }
  { auto _e = location_pad(); _o->location_pad = _e; }
  { auto _e = tightrope(); if (_e) _o->tightrope = std::unique_ptr<TEN::Save::LaraTightropeInfoT>(_e->UnPack(_resolver)); }
  { auto _e = beetle_life(); _o->beetle_life = _e; }
  { auto _e = has_beetle_things(); _o->has_beetle_things = _e; }
  { auto _e = small_waterskin(); _o->small_waterskin = _e; }
  { auto _e = big_waterskin(); _o->big_waterskin = _e; }
  { auto _e = vehicle(); _o->vehicle = _e; }
  { auto _e = extra_anim(); _o->extra_anim = _e; }
  { auto _e = mine_l(); _o->mine_l = _e; }
  { auto _e = mine_r(); _o->mine_r = _e; }
  { auto _e = weapons(); if (_e) { _o->weapons.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weapons[_i] = std::unique_ptr<TEN::Save::CarriedWeaponInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = puzzles(); if (_e) { _o->puzzles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles[_i] = _e->Get(_i); } } }
  { auto _e = keys(); if (_e) { _o->keys.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys[_i] = _e->Get(_i); } } }
  { auto _e = pickups(); if (_e) { _o->pickups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups[_i] = _e->Get(_i); } } }
  { auto _e = examines(); if (_e) { _o->examines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines[_i] = _e->Get(_i); } } }
  { auto _e = puzzles_combo(); if (_e) { _o->puzzles_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->puzzles_combo[_i] = _e->Get(_i); } } }
  { auto _e = keys_combo(); if (_e) { _o->keys_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_combo[_i] = _e->Get(_i); } } }
  { auto _e = pickups_combo(); if (_e) { _o->pickups_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pickups_combo[_i] = _e->Get(_i); } } }
  { auto _e = examines_combo(); if (_e) { _o->examines_combo.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->examines_combo[_i] = _e->Get(_i); } } }
  { auto _e = secrets(); _o->secrets = _e; }
  { auto _e = lasersight(); _o->lasersight = _e; }
  { auto _e = crowbar(); _o->crowbar = _e; }
  { auto _e = torch(); _o->torch = _e; }
  { auto _e = silencer(); _o->silencer = _e; }
  { auto _e = binoculars(); _o->binoculars = _e; }
  { auto _e = num_large_medipacks(); _o->num_large_medipacks = _e; }
  { auto _e = num_small_medipacks(); _o->num_small_medipacks = _e; }
  { auto _e = num_flares(); _o->num_flares = _e; }
  { auto _e = target_item_number(); _o->target_item_number = _e; }
}

inline flatbuffers::Offset<Lara> Lara::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLara(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lara> CreateLara(flatbuffers::FlatBufferBuilder &_fbb, const LaraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item_number = _o->item_number;
  auto _gun_status = _o->gun_status;
  auto _gun_type = _o->gun_type;
  auto _request_gun_type = _o->request_gun_type;
  auto _last_gun_type = _o->last_gun_type;
  auto _hit_points = _o->hit_points;
  auto _speed = _o->speed;
  auto _fall_speed = _o->fall_speed;
  auto _calc_fall_speed = _o->calc_fall_speed;
  auto _water_status = _o->water_status;
  auto _climb_status = _o->climb_status;
  auto _pose_count = _o->pose_count;
  auto _jump_count = _o->jump_count;
  auto _jump_queued = _o->jump_queued;
  auto _hit_frame = _o->hit_frame;
  auto _hit_direction = _o->hit_direction;
  auto _sprint_timer = _o->sprint_timer;
  auto _air = _o->air;
  auto _dive_count = _o->dive_count;
  auto _death_count = _o->death_count;
  auto _current_active = _o->current_active;
  auto _current_x_vel = _o->current_x_vel;
  auto _current_y_vel = _o->current_y_vel;
  auto _current_z_vel = _o->current_z_vel;
  auto _spaz_effect_count = _o->spaz_effect_count;
  auto _flare_age = _o->flare_age;
  auto _burn_count = _o->burn_count;
  auto _weapon_item = _o->weapon_item;
  auto _holster_info = _o->holster_info ? CreateHolsterInfo(_fbb, _o->holster_info.get(), _rehasher) : 0;
  auto _flare_frame = _o->flare_frame;
  auto _poisoned = _o->poisoned;
  auto _wet = _fbb.CreateVector(_o->wet);
  auto _flare_control_left = _o->flare_control_left;
  auto _look = _o->look;
  auto _burn = _o->burn;
  auto _keep_crouched = _o->keep_crouched;
  auto _is_moving = _o->is_moving;
  auto _can_monkey_swing = _o->can_monkey_swing;
  auto _burn_blue = _o->burn_blue;
  auto _burn_smoke = _o->burn_smoke;
  auto _is_ducked = _o->is_ducked;
  auto _has_fired = _o->has_fired;
  auto _busy = _o->busy;
  auto _old_busy = _o->old_busy;
  auto _uncontrollable = _o->uncontrollable;
  auto _lit_torch = _o->lit_torch;
  auto _is_climbing = _o->is_climbing;
  auto _fired = _o->fired;
  auto _water_surface_dist = _o->water_surface_dist;
  auto _last_position = _o->last_position ? _o->last_position.get() : 0;
  auto _next_corner_position = _o->next_corner_position ? _o->next_corner_position.get() : 0;
  auto _next_corner_rotation = _o->next_corner_rotation ? _o->next_corner_rotation.get() : 0;
  auto _mesh_ptrs = _fbb.CreateVector(_o->mesh_ptrs);
  auto _target_angles = _fbb.CreateVector(_o->target_angles);
  auto _turn_rate = _o->turn_rate;
  auto _move_angle = _o->move_angle;
  auto _head_x_rot = _o->head_x_rot;
  auto _head_y_rot = _o->head_y_rot;
  auto _head_z_rot = _o->head_z_rot;
  auto _torso_x_rot = _o->torso_x_rot;
  auto _torso_y_rot = _o->torso_y_rot;
  auto _torso_z_rot = _o->torso_z_rot;
  auto _left_arm = _o->left_arm ? CreateLaraArmInfo(_fbb, _o->left_arm.get(), _rehasher) : 0;
  auto _right_arm = _o->right_arm ? CreateLaraArmInfo(_fbb, _o->right_arm.get(), _rehasher) : 0;
  auto _rope_segment = _o->rope_segment;
  auto _rope_direction = _o->rope_direction;
  auto _rope_arc_front = _o->rope_arc_front;
  auto _rope_arc_back = _o->rope_arc_back;
  auto _rope_last_x = _o->rope_last_x;
  auto _rope_max_x_forward = _o->rope_max_x_forward;
  auto _rope_max_x_backward = _o->rope_max_x_backward;
  auto _rope_dframe = _o->rope_dframe;
  auto _rope_frame = _o->rope_frame;
  auto _rope_framerate = _o->rope_framerate;
  auto _rope_y = _o->rope_y;
  auto _rope_ptr = _o->rope_ptr;
  auto _interacted_item = _o->interacted_item;
  auto _rope_offset = _o->rope_offset;
  auto _rope_down_vel = _o->rope_down_vel;
  auto _rope_flag = _o->rope_flag;
  auto _rope_count = _o->rope_count;
  auto _move_count = _o->move_count;
  auto _location = _o->location;
  auto _highest_location = _o->highest_location;
  auto _location_pad = _o->location_pad;
  auto _tightrope = _o->tightrope ? CreateLaraTightropeInfo(_fbb, _o->tightrope.get(), _rehasher) : 0;
  auto _beetle_life = _o->beetle_life;
  auto _has_beetle_things = _o->has_beetle_things;
  auto _small_waterskin = _o->small_waterskin;
  auto _big_waterskin = _o->big_waterskin;
  auto _vehicle = _o->vehicle;
  auto _extra_anim = _o->extra_anim;
  auto _mine_l = _o->mine_l;
  auto _mine_r = _o->mine_r;
  auto _weapons = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::CarriedWeaponInfo>> (_o->weapons.size(), [](size_t i, _VectorArgs *__va) { return CreateCarriedWeaponInfo(*__va->__fbb, __va->__o->weapons[i].get(), __va->__rehasher); }, &_va );
  auto _puzzles = _fbb.CreateVector(_o->puzzles);
  auto _keys = _fbb.CreateVector(_o->keys);
  auto _pickups = _fbb.CreateVector(_o->pickups);
  auto _examines = _fbb.CreateVector(_o->examines);
  auto _puzzles_combo = _fbb.CreateVector(_o->puzzles_combo);
  auto _keys_combo = _fbb.CreateVector(_o->keys_combo);
  auto _pickups_combo = _fbb.CreateVector(_o->pickups_combo);
  auto _examines_combo = _fbb.CreateVector(_o->examines_combo);
  auto _secrets = _o->secrets;
  auto _lasersight = _o->lasersight;
  auto _crowbar = _o->crowbar;
  auto _torch = _o->torch;
  auto _silencer = _o->silencer;
  auto _binoculars = _o->binoculars;
  auto _num_large_medipacks = _o->num_large_medipacks;
  auto _num_small_medipacks = _o->num_small_medipacks;
  auto _num_flares = _o->num_flares;
  auto _target_item_number = _o->target_item_number;
  return TEN::Save::CreateLara(
      _fbb,
      _item_number,
      _gun_status,
      _gun_type,
      _request_gun_type,
      _last_gun_type,
      _hit_points,
      _speed,
      _fall_speed,
      _calc_fall_speed,
      _water_status,
      _climb_status,
      _pose_count,
      _jump_count,
      _jump_queued,
      _hit_frame,
      _hit_direction,
      _sprint_timer,
      _air,
      _dive_count,
      _death_count,
      _current_active,
      _current_x_vel,
      _current_y_vel,
      _current_z_vel,
      _spaz_effect_count,
      _flare_age,
      _burn_count,
      _weapon_item,
      _holster_info,
      _flare_frame,
      _poisoned,
      _wet,
      _flare_control_left,
      _look,
      _burn,
      _keep_crouched,
      _is_moving,
      _can_monkey_swing,
      _burn_blue,
      _burn_smoke,
      _is_ducked,
      _has_fired,
      _busy,
      _old_busy,
      _uncontrollable,
      _lit_torch,
      _is_climbing,
      _fired,
      _water_surface_dist,
      _last_position,
      _next_corner_position,
      _next_corner_rotation,
      _mesh_ptrs,
      _target_angles,
      _turn_rate,
      _move_angle,
      _head_x_rot,
      _head_y_rot,
      _head_z_rot,
      _torso_x_rot,
      _torso_y_rot,
      _torso_z_rot,
      _left_arm,
      _right_arm,
      _rope_segment,
      _rope_direction,
      _rope_arc_front,
      _rope_arc_back,
      _rope_last_x,
      _rope_max_x_forward,
      _rope_max_x_backward,
      _rope_dframe,
      _rope_frame,
      _rope_framerate,
      _rope_y,
      _rope_ptr,
      _interacted_item,
      _rope_offset,
      _rope_down_vel,
      _rope_flag,
      _rope_count,
      _move_count,
      _location,
      _highest_location,
      _location_pad,
      _tightrope,
      _beetle_life,
      _has_beetle_things,
      _small_waterskin,
      _big_waterskin,
      _vehicle,
      _extra_anim,
      _mine_l,
      _mine_r,
      _weapons,
      _puzzles,
      _keys,
      _pickups,
      _examines,
      _puzzles_combo,
      _keys_combo,
      _pickups_combo,
      _examines_combo,
      _secrets,
      _lasersight,
      _crowbar,
      _torch,
      _silencer,
      _binoculars,
      _num_large_medipacks,
      _num_small_medipacks,
      _num_flares,
      _target_item_number);
}

inline FixedCameraT *FixedCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FixedCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FixedCamera::UnPackTo(FixedCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FixedCamera> FixedCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixedCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FixedCamera> CreateFixedCamera(flatbuffers::FlatBufferBuilder &_fbb, const FixedCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FixedCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFixedCamera(
      _fbb,
      _flags);
}

inline FlyByCameraT *FlyByCamera::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FlyByCameraT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlyByCamera::UnPackTo(FlyByCameraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<FlyByCamera> FlyByCamera::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlyByCamera(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlyByCamera> CreateFlyByCamera(flatbuffers::FlatBufferBuilder &_fbb, const FlyByCameraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlyByCameraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateFlyByCamera(
      _fbb,
      _flags);
}

inline SinkT *Sink::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SinkT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sink::UnPackTo(SinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<Sink> Sink::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sink> CreateSink(flatbuffers::FlatBufferBuilder &_fbb, const SinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  return TEN::Save::CreateSink(
      _fbb,
      _flags);
}

inline StaticMeshInfoT *StaticMeshInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StaticMeshInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StaticMeshInfo::UnPackTo(StaticMeshInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<StaticMeshInfo> StaticMeshInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStaticMeshInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StaticMeshInfo> CreateStaticMeshInfo(flatbuffers::FlatBufferBuilder &_fbb, const StaticMeshInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StaticMeshInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateStaticMeshInfo(
      _fbb,
      _room_number,
      _flags);
}

inline RatInfoT *RatInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RatInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RatInfo::UnPackTo(RatInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<RatInfo> RatInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRatInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RatInfo> CreateRatInfo(flatbuffers::FlatBufferBuilder &_fbb, const RatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RatInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateRatInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline SpiderInfoT *SpiderInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SpiderInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpiderInfo::UnPackTo(SpiderInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<SpiderInfo> SpiderInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpiderInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpiderInfo> CreateSpiderInfo(flatbuffers::FlatBufferBuilder &_fbb, const SpiderInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpiderInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateSpiderInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline ScarabInfoT *ScarabInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ScarabInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScarabInfo::UnPackTo(ScarabInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
}

inline flatbuffers::Offset<ScarabInfo> ScarabInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScarabInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScarabInfo> CreateScarabInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScarabInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScarabInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _flags = _o->flags;
  return TEN::Save::CreateScarabInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _flags);
}

inline BatInfoT *BatInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BatInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatInfo::UnPackTo(BatInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = on(); _o->on = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = x_rot(); _o->x_rot = _e; }
  { auto _e = y_rot(); _o->y_rot = _e; }
  { auto _e = z_rot(); _o->z_rot = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = counter(); _o->counter = _e; }
}

inline flatbuffers::Offset<BatInfo> BatInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatInfo> CreateBatInfo(flatbuffers::FlatBufferBuilder &_fbb, const BatInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _on = _o->on;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _x_rot = _o->x_rot;
  auto _y_rot = _o->y_rot;
  auto _z_rot = _o->z_rot;
  auto _room_number = _o->room_number;
  auto _counter = _o->counter;
  return TEN::Save::CreateBatInfo(
      _fbb,
      _on,
      _x,
      _y,
      _z,
      _x_rot,
      _y_rot,
      _z_rot,
      _room_number,
      _counter);
}

inline RopeT *Rope::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RopeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rope::UnPackTo(RopeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = segments(); if (_e) { _o->segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->segments[_i] = *_e->Get(_i); } } }
  { auto _e = velocities(); if (_e) { _o->velocities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->velocities[_i] = *_e->Get(_i); } } }
  { auto _e = normalised_segments(); if (_e) { _o->normalised_segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normalised_segments[_i] = *_e->Get(_i); } } }
  { auto _e = mesh_segments(); if (_e) { _o->mesh_segments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mesh_segments[_i] = *_e->Get(_i); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = coords(); if (_e) { _o->coords.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coords[_i] = *_e->Get(_i); } } }
  { auto _e = segment_length(); _o->segment_length = _e; }
  { auto _e = active(); _o->active = _e; }
  { auto _e = coiled(); _o->coiled = _e; }
}

inline flatbuffers::Offset<Rope> Rope::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RopeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRope(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rope> CreateRope(flatbuffers::FlatBufferBuilder &_fbb, const RopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RopeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _segments = _fbb.CreateVectorOfStructs(_o->segments);
  auto _velocities = _fbb.CreateVectorOfStructs(_o->velocities);
  auto _normalised_segments = _fbb.CreateVectorOfStructs(_o->normalised_segments);
  auto _mesh_segments = _fbb.CreateVectorOfStructs(_o->mesh_segments);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _coords = _fbb.CreateVectorOfStructs(_o->coords);
  auto _segment_length = _o->segment_length;
  auto _active = _o->active;
  auto _coiled = _o->coiled;
  return TEN::Save::CreateRope(
      _fbb,
      _segments,
      _velocities,
      _normalised_segments,
      _mesh_segments,
      _position,
      _coords,
      _segment_length,
      _active,
      _coiled);
}

inline PendulumT *Pendulum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PendulumT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pendulum::UnPackTo(PendulumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<TEN::Save::Vector3>(new TEN::Save::Vector3(*_e)); }
  { auto _e = node(); _o->node = _e; }
}

inline flatbuffers::Offset<Pendulum> Pendulum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePendulum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pendulum> CreatePendulum(flatbuffers::FlatBufferBuilder &_fbb, const PendulumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PendulumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  auto _node = _o->node;
  return TEN::Save::CreatePendulum(
      _fbb,
      _position,
      _velocity,
      _node);
}

inline ScriptTableT *ScriptTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ScriptTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScriptTable::UnPackTo(ScriptTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keys_vals(); if (_e) { _o->keys_vals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys_vals[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<ScriptTable> ScriptTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScriptTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScriptTable> CreateScriptTable(flatbuffers::FlatBufferBuilder &_fbb, const ScriptTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScriptTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keys_vals = _fbb.CreateVectorOfStructs(_o->keys_vals);
  return TEN::Save::CreateScriptTable(
      _fbb,
      _keys_vals);
}

inline stringTableT *stringTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<stringTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void stringTable::UnPackTo(stringTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = str(); if (_e) _o->str = _e->str(); }
}

inline flatbuffers::Offset<stringTable> stringTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatestringTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<stringTable> CreatestringTable(flatbuffers::FlatBufferBuilder &_fbb, const stringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const stringTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _str = _o->str.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->str);
  return TEN::Save::CreatestringTable(
      _fbb,
      _str);
}

inline doubleTableT *doubleTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<doubleTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void doubleTable::UnPackTo(doubleTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<doubleTable> doubleTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatedoubleTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<doubleTable> CreatedoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const doubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const doubleTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreatedoubleTable(
      _fbb,
      _scalar);
}

inline UnionTableT *UnionTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionTableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionTable::UnPackTo(UnionTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = u_type(); _o->u.type = _e; }
  { auto _e = u(); if (_e) _o->u.value = TEN::Save::VarUnionUnion::UnPack(_e, u_type(), _resolver); }
}

inline flatbuffers::Offset<UnionTable> UnionTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionTable> CreateUnionTable(flatbuffers::FlatBufferBuilder &_fbb, const UnionTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _u_type = _o->u.type;
  auto _u = _o->u.Pack(_fbb);
  return TEN::Save::CreateUnionTable(
      _fbb,
      _u_type,
      _u);
}

inline UnionVecT *UnionVec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnionVecT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnionVec::UnPackTo(UnionVecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = members(); if (_e) { _o->members.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->members[_i] = std::unique_ptr<TEN::Save::UnionTableT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UnionVec> UnionVec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionVec> CreateUnionVec(flatbuffers::FlatBufferBuilder &_fbb, const UnionVecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionVecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _members = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::UnionTable>> (_o->members.size(), [](size_t i, _VectorArgs *__va) { return CreateUnionTable(*__va->__fbb, __va->__o->members[i].get(), __va->__rehasher); }, &_va );
  return TEN::Save::CreateUnionVec(
      _fbb,
      _members);
}

inline SaveGameHeaderT *SaveGameHeader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameHeaderT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameHeader::UnPackTo(SaveGameHeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level_name(); if (_e) _o->level_name = _e->str(); }
  { auto _e = days(); _o->days = _e; }
  { auto _e = hours(); _o->hours = _e; }
  { auto _e = minutes(); _o->minutes = _e; }
  { auto _e = seconds(); _o->seconds = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = timer(); _o->timer = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<SaveGameHeader> SaveGameHeader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameHeader> CreateSaveGameHeader(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameHeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level_name = _o->level_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->level_name);
  auto _days = _o->days;
  auto _hours = _o->hours;
  auto _minutes = _o->minutes;
  auto _seconds = _o->seconds;
  auto _level = _o->level;
  auto _timer = _o->timer;
  auto _count = _o->count;
  return TEN::Save::CreateSaveGameHeader(
      _fbb,
      _level_name,
      _days,
      _hours,
      _minutes,
      _seconds,
      _level,
      _timer,
      _count);
}

inline SaveGameStatisticsT *SaveGameStatistics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameStatisticsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGameStatistics::UnPackTo(SaveGameStatisticsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ammo_hits(); _o->ammo_hits = _e; }
  { auto _e = ammo_used(); _o->ammo_used = _e; }
  { auto _e = medipacks_used(); _o->medipacks_used = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = kills(); _o->kills = _e; }
  { auto _e = secrets(); _o->secrets = _e; }
  { auto _e = timer(); _o->timer = _e; }
}

inline flatbuffers::Offset<SaveGameStatistics> SaveGameStatistics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGameStatistics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGameStatistics> CreateSaveGameStatistics(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameStatisticsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameStatisticsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ammo_hits = _o->ammo_hits;
  auto _ammo_used = _o->ammo_used;
  auto _medipacks_used = _o->medipacks_used;
  auto _distance = _o->distance;
  auto _kills = _o->kills;
  auto _secrets = _o->secrets;
  auto _timer = _o->timer;
  return TEN::Save::CreateSaveGameStatistics(
      _fbb,
      _ammo_hits,
      _ammo_used,
      _medipacks_used,
      _distance,
      _kills,
      _secrets,
      _timer);
}

inline SaveGameT *SaveGame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveGameT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveGame::UnPackTo(SaveGameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<TEN::Save::SaveGameHeaderT>(_e->UnPack(_resolver)); }
  { auto _e = game(); if (_e) _o->game = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = level(); if (_e) _o->level = std::unique_ptr<TEN::Save::SaveGameStatisticsT>(_e->UnPack(_resolver)); }
  { auto _e = lara(); if (_e) _o->lara = std::unique_ptr<TEN::Save::LaraT>(_e->UnPack(_resolver)); }
  { auto _e = active_weapon(); if (_e) _o->active_weapon = std::unique_ptr<TEN::Save::WeaponInfoT>(_e->UnPack(_resolver)); }
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<TEN::Save::ItemT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = fixed_cameras(); if (_e) { _o->fixed_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fixed_cameras[_i] = std::unique_ptr<TEN::Save::FixedCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = sinks(); if (_e) { _o->sinks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sinks[_i] = std::unique_ptr<TEN::Save::SinkT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = static_meshes(); if (_e) { _o->static_meshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->static_meshes[_i] = std::unique_ptr<TEN::Save::StaticMeshInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flyby_cameras(); if (_e) { _o->flyby_cameras.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flyby_cameras[_i] = std::unique_ptr<TEN::Save::FlyByCameraT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = rats(); if (_e) { _o->rats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rats[_i] = std::unique_ptr<TEN::Save::RatInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = spiders(); if (_e) { _o->spiders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spiders[_i] = std::unique_ptr<TEN::Save::SpiderInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = scarabs(); if (_e) { _o->scarabs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scarabs[_i] = std::unique_ptr<TEN::Save::ScarabInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = bats(); if (_e) { _o->bats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bats[_i] = std::unique_ptr<TEN::Save::BatInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = flip_maps(); if (_e) { _o->flip_maps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_maps[_i] = _e->Get(_i); } } }
  { auto _e = flip_stats(); if (_e) { _o->flip_stats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flip_stats[_i] = _e->Get(_i); } } }
  { auto _e = flip_effect(); _o->flip_effect = _e; }
  { auto _e = flip_timer(); _o->flip_timer = _e; }
  { auto _e = flip_status(); _o->flip_status = _e; }
  { auto _e = ambient_track(); if (_e) _o->ambient_track = _e->str(); }
  { auto _e = ambient_position(); _o->ambient_position = _e; }
  { auto _e = oneshot_track(); if (_e) _o->oneshot_track = _e->str(); }
  { auto _e = oneshot_position(); _o->oneshot_position = _e; }
  { auto _e = cd_flags(); if (_e) { _o->cd_flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cd_flags[_i] = _e->Get(_i); } } }
  { auto _e = rope(); if (_e) _o->rope = std::unique_ptr<TEN::Save::RopeT>(_e->UnPack(_resolver)); }
  { auto _e = pendulum(); if (_e) _o->pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = alternate_pendulum(); if (_e) _o->alternate_pendulum = std::unique_ptr<TEN::Save::PendulumT>(_e->UnPack(_resolver)); }
  { auto _e = script_vars(); if (_e) _o->script_vars = std::unique_ptr<TEN::Save::UnionVecT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<SaveGame> SaveGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SaveGame> CreateSaveGame(flatbuffers::FlatBufferBuilder &_fbb, const SaveGameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SaveGameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _header = _o->header ? CreateSaveGameHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _game = _o->game ? CreateSaveGameStatistics(_fbb, _o->game.get(), _rehasher) : 0;
  auto _level = _o->level ? CreateSaveGameStatistics(_fbb, _o->level.get(), _rehasher) : 0;
  auto _lara = _o->lara ? CreateLara(_fbb, _o->lara.get(), _rehasher) : 0;
  auto _active_weapon = _o->active_weapon ? CreateWeaponInfo(_fbb, _o->active_weapon.get(), _rehasher) : 0;
  auto _items = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Item>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateItem(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va );
  auto _fixed_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FixedCamera>> (_o->fixed_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFixedCamera(*__va->__fbb, __va->__o->fixed_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _sinks = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::Sink>> (_o->sinks.size(), [](size_t i, _VectorArgs *__va) { return CreateSink(*__va->__fbb, __va->__o->sinks[i].get(), __va->__rehasher); }, &_va );
  auto _static_meshes = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::StaticMeshInfo>> (_o->static_meshes.size(), [](size_t i, _VectorArgs *__va) { return CreateStaticMeshInfo(*__va->__fbb, __va->__o->static_meshes[i].get(), __va->__rehasher); }, &_va );
  auto _flyby_cameras = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::FlyByCamera>> (_o->flyby_cameras.size(), [](size_t i, _VectorArgs *__va) { return CreateFlyByCamera(*__va->__fbb, __va->__o->flyby_cameras[i].get(), __va->__rehasher); }, &_va );
  auto _rats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::RatInfo>> (_o->rats.size(), [](size_t i, _VectorArgs *__va) { return CreateRatInfo(*__va->__fbb, __va->__o->rats[i].get(), __va->__rehasher); }, &_va );
  auto _spiders = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::SpiderInfo>> (_o->spiders.size(), [](size_t i, _VectorArgs *__va) { return CreateSpiderInfo(*__va->__fbb, __va->__o->spiders[i].get(), __va->__rehasher); }, &_va );
  auto _scarabs = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::ScarabInfo>> (_o->scarabs.size(), [](size_t i, _VectorArgs *__va) { return CreateScarabInfo(*__va->__fbb, __va->__o->scarabs[i].get(), __va->__rehasher); }, &_va );
  auto _bats = _fbb.CreateVector<flatbuffers::Offset<TEN::Save::BatInfo>> (_o->bats.size(), [](size_t i, _VectorArgs *__va) { return CreateBatInfo(*__va->__fbb, __va->__o->bats[i].get(), __va->__rehasher); }, &_va );
  auto _flip_maps = _fbb.CreateVector(_o->flip_maps);
  auto _flip_stats = _fbb.CreateVector(_o->flip_stats);
  auto _flip_effect = _o->flip_effect;
  auto _flip_timer = _o->flip_timer;
  auto _flip_status = _o->flip_status;
  auto _ambient_track = _o->ambient_track.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->ambient_track);
  auto _ambient_position = _o->ambient_position;
  auto _oneshot_track = _o->oneshot_track.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->oneshot_track);
  auto _oneshot_position = _o->oneshot_position;
  auto _cd_flags = _fbb.CreateVector(_o->cd_flags);
  auto _rope = _o->rope ? CreateRope(_fbb, _o->rope.get(), _rehasher) : 0;
  auto _pendulum = _o->pendulum ? CreatePendulum(_fbb, _o->pendulum.get(), _rehasher) : 0;
  auto _alternate_pendulum = _o->alternate_pendulum ? CreatePendulum(_fbb, _o->alternate_pendulum.get(), _rehasher) : 0;
  auto _script_vars = _o->script_vars ? CreateUnionVec(_fbb, _o->script_vars.get(), _rehasher) : 0;
  return TEN::Save::CreateSaveGame(
      _fbb,
      _header,
      _game,
      _level,
      _lara,
      _active_weapon,
      _items,
      _fixed_cameras,
      _sinks,
      _static_meshes,
      _flyby_cameras,
      _rats,
      _spiders,
      _scarabs,
      _bats,
      _flip_maps,
      _flip_stats,
      _flip_effect,
      _flip_timer,
      _flip_status,
      _ambient_track,
      _ambient_position,
      _oneshot_track,
      _oneshot_position,
      _cd_flags,
      _rope,
      _pendulum,
      _alternate_pendulum,
      _script_vars);
}

inline bool VerifyVarUnion(flatbuffers::Verifier &verifier, const void *obj, VarUnion type) {
  switch (type) {
    case VarUnion::NONE: {
      return true;
    }
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVarUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVarUnion(
        verifier,  values->Get(i), types->GetEnum<VarUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *VarUnionUnion::UnPack(const void *obj, VarUnion type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTable *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> VarUnionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<const TEN::Save::stringTableT *>(value);
      return CreatestringTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<const TEN::Save::ScriptTableT *>(value);
      return CreateScriptTable(_fbb, ptr, _rehasher).Union();
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<const TEN::Save::doubleTableT *>(value);
      return CreatedoubleTable(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline VarUnionUnion::VarUnionUnion(const VarUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case VarUnion::str: {
      value = new TEN::Save::stringTableT(*reinterpret_cast<TEN::Save::stringTableT *>(u.value));
      break;
    }
    case VarUnion::tab: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::ScriptTableT not copyable.
      break;
    }
    case VarUnion::num: {
      value = new TEN::Save::doubleTableT(*reinterpret_cast<TEN::Save::doubleTableT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void VarUnionUnion::Reset() {
  switch (type) {
    case VarUnion::str: {
      auto ptr = reinterpret_cast<TEN::Save::stringTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::tab: {
      auto ptr = reinterpret_cast<TEN::Save::ScriptTableT *>(value);
      delete ptr;
      break;
    }
    case VarUnion::num: {
      auto ptr = reinterpret_cast<TEN::Save::doubleTableT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = VarUnion::NONE;
}

inline const TEN::Save::SaveGame *GetSaveGame(const void *buf) {
  return flatbuffers::GetRoot<TEN::Save::SaveGame>(buf);
}

inline const TEN::Save::SaveGame *GetSizePrefixedSaveGame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<TEN::Save::SaveGame>(buf);
}

inline bool VerifySaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TEN::Save::SaveGame>(nullptr);
}

inline bool VerifySizePrefixedSaveGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TEN::Save::SaveGame>(nullptr);
}

inline void FinishSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSaveGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<TEN::Save::SaveGame> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSaveGame(buf)->UnPack(res));
}

inline std::unique_ptr<TEN::Save::SaveGameT> UnPackSizePrefixedSaveGame(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TEN::Save::SaveGameT>(GetSizePrefixedSaveGame(buf)->UnPack(res));
}

}  // namespace Save
}  // namespace TEN

#endif  // FLATBUFFERS_GENERATED_TENSAVEGAME_TEN_SAVE_H_
