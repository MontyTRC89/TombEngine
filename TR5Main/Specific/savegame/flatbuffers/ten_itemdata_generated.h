// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_
#define FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_

#include "flatbuffers/flatbuffers.h"

namespace TEN {
namespace Save {

struct Position;

struct CreatureTarget;
struct CreatureTargetBuilder;
struct CreatureTargetT;

struct Creature;
struct CreatureBuilder;
struct CreatureT;

struct LaserHead;
struct LaserHeadBuilder;
struct LaserHeadT;

struct QuadBike;
struct QuadBikeBuilder;
struct QuadBikeT;

struct BigGun;
struct BigGunBuilder;
struct BigGunT;

struct Motorbike;
struct MotorbikeBuilder;
struct MotorbikeT;

struct Jeep;
struct JeepBuilder;
struct JeepT;

struct Kayak;
struct KayakBuilder;
struct KayakT;

struct Door;
struct DoorBuilder;
struct DoorT;

struct Skidoo;
struct SkidooBuilder;
struct SkidooT;

struct UPV;
struct UPVBuilder;
struct UPVT;

struct Motorboat;
struct MotorboatBuilder;
struct MotorboatT;

struct GameVector;
struct GameVectorBuilder;
struct GameVectorT;

struct Wraith;
struct WraithBuilder;
struct WraithT;

struct Rubberboat;
struct RubberboatBuilder;
struct RubberboatT;

struct Pushable;
struct PushableBuilder;
struct PushableT;

struct Minecart;
struct MinecartBuilder;
struct MinecartT;

struct LaraInfo;
struct LaraInfoBuilder;
struct LaraInfoT;

struct ItemNumber;
struct ItemNumberBuilder;
struct ItemNumberT;

struct Short;
struct ShortBuilder;
struct ShortT;

struct Int;
struct IntBuilder;
struct IntT;

struct Float;
struct FloatBuilder;
struct FloatT;

struct ShortArray;
struct ShortArrayBuilder;
struct ShortArrayT;

struct Vector3;

enum class ItemData : uint8_t {
  NONE = 0,
  Int = 1,
  Short = 2,
  Float = 3,
  ShortArray = 4,
  ItemNumber = 5,
  Creature = 6,
  LaserHead = 7,
  QuadBike = 8,
  BigGun = 9,
  Motorbike = 10,
  Jeep = 11,
  LaraInfo = 12,
  Kayak = 13,
  Door = 14,
  Skidoo = 15,
  UPV = 16,
  Motorboat = 17,
  GameVector = 18,
  Wraith = 19,
  Rubberboat = 20,
  Pushable = 21,
  Minecart = 22,
  MIN = NONE,
  MAX = Minecart
};

inline const ItemData (&EnumValuesItemData())[23] {
  static const ItemData values[] = {
    ItemData::NONE,
    ItemData::Int,
    ItemData::Short,
    ItemData::Float,
    ItemData::ShortArray,
    ItemData::ItemNumber,
    ItemData::Creature,
    ItemData::LaserHead,
    ItemData::QuadBike,
    ItemData::BigGun,
    ItemData::Motorbike,
    ItemData::Jeep,
    ItemData::LaraInfo,
    ItemData::Kayak,
    ItemData::Door,
    ItemData::Skidoo,
    ItemData::UPV,
    ItemData::Motorboat,
    ItemData::GameVector,
    ItemData::Wraith,
    ItemData::Rubberboat,
    ItemData::Pushable,
    ItemData::Minecart
  };
  return values;
}

inline const char * const *EnumNamesItemData() {
  static const char * const names[24] = {
    "NONE",
    "Int",
    "Short",
    "Float",
    "ShortArray",
    "ItemNumber",
    "Creature",
    "LaserHead",
    "QuadBike",
    "BigGun",
    "Motorbike",
    "Jeep",
    "LaraInfo",
    "Kayak",
    "Door",
    "Skidoo",
    "UPV",
    "Motorboat",
    "GameVector",
    "Wraith",
    "Rubberboat",
    "Pushable",
    "Minecart",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemData(ItemData e) {
  if (flatbuffers::IsOutRange(e, ItemData::NONE, ItemData::Minecart)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemData()[index];
}

template<typename T> struct ItemDataTraits {
  static const ItemData enum_value = ItemData::NONE;
};

template<> struct ItemDataTraits<TEN::Save::Int> {
  static const ItemData enum_value = ItemData::Int;
};

template<> struct ItemDataTraits<TEN::Save::Short> {
  static const ItemData enum_value = ItemData::Short;
};

template<> struct ItemDataTraits<TEN::Save::Float> {
  static const ItemData enum_value = ItemData::Float;
};

template<> struct ItemDataTraits<TEN::Save::ShortArray> {
  static const ItemData enum_value = ItemData::ShortArray;
};

template<> struct ItemDataTraits<TEN::Save::ItemNumber> {
  static const ItemData enum_value = ItemData::ItemNumber;
};

template<> struct ItemDataTraits<TEN::Save::Creature> {
  static const ItemData enum_value = ItemData::Creature;
};

template<> struct ItemDataTraits<TEN::Save::LaserHead> {
  static const ItemData enum_value = ItemData::LaserHead;
};

template<> struct ItemDataTraits<TEN::Save::QuadBike> {
  static const ItemData enum_value = ItemData::QuadBike;
};

template<> struct ItemDataTraits<TEN::Save::BigGun> {
  static const ItemData enum_value = ItemData::BigGun;
};

template<> struct ItemDataTraits<TEN::Save::Motorbike> {
  static const ItemData enum_value = ItemData::Motorbike;
};

template<> struct ItemDataTraits<TEN::Save::Jeep> {
  static const ItemData enum_value = ItemData::Jeep;
};

template<> struct ItemDataTraits<TEN::Save::LaraInfo> {
  static const ItemData enum_value = ItemData::LaraInfo;
};

template<> struct ItemDataTraits<TEN::Save::Kayak> {
  static const ItemData enum_value = ItemData::Kayak;
};

template<> struct ItemDataTraits<TEN::Save::Door> {
  static const ItemData enum_value = ItemData::Door;
};

template<> struct ItemDataTraits<TEN::Save::Skidoo> {
  static const ItemData enum_value = ItemData::Skidoo;
};

template<> struct ItemDataTraits<TEN::Save::UPV> {
  static const ItemData enum_value = ItemData::UPV;
};

template<> struct ItemDataTraits<TEN::Save::Motorboat> {
  static const ItemData enum_value = ItemData::Motorboat;
};

template<> struct ItemDataTraits<TEN::Save::GameVector> {
  static const ItemData enum_value = ItemData::GameVector;
};

template<> struct ItemDataTraits<TEN::Save::Wraith> {
  static const ItemData enum_value = ItemData::Wraith;
};

template<> struct ItemDataTraits<TEN::Save::Rubberboat> {
  static const ItemData enum_value = ItemData::Rubberboat;
};

template<> struct ItemDataTraits<TEN::Save::Pushable> {
  static const ItemData enum_value = ItemData::Pushable;
};

template<> struct ItemDataTraits<TEN::Save::Minecart> {
  static const ItemData enum_value = ItemData::Minecart;
};

struct ItemDataUnion {
  ItemData type;
  void *value;

  ItemDataUnion() : type(ItemData::NONE), value(nullptr) {}
  ItemDataUnion(ItemDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ItemData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ItemDataUnion(const ItemDataUnion &);
  ItemDataUnion &operator=(const ItemDataUnion &u)
    { ItemDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ItemDataUnion &operator=(ItemDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ItemDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ItemDataTraits<typename RT::TableType>::enum_value;
    if (type != ItemData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ItemData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TEN::Save::IntT *AsInt() {
    return type == ItemData::Int ?
      reinterpret_cast<TEN::Save::IntT *>(value) : nullptr;
  }
  const TEN::Save::IntT *AsInt() const {
    return type == ItemData::Int ?
      reinterpret_cast<const TEN::Save::IntT *>(value) : nullptr;
  }
  TEN::Save::ShortT *AsShort() {
    return type == ItemData::Short ?
      reinterpret_cast<TEN::Save::ShortT *>(value) : nullptr;
  }
  const TEN::Save::ShortT *AsShort() const {
    return type == ItemData::Short ?
      reinterpret_cast<const TEN::Save::ShortT *>(value) : nullptr;
  }
  TEN::Save::FloatT *AsFloat() {
    return type == ItemData::Float ?
      reinterpret_cast<TEN::Save::FloatT *>(value) : nullptr;
  }
  const TEN::Save::FloatT *AsFloat() const {
    return type == ItemData::Float ?
      reinterpret_cast<const TEN::Save::FloatT *>(value) : nullptr;
  }
  TEN::Save::ShortArrayT *AsShortArray() {
    return type == ItemData::ShortArray ?
      reinterpret_cast<TEN::Save::ShortArrayT *>(value) : nullptr;
  }
  const TEN::Save::ShortArrayT *AsShortArray() const {
    return type == ItemData::ShortArray ?
      reinterpret_cast<const TEN::Save::ShortArrayT *>(value) : nullptr;
  }
  TEN::Save::ItemNumberT *AsItemNumber() {
    return type == ItemData::ItemNumber ?
      reinterpret_cast<TEN::Save::ItemNumberT *>(value) : nullptr;
  }
  const TEN::Save::ItemNumberT *AsItemNumber() const {
    return type == ItemData::ItemNumber ?
      reinterpret_cast<const TEN::Save::ItemNumberT *>(value) : nullptr;
  }
  TEN::Save::CreatureT *AsCreature() {
    return type == ItemData::Creature ?
      reinterpret_cast<TEN::Save::CreatureT *>(value) : nullptr;
  }
  const TEN::Save::CreatureT *AsCreature() const {
    return type == ItemData::Creature ?
      reinterpret_cast<const TEN::Save::CreatureT *>(value) : nullptr;
  }
  TEN::Save::LaserHeadT *AsLaserHead() {
    return type == ItemData::LaserHead ?
      reinterpret_cast<TEN::Save::LaserHeadT *>(value) : nullptr;
  }
  const TEN::Save::LaserHeadT *AsLaserHead() const {
    return type == ItemData::LaserHead ?
      reinterpret_cast<const TEN::Save::LaserHeadT *>(value) : nullptr;
  }
  TEN::Save::QuadBikeT *AsQuadBike() {
    return type == ItemData::QuadBike ?
      reinterpret_cast<TEN::Save::QuadBikeT *>(value) : nullptr;
  }
  const TEN::Save::QuadBikeT *AsQuadBike() const {
    return type == ItemData::QuadBike ?
      reinterpret_cast<const TEN::Save::QuadBikeT *>(value) : nullptr;
  }
  TEN::Save::BigGunT *AsBigGun() {
    return type == ItemData::BigGun ?
      reinterpret_cast<TEN::Save::BigGunT *>(value) : nullptr;
  }
  const TEN::Save::BigGunT *AsBigGun() const {
    return type == ItemData::BigGun ?
      reinterpret_cast<const TEN::Save::BigGunT *>(value) : nullptr;
  }
  TEN::Save::MotorbikeT *AsMotorbike() {
    return type == ItemData::Motorbike ?
      reinterpret_cast<TEN::Save::MotorbikeT *>(value) : nullptr;
  }
  const TEN::Save::MotorbikeT *AsMotorbike() const {
    return type == ItemData::Motorbike ?
      reinterpret_cast<const TEN::Save::MotorbikeT *>(value) : nullptr;
  }
  TEN::Save::JeepT *AsJeep() {
    return type == ItemData::Jeep ?
      reinterpret_cast<TEN::Save::JeepT *>(value) : nullptr;
  }
  const TEN::Save::JeepT *AsJeep() const {
    return type == ItemData::Jeep ?
      reinterpret_cast<const TEN::Save::JeepT *>(value) : nullptr;
  }
  TEN::Save::LaraInfoT *AsLaraInfo() {
    return type == ItemData::LaraInfo ?
      reinterpret_cast<TEN::Save::LaraInfoT *>(value) : nullptr;
  }
  const TEN::Save::LaraInfoT *AsLaraInfo() const {
    return type == ItemData::LaraInfo ?
      reinterpret_cast<const TEN::Save::LaraInfoT *>(value) : nullptr;
  }
  TEN::Save::KayakT *AsKayak() {
    return type == ItemData::Kayak ?
      reinterpret_cast<TEN::Save::KayakT *>(value) : nullptr;
  }
  const TEN::Save::KayakT *AsKayak() const {
    return type == ItemData::Kayak ?
      reinterpret_cast<const TEN::Save::KayakT *>(value) : nullptr;
  }
  TEN::Save::DoorT *AsDoor() {
    return type == ItemData::Door ?
      reinterpret_cast<TEN::Save::DoorT *>(value) : nullptr;
  }
  const TEN::Save::DoorT *AsDoor() const {
    return type == ItemData::Door ?
      reinterpret_cast<const TEN::Save::DoorT *>(value) : nullptr;
  }
  TEN::Save::SkidooT *AsSkidoo() {
    return type == ItemData::Skidoo ?
      reinterpret_cast<TEN::Save::SkidooT *>(value) : nullptr;
  }
  const TEN::Save::SkidooT *AsSkidoo() const {
    return type == ItemData::Skidoo ?
      reinterpret_cast<const TEN::Save::SkidooT *>(value) : nullptr;
  }
  TEN::Save::UPVT *AsUPV() {
    return type == ItemData::UPV ?
      reinterpret_cast<TEN::Save::UPVT *>(value) : nullptr;
  }
  const TEN::Save::UPVT *AsUPV() const {
    return type == ItemData::UPV ?
      reinterpret_cast<const TEN::Save::UPVT *>(value) : nullptr;
  }
  TEN::Save::MotorboatT *AsMotorboat() {
    return type == ItemData::Motorboat ?
      reinterpret_cast<TEN::Save::MotorboatT *>(value) : nullptr;
  }
  const TEN::Save::MotorboatT *AsMotorboat() const {
    return type == ItemData::Motorboat ?
      reinterpret_cast<const TEN::Save::MotorboatT *>(value) : nullptr;
  }
  TEN::Save::GameVectorT *AsGameVector() {
    return type == ItemData::GameVector ?
      reinterpret_cast<TEN::Save::GameVectorT *>(value) : nullptr;
  }
  const TEN::Save::GameVectorT *AsGameVector() const {
    return type == ItemData::GameVector ?
      reinterpret_cast<const TEN::Save::GameVectorT *>(value) : nullptr;
  }
  TEN::Save::WraithT *AsWraith() {
    return type == ItemData::Wraith ?
      reinterpret_cast<TEN::Save::WraithT *>(value) : nullptr;
  }
  const TEN::Save::WraithT *AsWraith() const {
    return type == ItemData::Wraith ?
      reinterpret_cast<const TEN::Save::WraithT *>(value) : nullptr;
  }
  TEN::Save::RubberboatT *AsRubberboat() {
    return type == ItemData::Rubberboat ?
      reinterpret_cast<TEN::Save::RubberboatT *>(value) : nullptr;
  }
  const TEN::Save::RubberboatT *AsRubberboat() const {
    return type == ItemData::Rubberboat ?
      reinterpret_cast<const TEN::Save::RubberboatT *>(value) : nullptr;
  }
  TEN::Save::PushableT *AsPushable() {
    return type == ItemData::Pushable ?
      reinterpret_cast<TEN::Save::PushableT *>(value) : nullptr;
  }
  const TEN::Save::PushableT *AsPushable() const {
    return type == ItemData::Pushable ?
      reinterpret_cast<const TEN::Save::PushableT *>(value) : nullptr;
  }
  TEN::Save::MinecartT *AsMinecart() {
    return type == ItemData::Minecart ?
      reinterpret_cast<TEN::Save::MinecartT *>(value) : nullptr;
  }
  const TEN::Save::MinecartT *AsMinecart() const {
    return type == ItemData::Minecart ?
      reinterpret_cast<const TEN::Save::MinecartT *>(value) : nullptr;
  }
};

bool VerifyItemData(flatbuffers::Verifier &verifier, const void *obj, ItemData type);
bool VerifyItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_pos_;
  int32_t y_pos_;
  int32_t z_pos_;
  int32_t x_rot_;
  int32_t y_rot_;
  int32_t z_rot_;

 public:
  struct Traits;
  Position()
      : x_pos_(0),
        y_pos_(0),
        z_pos_(0),
        x_rot_(0),
        y_rot_(0),
        z_rot_(0) {
  }
  Position(int32_t _x_pos, int32_t _y_pos, int32_t _z_pos, int32_t _x_rot, int32_t _y_rot, int32_t _z_rot)
      : x_pos_(flatbuffers::EndianScalar(_x_pos)),
        y_pos_(flatbuffers::EndianScalar(_y_pos)),
        z_pos_(flatbuffers::EndianScalar(_z_pos)),
        x_rot_(flatbuffers::EndianScalar(_x_rot)),
        y_rot_(flatbuffers::EndianScalar(_y_rot)),
        z_rot_(flatbuffers::EndianScalar(_z_rot)) {
  }
  int32_t x_pos() const {
    return flatbuffers::EndianScalar(x_pos_);
  }
  int32_t y_pos() const {
    return flatbuffers::EndianScalar(y_pos_);
  }
  int32_t z_pos() const {
    return flatbuffers::EndianScalar(z_pos_);
  }
  int32_t x_rot() const {
    return flatbuffers::EndianScalar(x_rot_);
  }
  int32_t y_rot() const {
    return flatbuffers::EndianScalar(y_rot_);
  }
  int32_t z_rot() const {
    return flatbuffers::EndianScalar(z_rot_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 24);

struct Position::Traits {
  using type = Position;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  struct Traits;
  Vector3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 12);

struct Vector3::Traits {
  using type = Vector3;
};

struct CreatureTargetT : public flatbuffers::NativeTable {
  typedef CreatureTarget TableType;
  int32_t object_number = 0;
  int32_t room_number = 0;
  int32_t box_number = 0;
  int32_t flags = 0;
  int32_t trigger_flags = 0;
  std::unique_ptr<TEN::Save::Position> position{};
};

struct CreatureTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureTargetT NativeTableType;
  typedef CreatureTargetBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NUMBER = 4,
    VT_ROOM_NUMBER = 6,
    VT_BOX_NUMBER = 8,
    VT_FLAGS = 10,
    VT_TRIGGER_FLAGS = 12,
    VT_POSITION = 14
  };
  int32_t object_number() const {
    return GetField<int32_t>(VT_OBJECT_NUMBER, 0);
  }
  int32_t room_number() const {
    return GetField<int32_t>(VT_ROOM_NUMBER, 0);
  }
  int32_t box_number() const {
    return GetField<int32_t>(VT_BOX_NUMBER, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t trigger_flags() const {
    return GetField<int32_t>(VT_TRIGGER_FLAGS, 0);
  }
  const TEN::Save::Position *position() const {
    return GetStruct<const TEN::Save::Position *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECT_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_ROOM_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_BOX_NUMBER) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_TRIGGER_FLAGS) &&
           VerifyField<TEN::Save::Position>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
  CreatureTargetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureTargetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreatureTarget> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureTargetBuilder {
  typedef CreatureTarget Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_number(int32_t object_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_OBJECT_NUMBER, object_number, 0);
  }
  void add_room_number(int32_t room_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_ROOM_NUMBER, room_number, 0);
  }
  void add_box_number(int32_t box_number) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_BOX_NUMBER, box_number, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_FLAGS, flags, 0);
  }
  void add_trigger_flags(int32_t trigger_flags) {
    fbb_.AddElement<int32_t>(CreatureTarget::VT_TRIGGER_FLAGS, trigger_flags, 0);
  }
  void add_position(const TEN::Save::Position *position) {
    fbb_.AddStruct(CreatureTarget::VT_POSITION, position);
  }
  explicit CreatureTargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreatureTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureTarget>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t object_number = 0,
    int32_t room_number = 0,
    int32_t box_number = 0,
    int32_t flags = 0,
    int32_t trigger_flags = 0,
    const TEN::Save::Position *position = 0) {
  CreatureTargetBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_trigger_flags(trigger_flags);
  builder_.add_flags(flags);
  builder_.add_box_number(box_number);
  builder_.add_room_number(room_number);
  builder_.add_object_number(object_number);
  return builder_.Finish();
}

struct CreatureTarget::Traits {
  using type = CreatureTarget;
  static auto constexpr Create = CreateCreatureTarget;
};

flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreatureT : public flatbuffers::NativeTable {
  typedef Creature TableType;
  std::vector<int32_t> joint_rotation{};
  int32_t maximum_turn = 0;
  int32_t flags = 0;
  bool alerted = false;
  bool head_left = false;
  bool head_right = false;
  bool reached_goal = false;
  bool hurt_by_lara = false;
  bool patrol2 = false;
  bool jump_ahead = false;
  bool monkey_ahead = false;
  int32_t mood = 0;
  int32_t enemy = 0;
  std::unique_ptr<TEN::Save::CreatureTargetT> ai_target{};
  bool can_jump = false;
  bool can_monkey = false;
  bool is_amphibious = false;
  bool is_jumping = false;
  bool is_monkeying = false;
};

struct Creature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureT NativeTableType;
  typedef CreatureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINT_ROTATION = 4,
    VT_MAXIMUM_TURN = 6,
    VT_FLAGS = 8,
    VT_ALERTED = 10,
    VT_HEAD_LEFT = 12,
    VT_HEAD_RIGHT = 14,
    VT_REACHED_GOAL = 16,
    VT_HURT_BY_LARA = 18,
    VT_PATROL2 = 20,
    VT_JUMP_AHEAD = 22,
    VT_MONKEY_AHEAD = 24,
    VT_MOOD = 26,
    VT_ENEMY = 28,
    VT_AI_TARGET = 30,
    VT_CAN_JUMP = 32,
    VT_CAN_MONKEY = 34,
    VT_IS_AMPHIBIOUS = 36,
    VT_IS_JUMPING = 38,
    VT_IS_MONKEYING = 40
  };
  const flatbuffers::Vector<int32_t> *joint_rotation() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_JOINT_ROTATION);
  }
  int32_t maximum_turn() const {
    return GetField<int32_t>(VT_MAXIMUM_TURN, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  bool alerted() const {
    return GetField<uint8_t>(VT_ALERTED, 0) != 0;
  }
  bool head_left() const {
    return GetField<uint8_t>(VT_HEAD_LEFT, 0) != 0;
  }
  bool head_right() const {
    return GetField<uint8_t>(VT_HEAD_RIGHT, 0) != 0;
  }
  bool reached_goal() const {
    return GetField<uint8_t>(VT_REACHED_GOAL, 0) != 0;
  }
  bool hurt_by_lara() const {
    return GetField<uint8_t>(VT_HURT_BY_LARA, 0) != 0;
  }
  bool patrol2() const {
    return GetField<uint8_t>(VT_PATROL2, 0) != 0;
  }
  bool jump_ahead() const {
    return GetField<uint8_t>(VT_JUMP_AHEAD, 0) != 0;
  }
  bool monkey_ahead() const {
    return GetField<uint8_t>(VT_MONKEY_AHEAD, 0) != 0;
  }
  int32_t mood() const {
    return GetField<int32_t>(VT_MOOD, 0);
  }
  int32_t enemy() const {
    return GetField<int32_t>(VT_ENEMY, 0);
  }
  const TEN::Save::CreatureTarget *ai_target() const {
    return GetPointer<const TEN::Save::CreatureTarget *>(VT_AI_TARGET);
  }
  bool can_jump() const {
    return GetField<uint8_t>(VT_CAN_JUMP, 0) != 0;
  }
  bool can_monkey() const {
    return GetField<uint8_t>(VT_CAN_MONKEY, 0) != 0;
  }
  bool is_amphibious() const {
    return GetField<uint8_t>(VT_IS_AMPHIBIOUS, 0) != 0;
  }
  bool is_jumping() const {
    return GetField<uint8_t>(VT_IS_JUMPING, 0) != 0;
  }
  bool is_monkeying() const {
    return GetField<uint8_t>(VT_IS_MONKEYING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JOINT_ROTATION) &&
           verifier.VerifyVector(joint_rotation()) &&
           VerifyField<int32_t>(verifier, VT_MAXIMUM_TURN) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_ALERTED) &&
           VerifyField<uint8_t>(verifier, VT_HEAD_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_HEAD_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_REACHED_GOAL) &&
           VerifyField<uint8_t>(verifier, VT_HURT_BY_LARA) &&
           VerifyField<uint8_t>(verifier, VT_PATROL2) &&
           VerifyField<uint8_t>(verifier, VT_JUMP_AHEAD) &&
           VerifyField<uint8_t>(verifier, VT_MONKEY_AHEAD) &&
           VerifyField<int32_t>(verifier, VT_MOOD) &&
           VerifyField<int32_t>(verifier, VT_ENEMY) &&
           VerifyOffset(verifier, VT_AI_TARGET) &&
           verifier.VerifyTable(ai_target()) &&
           VerifyField<uint8_t>(verifier, VT_CAN_JUMP) &&
           VerifyField<uint8_t>(verifier, VT_CAN_MONKEY) &&
           VerifyField<uint8_t>(verifier, VT_IS_AMPHIBIOUS) &&
           VerifyField<uint8_t>(verifier, VT_IS_JUMPING) &&
           VerifyField<uint8_t>(verifier, VT_IS_MONKEYING) &&
           verifier.EndTable();
  }
  CreatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Creature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureBuilder {
  typedef Creature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_joint_rotation(flatbuffers::Offset<flatbuffers::Vector<int32_t>> joint_rotation) {
    fbb_.AddOffset(Creature::VT_JOINT_ROTATION, joint_rotation);
  }
  void add_maximum_turn(int32_t maximum_turn) {
    fbb_.AddElement<int32_t>(Creature::VT_MAXIMUM_TURN, maximum_turn, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Creature::VT_FLAGS, flags, 0);
  }
  void add_alerted(bool alerted) {
    fbb_.AddElement<uint8_t>(Creature::VT_ALERTED, static_cast<uint8_t>(alerted), 0);
  }
  void add_head_left(bool head_left) {
    fbb_.AddElement<uint8_t>(Creature::VT_HEAD_LEFT, static_cast<uint8_t>(head_left), 0);
  }
  void add_head_right(bool head_right) {
    fbb_.AddElement<uint8_t>(Creature::VT_HEAD_RIGHT, static_cast<uint8_t>(head_right), 0);
  }
  void add_reached_goal(bool reached_goal) {
    fbb_.AddElement<uint8_t>(Creature::VT_REACHED_GOAL, static_cast<uint8_t>(reached_goal), 0);
  }
  void add_hurt_by_lara(bool hurt_by_lara) {
    fbb_.AddElement<uint8_t>(Creature::VT_HURT_BY_LARA, static_cast<uint8_t>(hurt_by_lara), 0);
  }
  void add_patrol2(bool patrol2) {
    fbb_.AddElement<uint8_t>(Creature::VT_PATROL2, static_cast<uint8_t>(patrol2), 0);
  }
  void add_jump_ahead(bool jump_ahead) {
    fbb_.AddElement<uint8_t>(Creature::VT_JUMP_AHEAD, static_cast<uint8_t>(jump_ahead), 0);
  }
  void add_monkey_ahead(bool monkey_ahead) {
    fbb_.AddElement<uint8_t>(Creature::VT_MONKEY_AHEAD, static_cast<uint8_t>(monkey_ahead), 0);
  }
  void add_mood(int32_t mood) {
    fbb_.AddElement<int32_t>(Creature::VT_MOOD, mood, 0);
  }
  void add_enemy(int32_t enemy) {
    fbb_.AddElement<int32_t>(Creature::VT_ENEMY, enemy, 0);
  }
  void add_ai_target(flatbuffers::Offset<TEN::Save::CreatureTarget> ai_target) {
    fbb_.AddOffset(Creature::VT_AI_TARGET, ai_target);
  }
  void add_can_jump(bool can_jump) {
    fbb_.AddElement<uint8_t>(Creature::VT_CAN_JUMP, static_cast<uint8_t>(can_jump), 0);
  }
  void add_can_monkey(bool can_monkey) {
    fbb_.AddElement<uint8_t>(Creature::VT_CAN_MONKEY, static_cast<uint8_t>(can_monkey), 0);
  }
  void add_is_amphibious(bool is_amphibious) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_AMPHIBIOUS, static_cast<uint8_t>(is_amphibious), 0);
  }
  void add_is_jumping(bool is_jumping) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_JUMPING, static_cast<uint8_t>(is_jumping), 0);
  }
  void add_is_monkeying(bool is_monkeying) {
    fbb_.AddElement<uint8_t>(Creature::VT_IS_MONKEYING, static_cast<uint8_t>(is_monkeying), 0);
  }
  explicit CreatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Creature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Creature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Creature> CreateCreature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> joint_rotation = 0,
    int32_t maximum_turn = 0,
    int32_t flags = 0,
    bool alerted = false,
    bool head_left = false,
    bool head_right = false,
    bool reached_goal = false,
    bool hurt_by_lara = false,
    bool patrol2 = false,
    bool jump_ahead = false,
    bool monkey_ahead = false,
    int32_t mood = 0,
    int32_t enemy = 0,
    flatbuffers::Offset<TEN::Save::CreatureTarget> ai_target = 0,
    bool can_jump = false,
    bool can_monkey = false,
    bool is_amphibious = false,
    bool is_jumping = false,
    bool is_monkeying = false) {
  CreatureBuilder builder_(_fbb);
  builder_.add_ai_target(ai_target);
  builder_.add_enemy(enemy);
  builder_.add_mood(mood);
  builder_.add_flags(flags);
  builder_.add_maximum_turn(maximum_turn);
  builder_.add_joint_rotation(joint_rotation);
  builder_.add_is_monkeying(is_monkeying);
  builder_.add_is_jumping(is_jumping);
  builder_.add_is_amphibious(is_amphibious);
  builder_.add_can_monkey(can_monkey);
  builder_.add_can_jump(can_jump);
  builder_.add_monkey_ahead(monkey_ahead);
  builder_.add_jump_ahead(jump_ahead);
  builder_.add_patrol2(patrol2);
  builder_.add_hurt_by_lara(hurt_by_lara);
  builder_.add_reached_goal(reached_goal);
  builder_.add_head_right(head_right);
  builder_.add_head_left(head_left);
  builder_.add_alerted(alerted);
  return builder_.Finish();
}

struct Creature::Traits {
  using type = Creature;
  static auto constexpr Create = CreateCreature;
};

inline flatbuffers::Offset<Creature> CreateCreatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *joint_rotation = nullptr,
    int32_t maximum_turn = 0,
    int32_t flags = 0,
    bool alerted = false,
    bool head_left = false,
    bool head_right = false,
    bool reached_goal = false,
    bool hurt_by_lara = false,
    bool patrol2 = false,
    bool jump_ahead = false,
    bool monkey_ahead = false,
    int32_t mood = 0,
    int32_t enemy = 0,
    flatbuffers::Offset<TEN::Save::CreatureTarget> ai_target = 0,
    bool can_jump = false,
    bool can_monkey = false,
    bool is_amphibious = false,
    bool is_jumping = false,
    bool is_monkeying = false) {
  auto joint_rotation__ = joint_rotation ? _fbb.CreateVector<int32_t>(*joint_rotation) : 0;
  return TEN::Save::CreateCreature(
      _fbb,
      joint_rotation__,
      maximum_turn,
      flags,
      alerted,
      head_left,
      head_right,
      reached_goal,
      hurt_by_lara,
      patrol2,
      jump_ahead,
      monkey_ahead,
      mood,
      enemy,
      ai_target,
      can_jump,
      can_monkey,
      is_amphibious,
      is_jumping,
      is_monkeying);
}

flatbuffers::Offset<Creature> CreateCreature(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserHeadT : public flatbuffers::NativeTable {
  typedef LaserHead TableType;
};

struct LaserHead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaserHeadT NativeTableType;
  typedef LaserHeadBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LaserHeadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserHeadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaserHead> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserHeadBuilder {
  typedef LaserHead Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LaserHeadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaserHead> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaserHead>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaserHead> CreateLaserHead(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LaserHeadBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LaserHead::Traits {
  using type = LaserHead;
  static auto constexpr Create = CreateLaserHead;
};

flatbuffers::Offset<LaserHead> CreateLaserHead(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuadBikeT : public flatbuffers::NativeTable {
  typedef QuadBike TableType;
};

struct QuadBike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuadBikeT NativeTableType;
  typedef QuadBikeBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  QuadBikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuadBikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuadBike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuadBikeBuilder {
  typedef QuadBike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit QuadBikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuadBike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuadBike>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuadBike> CreateQuadBike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  QuadBikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct QuadBike::Traits {
  using type = QuadBike;
  static auto constexpr Create = CreateQuadBike;
};

flatbuffers::Offset<QuadBike> CreateQuadBike(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BigGunT : public flatbuffers::NativeTable {
  typedef BigGun TableType;
};

struct BigGun FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BigGunT NativeTableType;
  typedef BigGunBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BigGunT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BigGunT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BigGun> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BigGunBuilder {
  typedef BigGun Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BigGunBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BigGun> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BigGun>(end);
    return o;
  }
};

inline flatbuffers::Offset<BigGun> CreateBigGun(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BigGunBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BigGun::Traits {
  using type = BigGun;
  static auto constexpr Create = CreateBigGun;
};

flatbuffers::Offset<BigGun> CreateBigGun(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotorbikeT : public flatbuffers::NativeTable {
  typedef Motorbike TableType;
};

struct Motorbike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotorbikeT NativeTableType;
  typedef MotorbikeBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MotorbikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotorbikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Motorbike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MotorbikeBuilder {
  typedef Motorbike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MotorbikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Motorbike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Motorbike>(end);
    return o;
  }
};

inline flatbuffers::Offset<Motorbike> CreateMotorbike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MotorbikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Motorbike::Traits {
  using type = Motorbike;
  static auto constexpr Create = CreateMotorbike;
};

flatbuffers::Offset<Motorbike> CreateMotorbike(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JeepT : public flatbuffers::NativeTable {
  typedef Jeep TableType;
};

struct Jeep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JeepT NativeTableType;
  typedef JeepBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  JeepT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JeepT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Jeep> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JeepT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JeepBuilder {
  typedef Jeep Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit JeepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Jeep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Jeep>(end);
    return o;
  }
};

inline flatbuffers::Offset<Jeep> CreateJeep(
    flatbuffers::FlatBufferBuilder &_fbb) {
  JeepBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Jeep::Traits {
  using type = Jeep;
  static auto constexpr Create = CreateJeep;
};

flatbuffers::Offset<Jeep> CreateJeep(flatbuffers::FlatBufferBuilder &_fbb, const JeepT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KayakT : public flatbuffers::NativeTable {
  typedef Kayak TableType;
};

struct Kayak FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KayakT NativeTableType;
  typedef KayakBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  KayakT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KayakT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Kayak> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KayakT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KayakBuilder {
  typedef Kayak Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit KayakBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Kayak> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Kayak>(end);
    return o;
  }
};

inline flatbuffers::Offset<Kayak> CreateKayak(
    flatbuffers::FlatBufferBuilder &_fbb) {
  KayakBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Kayak::Traits {
  using type = Kayak;
  static auto constexpr Create = CreateKayak;
};

flatbuffers::Offset<Kayak> CreateKayak(flatbuffers::FlatBufferBuilder &_fbb, const KayakT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DoorT : public flatbuffers::NativeTable {
  typedef Door TableType;
};

struct Door FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoorT NativeTableType;
  typedef DoorBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DoorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Door> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoorBuilder {
  typedef Door Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DoorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Door> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Door>(end);
    return o;
  }
};

inline flatbuffers::Offset<Door> CreateDoor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DoorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Door::Traits {
  using type = Door;
  static auto constexpr Create = CreateDoor;
};

flatbuffers::Offset<Door> CreateDoor(flatbuffers::FlatBufferBuilder &_fbb, const DoorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkidooT : public flatbuffers::NativeTable {
  typedef Skidoo TableType;
};

struct Skidoo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkidooT NativeTableType;
  typedef SkidooBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SkidooT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkidooT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Skidoo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkidooBuilder {
  typedef Skidoo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkidooBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Skidoo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Skidoo>(end);
    return o;
  }
};

inline flatbuffers::Offset<Skidoo> CreateSkidoo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkidooBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Skidoo::Traits {
  using type = Skidoo;
  static auto constexpr Create = CreateSkidoo;
};

flatbuffers::Offset<Skidoo> CreateSkidoo(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPVT : public flatbuffers::NativeTable {
  typedef UPV TableType;
};

struct UPV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPVT NativeTableType;
  typedef UPVBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UPVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPVBuilder {
  typedef UPV Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UPVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UPV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPV>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPV> CreateUPV(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UPVBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UPV::Traits {
  using type = UPV;
  static auto constexpr Create = CreateUPV;
};

flatbuffers::Offset<UPV> CreateUPV(flatbuffers::FlatBufferBuilder &_fbb, const UPVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotorboatT : public flatbuffers::NativeTable {
  typedef Motorboat TableType;
};

struct Motorboat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotorboatT NativeTableType;
  typedef MotorboatBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MotorboatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotorboatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Motorboat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MotorboatBuilder {
  typedef Motorboat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MotorboatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Motorboat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Motorboat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Motorboat> CreateMotorboat(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MotorboatBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Motorboat::Traits {
  using type = Motorboat;
  static auto constexpr Create = CreateMotorboat;
};

flatbuffers::Offset<Motorboat> CreateMotorboat(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameVectorT : public flatbuffers::NativeTable {
  typedef GameVector TableType;
};

struct GameVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GameVectorT NativeTableType;
  typedef GameVectorBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GameVectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameVectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GameVector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameVectorBuilder {
  typedef GameVector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GameVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GameVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameVector> CreateGameVector(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GameVectorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GameVector::Traits {
  using type = GameVector;
  static auto constexpr Create = CreateGameVector;
};

flatbuffers::Offset<GameVector> CreateGameVector(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WraithT : public flatbuffers::NativeTable {
  typedef Wraith TableType;
};

struct Wraith FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WraithT NativeTableType;
  typedef WraithBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WraithT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WraithT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Wraith> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WraithT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WraithBuilder {
  typedef Wraith Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WraithBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Wraith> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Wraith>(end);
    return o;
  }
};

inline flatbuffers::Offset<Wraith> CreateWraith(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WraithBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Wraith::Traits {
  using type = Wraith;
  static auto constexpr Create = CreateWraith;
};

flatbuffers::Offset<Wraith> CreateWraith(flatbuffers::FlatBufferBuilder &_fbb, const WraithT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RubberboatT : public flatbuffers::NativeTable {
  typedef Rubberboat TableType;
};

struct Rubberboat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RubberboatT NativeTableType;
  typedef RubberboatBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RubberboatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RubberboatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rubberboat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RubberboatBuilder {
  typedef Rubberboat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RubberboatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rubberboat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rubberboat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rubberboat> CreateRubberboat(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RubberboatBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rubberboat::Traits {
  using type = Rubberboat;
  static auto constexpr Create = CreateRubberboat;
};

flatbuffers::Offset<Rubberboat> CreateRubberboat(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PushableT : public flatbuffers::NativeTable {
  typedef Pushable TableType;
};

struct Pushable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PushableT NativeTableType;
  typedef PushableBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PushableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PushableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pushable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PushableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PushableBuilder {
  typedef Pushable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PushableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pushable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pushable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pushable> CreatePushable(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PushableBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Pushable::Traits {
  using type = Pushable;
  static auto constexpr Create = CreatePushable;
};

flatbuffers::Offset<Pushable> CreatePushable(flatbuffers::FlatBufferBuilder &_fbb, const PushableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinecartT : public flatbuffers::NativeTable {
  typedef Minecart TableType;
};

struct Minecart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinecartT NativeTableType;
  typedef MinecartBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinecartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinecartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Minecart> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinecartBuilder {
  typedef Minecart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinecartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Minecart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minecart>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minecart> CreateMinecart(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinecartBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Minecart::Traits {
  using type = Minecart;
  static auto constexpr Create = CreateMinecart;
};

flatbuffers::Offset<Minecart> CreateMinecart(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaraInfoT : public flatbuffers::NativeTable {
  typedef LaraInfo TableType;
};

struct LaraInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaraInfoT NativeTableType;
  typedef LaraInfoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LaraInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaraInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaraInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaraInfoBuilder {
  typedef LaraInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LaraInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaraInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaraInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LaraInfo> CreateLaraInfo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LaraInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LaraInfo::Traits {
  using type = LaraInfo;
  static auto constexpr Create = CreateLaraInfo;
};

flatbuffers::Offset<LaraInfo> CreateLaraInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemNumberT : public flatbuffers::NativeTable {
  typedef ItemNumber TableType;
  int16_t num = 0;
};

struct ItemNumber FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemNumberT NativeTableType;
  typedef ItemNumberBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4
  };
  int16_t num() const {
    return GetField<int16_t>(VT_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_NUM) &&
           verifier.EndTable();
  }
  ItemNumberT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemNumberT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemNumber> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemNumberBuilder {
  typedef ItemNumber Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int16_t num) {
    fbb_.AddElement<int16_t>(ItemNumber::VT_NUM, num, 0);
  }
  explicit ItemNumberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemNumber>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemNumber> CreateItemNumber(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t num = 0) {
  ItemNumberBuilder builder_(_fbb);
  builder_.add_num(num);
  return builder_.Finish();
}

struct ItemNumber::Traits {
  using type = ItemNumber;
  static auto constexpr Create = CreateItemNumber;
};

flatbuffers::Offset<ItemNumber> CreateItemNumber(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShortT : public flatbuffers::NativeTable {
  typedef Short TableType;
  int16_t scalar = 0;
};

struct Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortT NativeTableType;
  typedef ShortBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  int16_t scalar() const {
    return GetField<int16_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  ShortT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShortT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Short> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShortBuilder {
  typedef Short Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(int16_t scalar) {
    fbb_.AddElement<int16_t>(Short::VT_SCALAR, scalar, 0);
  }
  explicit ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline flatbuffers::Offset<Short> CreateShort(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t scalar = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Short::Traits {
  using type = Short;
  static auto constexpr Create = CreateShort;
};

flatbuffers::Offset<Short> CreateShort(flatbuffers::FlatBufferBuilder &_fbb, const ShortT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntT : public flatbuffers::NativeTable {
  typedef Int TableType;
  uint64_t scalar = 0;
};

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntT NativeTableType;
  typedef IntBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  uint64_t scalar() const {
    return GetField<uint64_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  IntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Int> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntBuilder {
  typedef Int Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(uint64_t scalar) {
    fbb_.AddElement<uint64_t>(Int::VT_SCALAR, scalar, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t scalar = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Int::Traits {
  using type = Int;
  static auto constexpr Create = CreateInt;
};

flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb, const IntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatT : public flatbuffers::NativeTable {
  typedef Float TableType;
  double scalar = 0.0;
};

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatT NativeTableType;
  typedef FloatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR = 4
  };
  double scalar() const {
    return GetField<double>(VT_SCALAR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
  FloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Float> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatBuilder {
  typedef Float Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scalar(double scalar) {
    fbb_.AddElement<double>(Float::VT_SCALAR, scalar, 0.0);
  }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float> CreateFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scalar = 0.0) {
  FloatBuilder builder_(_fbb);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

struct Float::Traits {
  using type = Float;
  static auto constexpr Create = CreateFloat;
};

flatbuffers::Offset<Float> CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, const FloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShortArrayT : public flatbuffers::NativeTable {
  typedef ShortArray TableType;
  std::vector<int16_t> arr{};
};

struct ShortArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortArrayT NativeTableType;
  typedef ShortArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARR = 4
  };
  const flatbuffers::Vector<int16_t> *arr() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_ARR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARR) &&
           verifier.VerifyVector(arr()) &&
           verifier.EndTable();
  }
  ShortArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShortArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShortArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShortArrayBuilder {
  typedef ShortArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arr(flatbuffers::Offset<flatbuffers::Vector<int16_t>> arr) {
    fbb_.AddOffset(ShortArray::VT_ARR, arr);
  }
  explicit ShortArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShortArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortArray> CreateShortArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> arr = 0) {
  ShortArrayBuilder builder_(_fbb);
  builder_.add_arr(arr);
  return builder_.Finish();
}

struct ShortArray::Traits {
  using type = ShortArray;
  static auto constexpr Create = CreateShortArray;
};

inline flatbuffers::Offset<ShortArray> CreateShortArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *arr = nullptr) {
  auto arr__ = arr ? _fbb.CreateVector<int16_t>(*arr) : 0;
  return TEN::Save::CreateShortArray(
      _fbb,
      arr__);
}

flatbuffers::Offset<ShortArray> CreateShortArray(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CreatureTargetT *CreatureTarget::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CreatureTargetT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreatureTarget::UnPackTo(CreatureTargetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_number(); _o->object_number = _e; }
  { auto _e = room_number(); _o->room_number = _e; }
  { auto _e = box_number(); _o->box_number = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = trigger_flags(); _o->trigger_flags = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<TEN::Save::Position>(new TEN::Save::Position(*_e)); }
}

inline flatbuffers::Offset<CreatureTarget> CreatureTarget::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreatureTarget(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreatureTarget> CreateCreatureTarget(flatbuffers::FlatBufferBuilder &_fbb, const CreatureTargetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureTargetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_number = _o->object_number;
  auto _room_number = _o->room_number;
  auto _box_number = _o->box_number;
  auto _flags = _o->flags;
  auto _trigger_flags = _o->trigger_flags;
  auto _position = _o->position ? _o->position.get() : 0;
  return TEN::Save::CreateCreatureTarget(
      _fbb,
      _object_number,
      _room_number,
      _box_number,
      _flags,
      _trigger_flags,
      _position);
}

inline CreatureT *Creature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CreatureT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Creature::UnPackTo(CreatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = joint_rotation(); if (_e) { _o->joint_rotation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->joint_rotation[_i] = _e->Get(_i); } } }
  { auto _e = maximum_turn(); _o->maximum_turn = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = alerted(); _o->alerted = _e; }
  { auto _e = head_left(); _o->head_left = _e; }
  { auto _e = head_right(); _o->head_right = _e; }
  { auto _e = reached_goal(); _o->reached_goal = _e; }
  { auto _e = hurt_by_lara(); _o->hurt_by_lara = _e; }
  { auto _e = patrol2(); _o->patrol2 = _e; }
  { auto _e = jump_ahead(); _o->jump_ahead = _e; }
  { auto _e = monkey_ahead(); _o->monkey_ahead = _e; }
  { auto _e = mood(); _o->mood = _e; }
  { auto _e = enemy(); _o->enemy = _e; }
  { auto _e = ai_target(); if (_e) _o->ai_target = std::unique_ptr<TEN::Save::CreatureTargetT>(_e->UnPack(_resolver)); }
  { auto _e = can_jump(); _o->can_jump = _e; }
  { auto _e = can_monkey(); _o->can_monkey = _e; }
  { auto _e = is_amphibious(); _o->is_amphibious = _e; }
  { auto _e = is_jumping(); _o->is_jumping = _e; }
  { auto _e = is_monkeying(); _o->is_monkeying = _e; }
}

inline flatbuffers::Offset<Creature> Creature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Creature> CreateCreature(flatbuffers::FlatBufferBuilder &_fbb, const CreatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _joint_rotation = _fbb.CreateVector(_o->joint_rotation);
  auto _maximum_turn = _o->maximum_turn;
  auto _flags = _o->flags;
  auto _alerted = _o->alerted;
  auto _head_left = _o->head_left;
  auto _head_right = _o->head_right;
  auto _reached_goal = _o->reached_goal;
  auto _hurt_by_lara = _o->hurt_by_lara;
  auto _patrol2 = _o->patrol2;
  auto _jump_ahead = _o->jump_ahead;
  auto _monkey_ahead = _o->monkey_ahead;
  auto _mood = _o->mood;
  auto _enemy = _o->enemy;
  auto _ai_target = _o->ai_target ? CreateCreatureTarget(_fbb, _o->ai_target.get(), _rehasher) : 0;
  auto _can_jump = _o->can_jump;
  auto _can_monkey = _o->can_monkey;
  auto _is_amphibious = _o->is_amphibious;
  auto _is_jumping = _o->is_jumping;
  auto _is_monkeying = _o->is_monkeying;
  return TEN::Save::CreateCreature(
      _fbb,
      _joint_rotation,
      _maximum_turn,
      _flags,
      _alerted,
      _head_left,
      _head_right,
      _reached_goal,
      _hurt_by_lara,
      _patrol2,
      _jump_ahead,
      _monkey_ahead,
      _mood,
      _enemy,
      _ai_target,
      _can_jump,
      _can_monkey,
      _is_amphibious,
      _is_jumping,
      _is_monkeying);
}

inline LaserHeadT *LaserHead::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaserHeadT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserHead::UnPackTo(LaserHeadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LaserHead> LaserHead::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserHead(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaserHead> CreateLaserHead(flatbuffers::FlatBufferBuilder &_fbb, const LaserHeadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaserHeadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateLaserHead(
      _fbb);
}

inline QuadBikeT *QuadBike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<QuadBikeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuadBike::UnPackTo(QuadBikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<QuadBike> QuadBike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuadBike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuadBike> CreateQuadBike(flatbuffers::FlatBufferBuilder &_fbb, const QuadBikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuadBikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateQuadBike(
      _fbb);
}

inline BigGunT *BigGun::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BigGunT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BigGun::UnPackTo(BigGunT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BigGun> BigGun::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBigGun(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BigGun> CreateBigGun(flatbuffers::FlatBufferBuilder &_fbb, const BigGunT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BigGunT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateBigGun(
      _fbb);
}

inline MotorbikeT *Motorbike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MotorbikeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Motorbike::UnPackTo(MotorbikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Motorbike> Motorbike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotorbike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Motorbike> CreateMotorbike(flatbuffers::FlatBufferBuilder &_fbb, const MotorbikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MotorbikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateMotorbike(
      _fbb);
}

inline JeepT *Jeep::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<JeepT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Jeep::UnPackTo(JeepT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Jeep> Jeep::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JeepT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJeep(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Jeep> CreateJeep(flatbuffers::FlatBufferBuilder &_fbb, const JeepT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JeepT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateJeep(
      _fbb);
}

inline KayakT *Kayak::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<KayakT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Kayak::UnPackTo(KayakT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Kayak> Kayak::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KayakT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKayak(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Kayak> CreateKayak(flatbuffers::FlatBufferBuilder &_fbb, const KayakT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KayakT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateKayak(
      _fbb);
}

inline DoorT *Door::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<DoorT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Door::UnPackTo(DoorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Door> Door::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Door> CreateDoor(flatbuffers::FlatBufferBuilder &_fbb, const DoorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DoorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateDoor(
      _fbb);
}

inline SkidooT *Skidoo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SkidooT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Skidoo::UnPackTo(SkidooT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Skidoo> Skidoo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkidoo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Skidoo> CreateSkidoo(flatbuffers::FlatBufferBuilder &_fbb, const SkidooT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkidooT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateSkidoo(
      _fbb);
}

inline UPVT *UPV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UPVT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UPV::UnPackTo(UPVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UPV> UPV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPV> CreateUPV(flatbuffers::FlatBufferBuilder &_fbb, const UPVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateUPV(
      _fbb);
}

inline MotorboatT *Motorboat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MotorboatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Motorboat::UnPackTo(MotorboatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Motorboat> Motorboat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotorboat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Motorboat> CreateMotorboat(flatbuffers::FlatBufferBuilder &_fbb, const MotorboatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MotorboatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateMotorboat(
      _fbb);
}

inline GameVectorT *GameVector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<GameVectorT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GameVector::UnPackTo(GameVectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GameVector> GameVector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGameVector(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GameVector> CreateGameVector(flatbuffers::FlatBufferBuilder &_fbb, const GameVectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GameVectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateGameVector(
      _fbb);
}

inline WraithT *Wraith::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WraithT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Wraith::UnPackTo(WraithT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Wraith> Wraith::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WraithT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWraith(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Wraith> CreateWraith(flatbuffers::FlatBufferBuilder &_fbb, const WraithT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WraithT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateWraith(
      _fbb);
}

inline RubberboatT *Rubberboat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RubberboatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rubberboat::UnPackTo(RubberboatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rubberboat> Rubberboat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRubberboat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rubberboat> CreateRubberboat(flatbuffers::FlatBufferBuilder &_fbb, const RubberboatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RubberboatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateRubberboat(
      _fbb);
}

inline PushableT *Pushable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PushableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pushable::UnPackTo(PushableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Pushable> Pushable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PushableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePushable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pushable> CreatePushable(flatbuffers::FlatBufferBuilder &_fbb, const PushableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PushableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreatePushable(
      _fbb);
}

inline MinecartT *Minecart::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MinecartT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Minecart::UnPackTo(MinecartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Minecart> Minecart::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinecart(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Minecart> CreateMinecart(flatbuffers::FlatBufferBuilder &_fbb, const MinecartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinecartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateMinecart(
      _fbb);
}

inline LaraInfoT *LaraInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LaraInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaraInfo::UnPackTo(LaraInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LaraInfo> LaraInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaraInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaraInfo> CreateLaraInfo(flatbuffers::FlatBufferBuilder &_fbb, const LaraInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaraInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return TEN::Save::CreateLaraInfo(
      _fbb);
}

inline ItemNumberT *ItemNumber::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ItemNumberT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemNumber::UnPackTo(ItemNumberT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
}

inline flatbuffers::Offset<ItemNumber> ItemNumber::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemNumber(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemNumber> CreateItemNumber(flatbuffers::FlatBufferBuilder &_fbb, const ItemNumberT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemNumberT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  return TEN::Save::CreateItemNumber(
      _fbb,
      _num);
}

inline ShortT *Short::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ShortT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Short::UnPackTo(ShortT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Short> Short::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShort(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Short> CreateShort(flatbuffers::FlatBufferBuilder &_fbb, const ShortT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShortT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateShort(
      _fbb,
      _scalar);
}

inline IntT *Int::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<IntT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int::UnPackTo(IntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Int> Int::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb, const IntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateInt(
      _fbb,
      _scalar);
}

inline FloatT *Float::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FloatT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float::UnPackTo(FloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scalar(); _o->scalar = _e; }
}

inline flatbuffers::Offset<Float> Float::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Float> CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, const FloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scalar = _o->scalar;
  return TEN::Save::CreateFloat(
      _fbb,
      _scalar);
}

inline ShortArrayT *ShortArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ShortArrayT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ShortArray::UnPackTo(ShortArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = arr(); if (_e) { _o->arr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arr[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ShortArray> ShortArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShortArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShortArray> CreateShortArray(flatbuffers::FlatBufferBuilder &_fbb, const ShortArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShortArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _arr = _fbb.CreateVector(_o->arr);
  return TEN::Save::CreateShortArray(
      _fbb,
      _arr);
}

inline bool VerifyItemData(flatbuffers::Verifier &verifier, const void *obj, ItemData type) {
  switch (type) {
    case ItemData::NONE: {
      return true;
    }
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::Float *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumber *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::Creature *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHead *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGun *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorbike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::Jeep *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::Kayak *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::Door *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::Skidoo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorboat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::Wraith *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Rubberboat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::Pushable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::Minecart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyItemData(
        verifier,  values->Get(i), types->GetEnum<ItemData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ItemDataUnion::UnPack(const void *obj, ItemData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::Int *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::Short *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::Float *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArray *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumber *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::Creature *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHead *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBike *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGun *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorbike *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::Jeep *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::Kayak *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::Door *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::Skidoo *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPV *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Motorboat *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVector *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::Wraith *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::Rubberboat *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::Pushable *>(obj);
      return ptr->UnPack(resolver);
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::Minecart *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ItemDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<const TEN::Save::IntT *>(value);
      return CreateInt(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortT *>(value);
      return CreateShort(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<const TEN::Save::FloatT *>(value);
      return CreateFloat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<const TEN::Save::ShortArrayT *>(value);
      return CreateShortArray(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<const TEN::Save::ItemNumberT *>(value);
      return CreateItemNumber(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<const TEN::Save::CreatureT *>(value);
      return CreateCreature(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<const TEN::Save::LaserHeadT *>(value);
      return CreateLaserHead(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<const TEN::Save::QuadBikeT *>(value);
      return CreateQuadBike(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<const TEN::Save::BigGunT *>(value);
      return CreateBigGun(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<const TEN::Save::MotorbikeT *>(value);
      return CreateMotorbike(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<const TEN::Save::JeepT *>(value);
      return CreateJeep(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<const TEN::Save::LaraInfoT *>(value);
      return CreateLaraInfo(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<const TEN::Save::KayakT *>(value);
      return CreateKayak(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<const TEN::Save::DoorT *>(value);
      return CreateDoor(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<const TEN::Save::SkidooT *>(value);
      return CreateSkidoo(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<const TEN::Save::UPVT *>(value);
      return CreateUPV(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<const TEN::Save::MotorboatT *>(value);
      return CreateMotorboat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<const TEN::Save::GameVectorT *>(value);
      return CreateGameVector(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<const TEN::Save::WraithT *>(value);
      return CreateWraith(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<const TEN::Save::RubberboatT *>(value);
      return CreateRubberboat(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<const TEN::Save::PushableT *>(value);
      return CreatePushable(_fbb, ptr, _rehasher).Union();
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<const TEN::Save::MinecartT *>(value);
      return CreateMinecart(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ItemDataUnion::ItemDataUnion(const ItemDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ItemData::Int: {
      value = new TEN::Save::IntT(*reinterpret_cast<TEN::Save::IntT *>(u.value));
      break;
    }
    case ItemData::Short: {
      value = new TEN::Save::ShortT(*reinterpret_cast<TEN::Save::ShortT *>(u.value));
      break;
    }
    case ItemData::Float: {
      value = new TEN::Save::FloatT(*reinterpret_cast<TEN::Save::FloatT *>(u.value));
      break;
    }
    case ItemData::ShortArray: {
      value = new TEN::Save::ShortArrayT(*reinterpret_cast<TEN::Save::ShortArrayT *>(u.value));
      break;
    }
    case ItemData::ItemNumber: {
      value = new TEN::Save::ItemNumberT(*reinterpret_cast<TEN::Save::ItemNumberT *>(u.value));
      break;
    }
    case ItemData::Creature: {
      FLATBUFFERS_ASSERT(false);  // TEN::Save::CreatureT not copyable.
      break;
    }
    case ItemData::LaserHead: {
      value = new TEN::Save::LaserHeadT(*reinterpret_cast<TEN::Save::LaserHeadT *>(u.value));
      break;
    }
    case ItemData::QuadBike: {
      value = new TEN::Save::QuadBikeT(*reinterpret_cast<TEN::Save::QuadBikeT *>(u.value));
      break;
    }
    case ItemData::BigGun: {
      value = new TEN::Save::BigGunT(*reinterpret_cast<TEN::Save::BigGunT *>(u.value));
      break;
    }
    case ItemData::Motorbike: {
      value = new TEN::Save::MotorbikeT(*reinterpret_cast<TEN::Save::MotorbikeT *>(u.value));
      break;
    }
    case ItemData::Jeep: {
      value = new TEN::Save::JeepT(*reinterpret_cast<TEN::Save::JeepT *>(u.value));
      break;
    }
    case ItemData::LaraInfo: {
      value = new TEN::Save::LaraInfoT(*reinterpret_cast<TEN::Save::LaraInfoT *>(u.value));
      break;
    }
    case ItemData::Kayak: {
      value = new TEN::Save::KayakT(*reinterpret_cast<TEN::Save::KayakT *>(u.value));
      break;
    }
    case ItemData::Door: {
      value = new TEN::Save::DoorT(*reinterpret_cast<TEN::Save::DoorT *>(u.value));
      break;
    }
    case ItemData::Skidoo: {
      value = new TEN::Save::SkidooT(*reinterpret_cast<TEN::Save::SkidooT *>(u.value));
      break;
    }
    case ItemData::UPV: {
      value = new TEN::Save::UPVT(*reinterpret_cast<TEN::Save::UPVT *>(u.value));
      break;
    }
    case ItemData::Motorboat: {
      value = new TEN::Save::MotorboatT(*reinterpret_cast<TEN::Save::MotorboatT *>(u.value));
      break;
    }
    case ItemData::GameVector: {
      value = new TEN::Save::GameVectorT(*reinterpret_cast<TEN::Save::GameVectorT *>(u.value));
      break;
    }
    case ItemData::Wraith: {
      value = new TEN::Save::WraithT(*reinterpret_cast<TEN::Save::WraithT *>(u.value));
      break;
    }
    case ItemData::Rubberboat: {
      value = new TEN::Save::RubberboatT(*reinterpret_cast<TEN::Save::RubberboatT *>(u.value));
      break;
    }
    case ItemData::Pushable: {
      value = new TEN::Save::PushableT(*reinterpret_cast<TEN::Save::PushableT *>(u.value));
      break;
    }
    case ItemData::Minecart: {
      value = new TEN::Save::MinecartT(*reinterpret_cast<TEN::Save::MinecartT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ItemDataUnion::Reset() {
  switch (type) {
    case ItemData::Int: {
      auto ptr = reinterpret_cast<TEN::Save::IntT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Short: {
      auto ptr = reinterpret_cast<TEN::Save::ShortT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Float: {
      auto ptr = reinterpret_cast<TEN::Save::FloatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::ShortArray: {
      auto ptr = reinterpret_cast<TEN::Save::ShortArrayT *>(value);
      delete ptr;
      break;
    }
    case ItemData::ItemNumber: {
      auto ptr = reinterpret_cast<TEN::Save::ItemNumberT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Creature: {
      auto ptr = reinterpret_cast<TEN::Save::CreatureT *>(value);
      delete ptr;
      break;
    }
    case ItemData::LaserHead: {
      auto ptr = reinterpret_cast<TEN::Save::LaserHeadT *>(value);
      delete ptr;
      break;
    }
    case ItemData::QuadBike: {
      auto ptr = reinterpret_cast<TEN::Save::QuadBikeT *>(value);
      delete ptr;
      break;
    }
    case ItemData::BigGun: {
      auto ptr = reinterpret_cast<TEN::Save::BigGunT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Motorbike: {
      auto ptr = reinterpret_cast<TEN::Save::MotorbikeT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Jeep: {
      auto ptr = reinterpret_cast<TEN::Save::JeepT *>(value);
      delete ptr;
      break;
    }
    case ItemData::LaraInfo: {
      auto ptr = reinterpret_cast<TEN::Save::LaraInfoT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Kayak: {
      auto ptr = reinterpret_cast<TEN::Save::KayakT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Door: {
      auto ptr = reinterpret_cast<TEN::Save::DoorT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Skidoo: {
      auto ptr = reinterpret_cast<TEN::Save::SkidooT *>(value);
      delete ptr;
      break;
    }
    case ItemData::UPV: {
      auto ptr = reinterpret_cast<TEN::Save::UPVT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Motorboat: {
      auto ptr = reinterpret_cast<TEN::Save::MotorboatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::GameVector: {
      auto ptr = reinterpret_cast<TEN::Save::GameVectorT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Wraith: {
      auto ptr = reinterpret_cast<TEN::Save::WraithT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Rubberboat: {
      auto ptr = reinterpret_cast<TEN::Save::RubberboatT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Pushable: {
      auto ptr = reinterpret_cast<TEN::Save::PushableT *>(value);
      delete ptr;
      break;
    }
    case ItemData::Minecart: {
      auto ptr = reinterpret_cast<TEN::Save::MinecartT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ItemData::NONE;
}

}  // namespace Save
}  // namespace TEN

#endif  // FLATBUFFERS_GENERATED_TENITEMDATA_TEN_SAVE_H_
